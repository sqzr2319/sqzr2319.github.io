<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大学物理B(1)</title>
    <link href="/Physics-B1/"/>
    <url>/Physics-B1/</url>
    
    <content type="html"><![CDATA[<p>大一下学期大学物理B(1)的复习笔记，目前更新至相对论。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="一、力学"><a href="#一、力学" class="headerlink" title="一、力学"></a>一、力学</h2><ol><li>牛顿运动定律<ol><li>$v&#x3D;w\times r$</li><li>$[F]&#x3D;MLT^{-2}$</li><li>物体间相对静止 $\Rightarrow$ $a,v$ 相同</li><li>微分方程技巧：两边同乘 $ds$</li><li>科里奥利力：$F&#x3D;2mv\times \omega$</li><li>傅科摆周期：$T&#x3D;\frac{24h}{\sin \phi}$</li></ol></li><li>动量<ol><li>动量定理、动量守恒定律仅适用于惯性系（若要在非惯性系，应考虑惯性力）</li><li>动量若在某一惯性系下守恒，则在任意惯性系下守恒</li><li>系统内力不影响系统总动量</li><li>质心系是零动量参考系</li></ol></li><li>角动量<ol><li>角动量：$L&#x3D;r\times p$</li><li>角动量定理：$\frac{dL}{dt}&#x3D;M&#x3D;r\times F,\int Mdt&#x3D;L_2-L_1$</li><li>角动量守恒：平衡或有心力</li><li>角动量定理、角动量守恒仅适用于惯性系</li><li>系统内力矩不影响系统总角动量</li><li>质点系对原点的角动量$&#x3D;$质心对原点的角动量$+$质点系对质心的角动量</li><li>角动量定理在质心系中适用</li></ol></li><li>功<ol><li>功的数值取决于参考系的选取</li><li>内力能改变系统的总动能</li><li>动能定理、功能原理仅适用于惯性系</li><li>柯尼希定理：质点系总动能$&#x3D;$质心动能$+$质点系相对质心的动能</li><li>一对力的功$&#x3D;$其中一个质点受的力沿着它相对于另一个质点移动的路径所做的功（与参考系的选取无关）</li><li>推论：静摩擦力的功为零、正压力的功为零、滑动摩擦力的功为负</li><li>机械能守恒定律仅适用于惯性系，且在一个惯性系中机械能守恒并不代表在其他惯性系中机械能守恒</li><li>功能原理、机械能守恒定律在质心系中适用</li><li>伯努利原理：$P+\frac{1}{2}\rho v^2+\rho gh&#x3D;\mathrm{const}$</li></ol></li><li>刚体转动<ol><li>一般选取质心或瞬心为基点</li><li>$a&#x3D;\alpha \times r+\omega \times v$（旋转加速度$+$向轴加速度）</li><li>定轴转动定律：$M&#x3D;J\alpha,J&#x3D;\sum m_ir_i^2$</li><li>常用转动惯量<ol><li>细圆环或圆筒：$J&#x3D;mR^2$</li><li>均匀圆盘或圆柱：$J&#x3D;\frac{1}{2}mR^2$</li><li>均匀细杆绕一端转动：$J&#x3D;\frac{1}{3}mL^2$</li><li>均匀细杆绕中点转动：$J&#x3D;\frac{1}{12}mL^2$</li><li>球的转动惯量：$J&#x3D;\frac{2}{5}mR^2$</li></ol></li><li>平行轴定理：$J&#x3D;J_{\mathrm{cm}}+md^2$</li><li>对薄平板的正交轴定理：$J_z&#x3D;J_x+J_y$</li><li>推论：薄圆盘一条直径轴转动：$J&#x3D;\frac{1}{4}mR^2$</li><li>力矩的功：$W&#x3D;\int M\mathrm{d}\theta$</li><li>定轴转动动能：$E_k&#x3D;\frac{1}{2}J\omega^2$</li><li>定轴转动角动量定理：$\frac{\mathrm{d}L}{\mathrm{d}t}&#x3D;\frac{\mathrm{d}(J\omega)}{\mathrm{d}t}&#x3D;M$</li><li>定轴转动角动量守恒：$M&#x3D;0,L&#x3D;J\omega&#x3D;\mathrm{const}$</li></ol></li></ol><h2 id="二、相对论"><a href="#二、相对论" class="headerlink" title="二、相对论"></a>二、相对论</h2><ol><li>同时性的相对性<ol><li>沿着两个惯性系相对运动方向发生的两个事件若在甲惯性系中观察是同时发生的，则在乙惯性系中观察就不是同时发生的，而是在甲惯性系运动的后方的那个事件先发生。</li></ol></li><li>$\mathrm{Lorentz}$ 变换<ol><li>$\displaystyle \gamma&#x3D;\frac{1}{\sqrt{1-\frac{u^2}{c^2}}},\beta&#x3D;\frac{u}{c}$</li><li>$\displaystyle x’&#x3D;\gamma(x-ut),\displaystyle t’&#x3D;\gamma\left(t-\frac{\beta}{c}x\right)$</li><li>$\displaystyle v’_x&#x3D;\frac{v_x-u}{1-\frac{uv_x}{c^2}},v’_y&#x3D;\frac{v_y}{\gamma(1-\frac{uv_x}{c^2})}$</li><li>时空间隔恒等式：$c^2t^2-x^2-y^2-z^2&#x3D;\mathrm{const}.$</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数(2)</title>
    <link href="/LinearAlgebra-2/"/>
    <url>/LinearAlgebra-2/</url>
    
    <content type="html"><![CDATA[<p>大一下学期线性代数(2)的复习笔记，目前更新至 $\mathrm{Jordan}$ 标准形。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="一、基本定义"><a href="#一、基本定义" class="headerlink" title="一、基本定义"></a>一、基本定义</h2><ol><li>复数<ol><li>矩阵形式：$T(a+bi)&#x3D;\begin{pmatrix} a &amp; -b \ b &amp; a \end{pmatrix}$，$T$ 保持加法和乘法</li><li>复数的幂：整数幂唯一，有理数 $\frac{p}{q}$ 次幂有$p$个，无理数次幂无穷多</li><li>$\mathrm{Hermite}$ 共轭：$A^H&#x3D;\overline{A^T}&#x3D;\overline{A}^T$</li></ol></li><li>代数结构：详见<a href="https://sqzr2319.github.io/DiscreteMath-2">离散数学(2)</a><ol><li>半群：封闭性、结合律</li><li>群：半群 $+$ 单位元、逆元</li><li>交换群（$\mathrm{Abel}$ 群）：群 $+$ 交换律</li><li>环：加法交换群 $+$ 乘法半群 $+$ 分配律</li><li>域：环 $+$ 乘法交换群</li></ol></li></ol><h2 id="二、多项式"><a href="#二、多项式" class="headerlink" title="二、多项式"></a>二、多项式</h2><ol><li>综合除法：$f(x)&#x3D;x^3-4x^2-5x+2$，求 $f(-3)$ 或求 $f(x)$ 除以 $x+3$ 的余式<br>$$\begin{bmatrix} -3 &amp; 1 &amp; -4 &amp; -5 &amp; 2 \ &amp;  &amp; -3 &amp; 21 &amp; -48 \ \hline &amp; 1 &amp; -7 &amp; 16 &amp; -46 \end{bmatrix}$$</li><li>将 $f(x)$ 分解成 $x-a$ 的方幂和：$f(x)&#x3D;(x-a)g_0(x)+r_0(x)&#x3D;(x-a)((x-a)g_1(x)+r_1(x))+r_0(x)$</li><li>$\mathrm{Lagrange}$ 插值<ol><li>$n&#x3D;1$ 时：$f(x)&#x3D;f(x_0)\frac{(x-x_1)}{(x_0-x_1)}+f(x_1)\frac{(x-x_0)}{(x_1-x_0)}$</li><li>$L_i(x)&#x3D;\frac{(x-a_0)\cdots(x-a_{i-1})(x-a_{i+1})\cdots(x-a_n)}{(a_i-a_0)\cdots(a_i-a_{i-1})(a_i-a_{i+1})\cdots(a_i-a_n)}$,$L(x)&#x3D;\sum_{i&#x3D;0}^n f(a_i)L_i(x)$</li></ol></li><li>$\mathrm{Bezout}$ 等式：$(f(x),g(x))&#x3D;f(x)u(x)+g(x)v(x)$<ol><li>$f(x)&#x3D;p(x)g(x)+r(x),g(x)&#x3D;q(x)r(x)+s(x),r(x)&#x3D;t(x)s(x)\Rightarrow s(x)&#x3D;g(x)-q(x)r(x)&#x3D;g(x)-q(x)(f(x)-p(x)g(x))$</li><li>$f(x)u(x)+g(x)v(x)&#x3D;h(x)$ 不能推出 $h(x)$ 是最大公因式</li><li>$f(x)u(x)+g(x)v(x)&#x3D;1\Leftrightarrow f(x)$ 和 $g(x)$ 互质</li></ol></li><li>有理根定理：$f(x)&#x3D;a_nx^n+\cdots+a_0$，$\frac{p}{q}$ 是 $f(x)$ 的有理根  $\Rightarrow p|a_0,q|a_n$</li><li>三次方程 $ax^3+bx^2+cx+d&#x3D;0$ 的根的性质<ol><li>$\mathrm{Vieta}$ 定理：$x_1+x_2+x_3&#x3D;-\frac{b}{a},x_1x_2+x_2x_3+x_3x_1&#x3D;\frac{c}{a},x_1x_2x_3&#x3D;-\frac{d}{a}$</li><li>$x^3+px+q&#x3D;0$ 的判别式：$\Delta&#x3D;-4p^3-27q^2$，$\Delta&gt;0$ 有三个不相等的实根，$\Delta&#x3D;0$ 有两个相等的实根，$\Delta&lt;0$ 有一个实根和两个共轭复根</li></ol></li></ol><h2 id="三、-mathrm-Jordan-标准形"><a href="#三、-mathrm-Jordan-标准形" class="headerlink" title="三、$\mathrm{Jordan}$ 标准形"></a>三、$\mathrm{Jordan}$ 标准形</h2><ol><li>$\mathrm{Ker}T,\mathrm{Im}T,\mathrm{Ker}(T-aI)^k,\mathrm{Im}(T-aI)^k$ 是 $T-$ 不变子空间</li><li>极小多项式<ol><li>唯一且相似矩阵的极小多项式相同</li><li>分块对角矩阵的极小多项式为分块对角矩阵的极小多项式的最小公倍式</li><li>设 $|\lambda I_n-A|&#x3D;(\lambda -\lambda_1)^{n_1}(\lambda -\lambda_2)^{n_2}\cdots(\lambda -\lambda_s)^{n_s}$，则 $m_A(x)&#x3D;(x-\lambda_1)^{m_1}(x-\lambda_2)^{m_2}\cdots(x-\lambda_s)^{m_s}$，其中 $m_i$ 是使 $G_{\lambda_i}(A)$ 的维数最大的最小整数</li><li>推论：可对角化等价于极小多项式无重根</li><li>推论：若存在向量 $v$ 使得 $v,T(v),T^2(v),\cdots,T^{k}(v)$ 线性无关，则 $T$ 的极小多项式次数大于 $k$</li></ol></li><li>循环子空间<ol><li>幂零变换 $\Leftrightarrow$ 只有零特征值</li><li>极大循环子空间 $\Leftrightarrow v\notin \mathrm{Im} T$</li><li>循环子空间直和分解定理<ol><li>循环子空间个数 $&#x3D;\mathrm{dim} \mathrm{Ker} T&#x3D;$ 零特征值的几何重数</li><li>循环子空间最大维数 $&#x3D;$ 幂零次数 $&#x3D;$ 极小多项式次数</li><li>阶数为 $d$ 的 $\mathrm{Jordan}$ 块个数 $&#x3D;r(A^{d-1})+r(A^{d+1})-2r(A^d)$</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分A(2)</title>
    <link href="/Calculus-A2/"/>
    <url>/Calculus-A2/</url>
    
    <content type="html"><![CDATA[<font face="霞鹜文楷等宽"><p>大一下学期微积分A(2)的复习笔记，目前更新至含参积分。</p><span id="more"></span><h2 id="一、多元微分"><a href="#一、多元微分" class="headerlink" title="一、多元微分"></a>一、多元微分</h2><ol><li>赋范线性空间 $\mathbb R^n$<ol><li>$\mathbb R^n$ 中非空的道路连通的开集称为开区域，<strong>开区域的闭包</strong>称为闭区域</li><li>道路联通的闭集<strong>不一定</strong>是闭区域</li><li>凸区域：$\forall x,y\in\Omega,\lambda x+(1-\lambda)y\in\Omega$</li></ol></li><li>极限与连续<ol><li>若 $x_0$ 是 $\Omega$ 的孤立点，则 $f$ 在 $x_0$ 处连续</li><li>在<strong>开区域</strong>中定义的初等函数处处连续</li><li>$|f(x)|\le M|g(x)|$，则 $f(x)&#x3D;O(g(x))\Leftrightarrow g(x)&#x3D;\Omega(f(x))$</li><li>$f$ 为连续函数当且仅当开集的原像为开集</li></ol></li><li>导数与微分<ol><li>不可微时即使偏导函数都存在也不存在梯度</li><li>隐函数定理(1)：$\frac{\partial F}{\partial y}(x_0,y_0)$ 可逆 $\Rightarrow \frac{\partial y}{\partial x}&#x3D;-(\frac{\partial F}{\partial y})^{-1}\frac{\partial F}{\partial x}$</li><li>隐函数定理(2)：$\frac{\partial y}{\partial x_i}&#x3D;-\frac{\frac{\partial F}{\partial x_i}}{\frac{\partial F}{\partial y}}$</li><li>逆映射定理：$J(F)|_{x_0}$ 可逆 $\Rightarrow J(f^{-1})&#x3D;(J(f))^{-1}$</li></ol></li><li>$\mathrm{Taylor}$ 公式<ol><li>$\displaystyle f(x)&#x3D;\sum_{k&#x3D;0}^{n}\frac{1}{k!}(h_1\frac{\partial}{\partial x_1}+h_2\frac{\partial}{\partial x_2}+\cdots+h_m\frac{\partial}{\partial x_m})^kf(x_0)+o(|x-x_0|^n)$</li><li>$f(x)&#x3D;f(x_0)+J_f(x_0)\cdot(x-x_0)+\frac{1}{2}(x-x_0)^T H_f(x_0)(x-x_0)+o(||x-x_0||^2)$</li></ol></li><li>空间曲线与曲面<ol><li>详见<a href="https://sqzr2319.github.io/LinearAlgebra-1">线性代数(1)</a></li><li>$z&#x3D;f(x,y)$ 法向量：$(-f’x,-f’y,1)$</li><li>$F(x,y,z)&#x3D;0$ 法向量：$\nabla F$</li></ol></li><li>无条件极值与条件极值<ol><li>驻点 $+$ $\mathrm{Hesse}$ 矩阵正定或负定 $\Rightarrow$ 无条件极值（反之不成立）</li><li>拉乘求得的解一定是条件最值但不一定是极值（需验算 $\mathrm{Hesse}$ 矩阵）</li><li>存在函数 $f(x,y)&#x3D;x^2+y^2(1-x)^3$ 使得函数在 $\mathbb R^2$ 上一阶连续可微且存在唯一极值点，但该极值点不是最值点</li></ol></li><li>例题<ol><li>$(2021)$ 已知函数 $f(x,y)$ 在 $(1,1)$ 处可微，且 $f(1,1)&#x3D;1,f’_x(1,1)&#x3D;2,f’_y(1,1)&#x3D;3$，设 $g(x)&#x3D;f(x,f(x,x))$，求 $g’(1)$</li><li>$(2021)$ 已知 $(axy^3-y^2\cos x)\mathrm{d}x+(1+by\sin x+3x^2y^2)\mathrm{d}y$ 为某一函数 $f(x,y)$ 的全微分，求 $a,b$ 的值及 $f(x,y)$</li><li>$(2023)$ 设函数 $f(x,y)$ 在 $\mathbb R^2$ 上二次连续可微，对 $\forall \theta \in \mathbb R$，令 $g_\theta(t)&#x3D;f(t\cos\theta,t\sin\theta)$，假设 $\frac{\mathrm{d}g_\theta(t)}{\mathrm{d}t}\vert_{t&#x3D;0}&#x3D;0$ 且 $\frac{\mathrm{d}^2g_\theta(t)}{\mathrm{d}t^2}\vert_{t&#x3D;0}\gt 0,\forall \theta \in \mathbb R$，证明函数 $f(x,y)$ 在点 $(0,0)$ 处取得极小值</li><li>$(2023)$ 根据隐函数定理，证明方程组 $\begin{cases}x^2+y^3&#x3D;2z^3\\x+y+z&#x3D;3\end{cases}$ 在点 $(1,1,1)$ 附近确定了两个 $C^{\infty}$ 类隐函数 $y&#x3D;y(x),z&#x3D;z(x)$，并证明隐函数 $z&#x3D;z(x)$ 在 $x&#x3D;1$ 处取得极值</li><li>$(2024)$ 设可微函数 $u(x,y)$ 满足 $u(x,x^2)&#x3D;1$ 且 $\frac{\partial u}{\partial x}(x,x^2)&#x3D;x$，求 $\frac{\partial u}{\partial y}(x,x^2)$</li><li>$(2023)$ 已知椭球面 $\frac{x^2}{8}+\frac{y^2}{4}+\frac{z^2}{2}&#x3D;1$ 与平面 $x+2y+2z&#x3D;0$ 的交线是椭圆，其在 $Oxy$ 平面上的投影曲线 $\Tau$ 也是椭圆，求 $\Tau$ 的四个顶点坐标</li><li>$(3.15)$ 在方程 $(xy+z)\frac{\partial z}{\partial x}+(1-y^2)\frac{\partial z}{\partial y}&#x3D;x+yz$ 中作代换 $u&#x3D;yz-x,v&#x3D;xz-y,w&#x3D;xy-z$，其中视 $w$ 是 $u,v$ 的函数，求代换后的方程</li><li>$(3.26)$ 曲线 $S$ 由方程 $ax+by+cz&#x3D;G(x^2+y^2+z^2)$ 确定，试证明：曲线 $S$ 上任一点的法线与某定直线相交</li><li>$(3.27)$ 求两曲面 $F(x,y,z)&#x3D;0$ 和 $G(x,y,z)&#x3D;0$ 的交线在 $xy$ 平面上的投影曲线的切线方程</li><li>$(4.34)$ 证明：椭球面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}&#x3D;1$ 与平面 $Ax+By+Cz&#x3D;0$ 相交所截的椭圆面积为 $S&#x3D;\pi abc\sqrt{\frac{A^2+B^2+C^2}{A^2a^2+B^2b^2+C^2c^2}}$</li></ol></li><li>证明题<ol><li>$(2021)$ 已知函数 $f(x,y)$ 对每个变量 $x,y$ 分别连续，且对每个固定的 $x$，函数 $f(x,y)$ 对 $y$ 单调，证明：$f(x,y)$ 作为二元函数是连续函数</li><li>$(2023)$ 对在 $\mathbb R^2$ 上连续可微的函数 $g(x,y)$，假设曲线 $\{(x,y)\in \mathbb R^2|G(x,y)&#x3D;0\}$ 具有无穷大符号 $\infty$ 的形状，问函数 $g(x,y)$ 在 $\mathbb R^2$ 上至少有多少个驻点？并证明你的结论。</li><li>$(2024)$ 设 $D\subset\mathbb R^2$ 是一个非空有界闭区域，$f$ 是 $D$ 上的连续函数，证明：至多只有一个函数 $u(x,y)$ 在 $D$ 上连续，在 $D$ 的内部 $\mathring D$ 为 $C^2$ 类，且满足 $\begin{cases} u’’_{xx}+u’’_{yy}&#x3D;e^u,(x,y)\in \mathring D\\u&#x3D;f,(x,y) \in \partial D\end{cases}$</li><li>$(2024)$ 设 $K$ 是 $\mathbb R^k$ 的非空有界闭子集，函数 $f:\mathbb R^m\times K\to \mathbb R$ 连续，记 $\displaystyle g(\mathrm{x})&#x3D;\min_{\mathrm{y}\in K}f(\mathrm{x},\mathrm{y})$，证明：$g:\mathbb R^m\to \mathbb R$ 连续</li><li>$(2.12)$ 设 $\frac{\partial f}{\partial x}(x_0,y_0)$ 存在，$\frac{\partial f}{\partial y}(x,y)$ 连续，证明：$f(x,y)$ 在点 $(x_0,y_0)$ 处可微</li><li>$(2.29)$ 设 $f’_x,f’_y$ 在点 $(x_0,y_0)$ 的某邻域内存在且 $f’’_{xy}$ 在 $(x_0,y_0)$ 连续，证明：$f’’_{yx}(x_0,y_0)$ 存在且 $f’’_{xy}(x_0,y_0)&#x3D;f’’_{yx}(x_0,y_0)$</li><li>$(3.11)$ 设 $u&#x3D;f(z)$，其中 $z$ 是由方程 $z&#x3D;x+y\varphi(z)$ 所定义的变量为 $x,y$ 的隐函数，求证：$\displaystyle \frac{\partial^n u}{\partial y^n}&#x3D;\frac{\partial^{n-1}}{\partial x^{n-1}}\left((\varphi(z))^n\frac{\partial u}{\partial x}\right)$，其中 $\varphi(z)$ 无穷次可微</li><li>$(4.11)$ $f$ 在 $\mathbb R^2$ 上一阶连续可微，且 $\forall (x,y)\neq (0,0)$，有 $xf’_x(x,y)+yf’_y(x,y)\gt 0$，证明：原点是 $f$ 的唯一极小值点，且 $\displaystyle \lim_{(x,y)\to (0,0)}\frac{f(x,y)-f(0,0)}{\sqrt{x^2+y^2}}&#x3D;0$</li><li>$(4.13)$ 已知 $D&#x3D;\{(x,y):0\lt x\lt 1,0\lt y\lt 1\},f(x,y)&#x3D;ax^2+bxy+cy^2+dx+ey$，且 $\forall (x,y)\in \partial D$，有 $f(x,y)\le 0$，证明：$\forall (x,y)\in D$，有 $f(x,y)\le 0$</li></ol></li></ol><h2 id="二、含参积分"><a href="#二、含参积分" class="headerlink" title="二、含参积分"></a>二、含参积分</h2><ol><li>含参定积分的性质（参数范围为<strong>有限闭区间</strong>）<ol><li>连续、可积：$f(x,y)$ 在 $[a,b]\times [\alpha,\beta]$ 上连续</li><li>可微：$f(x,y),f’_y(x,y)$ 在 $[a,b]\times [\alpha,\beta]$ 上连续</li><li>可微的计算：$\displaystyle \frac{\mathrm{d}}{\mathrm{d}y}\int_{\alpha(y)}^{\beta(y)} f(x,y)\mathrm{d}x&#x3D;\int_{\alpha(y)}^{\beta(y)} f’_y(x,y)\mathrm{d}x+f(\beta(y),y)\cdot\beta’(y)-f(\alpha(y),y)\cdot\alpha’(y)$</li></ol></li><li>含参广义积分的性质（参数范围为<strong>有限闭区间</strong>）<ol><li>连续、可积<ol><li>$f(x,y)$ 在 $[a,+\infty)\times [\alpha,\beta]$ 上连续（同定积分）</li><li>$\displaystyle \int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li></ol></li><li>可微<ol><li>$f(x,y),f’_y(x,y)$ 在 $[a,+\infty)\times [\alpha,\beta]$ 上连续（同定积分）</li><li>$\displaystyle \int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>逐点收敛</strong></li><li>$\displaystyle \int_a^{+\infty}f’_y(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li></ol></li></ol></li><li>二元无穷限累次积分的性质（参数范围为<strong>无穷限区间</strong>）<ol><li>交换积分次序<ol><li>$f(x,y)$ 在 $[a,+\infty)\times [\alpha,+\infty)$ 上连续（同定积分）</li><li>$\displaystyle \forall \beta\gt \alpha,\int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li><li>$\displaystyle \forall b\gt a,\int_\alpha^{+\infty}f(x,y)\mathrm{d}y$ 在 $x\in[a,b]$ 上<strong>一致收敛</strong></li><li>$\displaystyle \int_\alpha^{+\infty}\mathrm{d}y\int_a^{+\infty}\left|f(x,y)\right|\mathrm{d}x$ 和 $\displaystyle \int_a^{+\infty}\mathrm{d}y\int_\alpha^{+\infty}\left|f(x,y)\right|\mathrm{d}x$ 中至少有一个存在</li></ol></li></ol></li><li>含参广义积分判敛<ol><li>方法<ol><li>定义</li><li>$\mathrm{Cauchy}$</li><li>$\mathrm{Weierstrass}$</li><li>$\mathrm{Dirichlet}$</li><li>$\mathrm{Abel}$</li></ol></li><li>技巧<ol><li>连续延拓</li><li>取任意闭区间 $[a,b]$ 逼近开区间</li></ol></li><li>注意事项<ol><li><strong>技巧2.2只能用于连续不能用于一致收敛</strong></li><li>一致收敛是连续的<strong>充分非必要</strong>条件</li></ol></li></ol></li><li>技巧与例题<ol><li>微分方程的求解：详见<a href="https://sqzr2319.github.io/Calculus-A1">微积分A(1)</a></li><li>常用积分公式：$\begin{cases}\displaystyle \int e^{ax}\cos bx\mathrm{d}x&#x3D;\frac{e^{ax}}{a^2+b^2}(a\cos bx+b\sin bx)+C\\\displaystyle \int e^{ax}\sin bx\mathrm{d}x&#x3D;\frac{e^{ax}}{a^2+b^2}(a\sin bx-b\cos bx)+C\end{cases}$</li><li>$(2024)$ 设 $\displaystyle I(y)&#x3D;\int_0^{+\infty}e^{-x^2}\sin(2xy)\mathrm{d}x$，证明：$\displaystyle I(y)&#x3D;e^{-y^2}\int_0^y e^{-t^2}\mathrm{d}t$</li><li>$(5.26)$ 试利用积分 $\displaystyle \varphi(x)&#x3D;\int_0^1 \frac{e^{-x^2(1+u^2)}}{1+u^2}\mathrm{d}u$ 计算积分 $\displaystyle I&#x3D;\int_0^{+\infty} e^{-x^2}\mathrm{d}x$</li></ol></li><li>证明题<ol><li>$(5.17)$ 证明：$\displaystyle \int_0^{+\infty} \frac{\sin x^2y}{x}\mathrm{d}x$ 在 $y\in (0,+\infty)$ 不一致收敛，但连续</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一下</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大一上自学笔记</title>
    <link href="/CSDIY-24Winter/"/>
    <url>/CSDIY-24Winter/</url>
    
    <content type="html"><![CDATA[<p>大一上学期自学的笔记，主要包括Crash Course : Computer Science和MIT Missing Semester。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="一、Crash-Course-Computer-Science"><a href="#一、Crash-Course-Computer-Science" class="headerlink" title="一、Crash Course : Computer Science"></a>一、Crash Course : Computer Science</h2><ol><li>计算机底层<ol><li>晶体管</li><li>逻辑门</li><li>半加器、寄存器</li><li>$\mathrm{ALU}$、$\mathrm{RAM}$</li><li>二进制编程</li><li>$\mathrm{CPU}$</li><li>汇编语言</li><li>操作系统</li><li>文件系统</li><li>编译型语言</li><li>解释型语言</li></ol></li><li>计算机硬件<ol><li>存储器：延迟线 $\Rightarrow$ 磁芯 $\Rightarrow$ 磁带 $\Rightarrow$ 磁盘 $\Rightarrow$ 光盘 $\Rightarrow$ 固态硬盘</li><li>$\mathrm{IO}$<ol><li>电传打字机 $\Rightarrow$ 阴极射线管 $\Rightarrow \mathrm{LCD}$</li><li>矢量扫描、光栅扫描</li></ol></li><li>$\mathrm{3D}$<ol><li>正交投影、透视投影</li><li>多边形渲染、扫描线、抗锯齿</li><li>画家算法、深度缓冲</li><li>表面法线、纹理映射</li></ol></li></ol></li><li>计算机软件<ol><li>网络<ol><li>物理层</li><li>数据链路层：$\mathrm{MAC}$、载波侦听多路访问、指数退避</li><li>网络层：交换机、路由、跳数限制</li><li>传输层：报文、数据包、$\mathrm{IP}$、$\mathrm{UDP}$、$\mathrm{TCP}$ </li><li>会话层：$\mathrm{URL}$、$\mathrm{DNS}$、$\mathrm{HTTP}$、$\mathrm{HTML}$</li></ol></li><li>信息安全<ol><li>$\mathrm{Bell-LaPadula}$ 模型</li><li>攻击方式：社会工程学、钓鱼、假托、木马、暴力、$\mathrm{NAND}$ 镜像</li><li>漏洞利用：缓存区溢出（边界检查、金丝雀）、$\mathrm{SQL}$ 注入、蠕虫、僵尸网络</li><li>加密：$\mathrm{Diffie-Hellman}$ 密钥交换（模幂）、非对称加密</li></ol></li><li>人工智能<ol><li>分类：决策边界、混淆矩阵 $\Rightarrow$ 决策树 $\Rightarrow$ 森林 $\Rightarrow$ 支持向量机</li><li>神经网络：加权、求和、偏置、激活</li><li>$\mathrm{CV}$：颜色跟踪 $\Rightarrow$ 特征检测（核、卷积）$\Rightarrow$ 卷积神经网络</li><li>$\mathrm{NLP}$：分析树、知识图谱、语音识别（$\mathrm{FFT}$）、语音合成</li></ol></li></ol></li></ol><h2 id="二、MIT-Missing-Semester"><a href="#二、MIT-Missing-Semester" class="headerlink" title="二、MIT Missing Semester"></a>二、MIT Missing Semester</h2><ol><li>Shell<ol><li>以 <code>/</code> 或盘符开头的是绝对路径，否则是相对路径；Linux,MacOS 用 <code>/</code>，Windows 用 <code>\</code></li><li>命令：<code>which</code>，<code>sudo su</code>，<code>cat</code>，<code>curl</code>，<code>grep</code>，<code>tee</code></li><li><code>cd</code> 需要权限 <code>x</code>；<code>ls</code> 需要权限 <code>r</code></li><li><code>&#39;</code> 不转义变量，<code>&quot;</code> 转义变量</li><li><code>$0</code> 脚本名，<code>$1-$9</code> 脚本参数，<code>$@</code> 所有参数，<code>$#</code> 参数个数，<code>$?</code> 返回值，<code>$$</code> PID，<code>!!</code> 上一个命令，<code>$_</code> 最后一个参数</li><li>标准错误流 <code>2&gt;</code>；不等于 <code>-ne</code>；比较时用 <code>[[ ]]</code></li><li>通配符：<code>*</code> 任意字符，<code>?</code> 单个字符，<code>[]</code> 字符集，<code>&#123;&#125;</code> 多个字符</li><li><code>find</code>: <code>-name</code> 文件名，<code>-type</code> 文件类型，<code>-size</code> 文件大小，<code>-exec</code> 执行命令，<code>path</code> 路径，<code>-mtime</code> 修改时间</li><li>正则表达式：<code>^</code> 开头，<code>$</code> 结尾，<code>.</code> 任意字符，<code>*</code> 0-多次，<code>+</code> 1-多次，<code>?</code> 0-1次，<code>[]</code> 字符集，<code>()</code> 分组，<code>|</code> 或，<code>\1,\2</code> 捕获组</li><li>数据整理：<code>awk</code>，<code>sed</code>，<code>sort</code>，<code>uniq</code>，<code>paste</code>，<code>wc</code>，<code>head</code>，<code>tail</code></li><li>终止：<code>^C</code> &#x3D; <code>SIGINT</code>，<code>^D</code> &#x3D; <code>EOF</code>，<code>^\</code> &#x3D; <code>SIGQUIT</code>，<code>kill</code> &#x3D; <code>SIGTERM</code>，<code>^Z</code> &#x3D; <code>SIGTSTP</code>，<code>SIGKILL</code> 立刻结束</li><li>进程管理：<code>fg</code> 前台继续，<code>bg</code> 后台继续，<code>jobs</code> 查看，<code>pgrep</code> 查找，<code>$!</code> 最后一个进程，<code>nohup</code> 后台运行</li><li>常用参数：<code>--verbose</code>，<code>-v</code>，<code>-vvv</code>，<code>--quiet</code>，<code>-</code>，<code>-r</code>，<code>-- -r</code></li><li>常见目录：<code>/etc</code>，<code>/var</code>，<code>/tmp</code>，<code>/dev</code>，<code>/bin</code>，<code>/sbin</code>，<code>/opt</code>，<code>/lib</code></li></ol></li><li>VIM<ol><li>切模式：<code>i</code> 插入，<code>v</code> 可视，<code>V</code> 行可视，<code>^V</code> 块可视，<code>R</code> 替换，<code>:</code> 命令，<code>a</code> 插入</li><li>移动：<code>hjkl</code>，<code>w</code>，<code>b</code>，<code>e</code>，<code>0</code>，<code>^</code>，<code>$</code>，<code>gg</code>，<code>G</code>，<code>H</code>，<code>M</code>，<code>L</code>，<code>^U</code>，<code>^D</code></li><li>搜索：<code>%</code> 找配对括号，<code>f</code>,<code>t</code>,<code>F</code>,<code>T</code> 查找，<code>/</code> 搜索，<code>,</code>,<code>;</code>,<code>n</code>,<code>N</code> 导航匹配</li><li>编辑：<code>o</code>，<code>O</code>，<code>r</code>，<code>d</code>，<code>x</code>，<code>s</code>，<code>y</code>，<code>p</code>，<code>u</code>，<code>~</code>，<code>.</code>，<code>i</code> 内部，<code>a</code> 周围，<code>ci[</code></li></ol></li><li>GIT<ol><li>命令：<code>init</code>，<code>status</code>，<code>add</code>，<code>commit</code>，<code>log</code>，<code>diff</code>，<code>checkout</code>，<code>branch</code>，<code>merge</code></li><li>远程：<code>remote add</code>，<code>push</code>，<code>pull</code>，<code>clone</code>，<code>fetch</code></li></ol></li><li>tmux：<code>tmux</code>，<code>tmux ls</code>，<code>tmux a</code>，<code>^A</code>+<code>d</code>,<code>c</code>,<code>1</code>,<code>n</code>,<code>p</code>,<code>,</code>,<code>w</code>,<code>&quot;</code>,<code>%</code>,<code>x</code>,<code>y</code>,<code>z</code></li><li>ssh：<code>ssh</code>，<code>scp</code>，<code>ssh-keygen</code>，<code>ssh-copy-id</code></li><li>配置文件：<code>~/.bashrc</code>，<code>~/.gitconfig</code>，<code>~/.vimrc</code>，<code>~/.tmux.conf</code>，<code>~/.ssh/config</code></li><li>版本管理：主版本号.次版本号.补丁号</li><li>元编程：Makefile，CMake，CI，GitHub Pages，Jekyll</li><li>密码学：Hash 函数，盐，对称加密，密钥交换，非对称加密，加密邮件，数字签名</li><li>杂项：VM，Docker，Jupyter Notebook</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一上</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 | 逆天高三模卷数学压轴一则</title>
    <link href="/Bytalk-2/"/>
    <url>/Bytalk-2/</url>
    
    <content type="html"><![CDATA[<p>杂谈第二期，介绍了一道高三模卷数学压轴题，题目质量很高，难度也不低，值得一试。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>对定义在 $\mathbb R$ 上的函数 $f(x)$ 与正实数 $r$，定义 $S_r&#x3D;\{x|x^2+f^2(x)\le r^2\}$. </p><p>若 $f(x)$ 满足对任意正实数 $r$，均有 $S_r&#x3D;[-g(r),g(r)]$，其中 $g(x)$ 是定义在 $(0,+\infty)$ 上的可导函数，且$\forall x\gt 0,\begin{cases}g(x)\gt 0\\0\lt g’(x)\lt 1\end{cases}$，</p><p>证明：$f(x)$ 是 $\mathbb R$ 上的严格增函数<strong>当且仅当</strong> $\{x|f(x)\ge 0\}&#x3D;[0,+\infty)$.</p><p>本题改编自公众号<strong>未来教研之星</strong>举办的 $\mathrm{WJXSAT}$ 考试，供题人为B站<strong>艺扬飞翔在出题</strong>，原题链接见页尾“阅读原文”。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="充分性："><a href="#充分性：" class="headerlink" title="充分性："></a>充分性：</h4><p>证明：假设 $f(0)\neq 0$，设 $f(0)&#x3D;m\neq 0$，则取 $r^2&#x3D;\frac{1}{2}m^2$，$S_r$ 不包含 $0$，矛盾。</p><p>故 $f(0)&#x3D;0$，又 $f(x)$ 在 $\mathbb R$ 上严格递增，故 $\{x|f(x)\ge 0\}&#x3D;[0,+\infty)$.</p><h4 id="必要性："><a href="#必要性：" class="headerlink" title="必要性："></a>必要性：</h4><p>先证明两个引理。</p><p><strong>引理 $1$：令 $h(x)&#x3D;x^2+f^2(x)$，则 $h(x)$ 在 $(-\infty,0]$ 上严格递减，$[0,+\infty)$ 上严格递增。</strong></p><p>证明：先考虑 $[0,+\infty)$ 的情况，假设 $h(x)$ 不严格递增，分两种情况讨论：</p><p>$(\mathrm{i})$ $\exists x_1\lt x_2,h(x_1)\gt h(x_2)$，取 $r^2&#x3D;h(x_2)$，则 $S_r$ 不包含 $x_1$，矛盾。</p><p>$(\mathrm{ii})$ $\exists x_1\lt x_2,h(x)$ 在 $[x_1,x_2]$ 上是常值函数，则 $\forall \epsilon\gt 0$，取 $r^2&#x3D;h(x_2)-\epsilon$，$g(r)\lt x_1$，但 $r^2&#x3D;h(x_2)$ 时，$g(r)\ge x_2$，则 $g(r)$ 不连续，矛盾。</p><p>故 $h(x)$ 在 $[0,+\infty)$ 上严格递增，同理可证 $h(x)$ 在 $(-\infty,0]$ 上严格递减。</p><p>由引理 $1$ 可得，则 $g(r)$ 为 $\sqrt{x^2+f^2(x)}(x\gt 0)$ 的反函数，由于 $g(r)$ 为定义在 $(0,+\infty)$ 上的可导函数，则 $f(x)$ 在 $[0,+\infty)$ 上可导。</p><p><strong>引理 $2$：$f(x)$ 为奇函数。</strong></p><p>证明：由引理 $1$ 及其推论，$\forall x_0\gt 0$，取 $r_0^2&#x3D;x_0^2+f^2(x_0)$，则 $g(r_0)&#x3D;x_0,-g(r_0)&#x3D;-x_0$，故 $(-x_0)^2+f^2(-x_0)&#x3D;r_0^2$，则 $\forall x_0\gt 0,f^2(x_0)&#x3D;f^2(-x_0)$.</p><p>假设 $\exists x_0\gt 0,f(x_0)&#x3D;f(-x_0)$，则 $f(-x_0)&#x3D;f(x_0)\gt 0$，但 $-x_0\lt 0$ 不在 $\{x|f(x)\ge 0\}$ 中，矛盾，故 $f(x)&#x3D;-f(-x)$，$f(x)$ 为奇函数。</p><p>由引理 $2$ 可得，$\forall x\gt 0$，$f(x)\gt 0$.</p><p>接下来先考虑 $x\ge 0$ 的情况，由引理 $1$ 的推论，$g’(r)\lt 1 \Rightarrow \forall x\gt 0,(\sqrt{x^2+f^2(x)})’\gt 1$，即 $f’(x)\gt \sqrt{(\frac{x}{f(x)})^2+1}-\frac{x}{f(x)}\gt 0$，$f(x)$ 在 $[0,+\infty)$ 上严格递增。</p><p>又由引理 $2$，$f(x)$ 为奇函数，故 $f(x)$ 在 $\mathbb R$ 上严格递增。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前标准答案尚未公布，题解为笔者自己的做法，解题过程中使用了连续性的定义和反函数的导数等高等知识，期待标答给出的纯初等解法。</p><p>个人认为本题难度过大，但题目质量还是很高的。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 | 一道高三一模数学题引发的思考</title>
    <link href="/Bytalk-1/"/>
    <url>/Bytalk-1/</url>
    
    <content type="html"><![CDATA[<p>杂谈第一期，介绍了一道高三一模数学题的解法和思考。题目是关于函数的性质，涉及到一些高等数学的知识。通过引理和分情况讨论，最终证明了满足条件的函数只能是零函数。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/Bytalk-1-1.jpg"></p><p>上图为今年上海市崇明区高三数学一模压轴题最后一问的原题以及区教研组提供的参考答案。事实上，题设中的条件已经够强，只需要借助一些高等知识，就可以证明：满足条件的 $f$ 只能是零函数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了证明 $f&#x3D;0$，先证明两个引理：</p><p><strong>引理 $1$：满足条件的 $f$ 若存在两个零点 $x_1\neq x_2$，则 $\forall x\in[x_1,x_2],f(x)&#x3D;0$</strong></p><p>证明：考虑函数 $g(x)&#x3D;|f(x)|$，由 $g(x)$ 的连续性，$g$ 在 $[x_1,x_2]$ 上存在最大值，分两种情况讨论：</p><p>$(1)$ $g$ 在区间上的最大值在端点处取到，则自然有 $\forall x\in[x_1,x_2],|f(x)|&#x3D;0\Leftrightarrow f(x)&#x3D;0$ 成立</p><p>$(2)$ $g$ 在区间上的最大值在内点 $x_0$ 处取到，此时有 $g(x_0)\neq 0$，不妨设 $g(x_0)\gt 0$，则在 $x_0$ 的邻域上有 $g(x)&#x3D;f(x)$ 或 $g(x)&#x3D;-f(x)$，则 $g(x)$ 在 $x_0$ 处可导，因此由 $\mathrm{Fermat}$ 引理，有 $g’(x_0)&#x3D;0$，则 $g(x_0)&#x3D;g’(x_0)&#x3D;0$，故也有 $\forall x\in[x_1,x_2],|f(x)|&#x3D;0\Leftrightarrow f(x)&#x3D;0$ 成立</p><p><strong>引理 $2$：若函数在区间 $I$ 上不存在零点，则函数在该区间上单调</strong></p><p>证明：若函数不单调，则 $\exists \xi\in I,s.t. f’(\xi)&#x3D;0$，则 $f(\xi)&#x3D;0$，与函数在区间 $I$ 上不存在零点矛盾</p><p><strong>接下来考虑 $f$ 的零点构成的集合 $S$，分四种情况讨论：</strong></p><p>$(1)$ $S$ 不存在上下确界，则由引理 $1$，$S&#x3D;\mathbb R$，则 $f&#x3D;0$</p><p>$(2)$ $S$ 的上下确界中的一个不存在，不妨设下确界不存在，记 $S$ 的上确界为 $M$，则 $f$ 在 $[M,+\infty)$ 上单调，且 $f(M-1)&#x3D;0$，由于添加零区间不影响函数的单调性，故 $f$ 在 $[M-1,+\infty)$ 上也单调，不妨设 $f$ 在 $[M-1,+\infty)$ 上单调递增，$f’(x)\ge 0$，则由条件 $1$ 和 $f$ 的单调性有 $0\le f(x)\le f’(x)$，此时考虑函数 $\displaystyle h(x)&#x3D;\frac{f(x)}{e^x}$，$\displaystyle h’(x)&#x3D;\frac{f’(x)-f(x)}{e^x}\ge 0$，$h(x)$ 在 $[M-1,+\infty)$ 上单调递增，再将 $f(x)&#x3D;h(x)e^x$ 代入条件 $2$，有 $\displaystyle 0\le h(x)\le \frac{\sqrt{2}}{e^x}$，由夹逼定理，则 $\displaystyle \lim_{x\to +\infty} h(x)&#x3D;0$，又由于 $h(M-1)&#x3D;0$，且 $h$ 在 $[M-1,+\infty)$ 上单调递增，故 $\forall x\in[M-1,+\infty),h(x)&#x3D;0\Rightarrow f(x)&#x3D;0$，而又由于引理 $1$， $(-\infty,M-1]\subset S$，故 $\forall x\in \mathbb R, f(x)&#x3D;0$ </p><p>$(3)$ $S$ 上下确界均存在，此时仿照 $(2)$ 即可</p><p>$(4)$ $S$ 为空集，不妨设 $f\gt 0$，记 $f(0)&#x3D;m_0\gt 0$，由于 $f$ 在 $\mathbb R$ 上单调，再分两种情况讨论：</p><p>$(\mathrm{i})$ 若 $f$ 单调递增，则 $\forall x\in [0,+\infty),f’(x)\ge f(x)\ge f(0)&#x3D;m_0\gt 0$，显然与 $f$ 有界矛盾</p><p>$(\mathrm{ii})$ 若 $f$ 单调递减，考虑函数 $h(x)&#x3D;f(-x)$，容易验证若 $f$ 满足条件，则 $h$ 也满足条件，且有 $h(0)\gt 0$，$h$ 在 $\mathbb R$ 上单调递增，由情况 $(\mathrm{i})$，$h$ 不存在，故 $f$ 也不存在，矛盾</p><p>综上，$f$ 满足条件当且仅当 $f&#x3D;0$</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>原题作为高三数学一模压轴题的最后一问，题设的条件显然欠妥；然而，改编后的题目却很适合作为微积分或数学分析的一道习题。</p><p>事实上，证明过程中的引理 $1$ 是今年上海交通大学高等数学 $\mathrm{A}(1)$ 期末考试的压轴题，而情况 $(2)$ 中构造的函数 $h$ 也是利用微分方程解决不等式问题的常见技巧。</p><p>希望能借这道题帮看到这篇文章的同学们回顾一下上学期所学的微积分知识，也祝同学们在微积分 $\mathrm{A}(1)$ 中取得满意的成绩。（笔者已经寄了，$\mathrm{qwq}$）</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分A(1)</title>
    <link href="/Calculus-A1/"/>
    <url>/Calculus-A1/</url>
    
    <content type="html"><![CDATA[<font face="霞鹜文楷等宽"><p>大一上学期微积分A(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、数列极限"><a href="#一、数列极限" class="headerlink" title="一、数列极限"></a>一、数列极限</h2><ol><li>计算<ol><li>定义法<ol><li>固定有限项，分步确定 $N$<ol><li>证明：若 $\displaystyle\lim_{n\to \infty}a_n&#x3D;a$，则 $\displaystyle \lim_{n\to \infty}\frac{a_1+a_2+\dots +a_n}{n}&#x3D;a$</li><li>证明：若 $\displaystyle\lim_{n\to \infty}\frac{a_n}{n}&#x3D;0$，则 $\displaystyle \lim_{n\to \infty}\frac{\max\{a_1,a_2,\dots ,a_n\}}{n}&#x3D;0$</li></ol></li><li>二项式定理放缩<ol><li>证明： $\displaystyle\lim_{n\to \infty}\sqrt[n]{n}&#x3D;1$</li><li>求 $\displaystyle\lim_{n\to \infty}n\left(\sqrt[n]{n}-1\right)^2$</li></ol></li><li>迭代：若 $\displaystyle\lim_{n\to \infty}\left(2a_n+a_{n+1}\right)&#x3D;0$，证明 $a_n$ 收敛，并求 $\displaystyle \lim_{n\to \infty}a_n$</li></ol></li><li>夹逼定理<ol><li>裂项放缩<ol><li>求 $\displaystyle\lim_{n\to \infty}\frac{n}{(n+1)^2}+\frac{n}{(n+2)^2}+\dots +\frac{n}{(2n)^2}$</li><li>求 $\displaystyle\lim_{n\to \infty}\frac{(2n-1)!!}{(2n)!!}$</li><li>证明： $\displaystyle\frac{1}{2\sqrt{n}}\lt \prod^n_{i&#x3D;1}\frac{2i-1}{2i}\lt \frac{1}{\sqrt{2n+1}}$</li></ol></li><li>常用放缩技巧<ol><li>$\gt 1;\gt 0$</li><li>$n!\gt \left(\frac{n}{2}\right)^{\frac{n}{2}}$</li><li>最大&#x2F;最小&#x2F;第一项放缩</li><li>$\sin ;\cos$ 有界</li><li>分子有理化</li><li>$\mathrm{Bernoulli}$ 不等式</li><li>平方差公式：求 $\displaystyle\prod_{i&#x3D;1}^{\infty}\left(1+\frac{1}{2^{2^i}}\right)$ </li><li>和差化积</li></ol></li></ol></li><li>单调收敛原理<ol><li>递推数列<ol><li>若 $\displaystyle a_{n+1}&#x3D;a_n+\frac{2-a_n^2}{2a_n}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>若 $\displaystyle 0\lt c\le 1,a_1&#x3D;\frac{c}{2},a_{n+1}&#x3D;\frac{c}{2}+\frac{a_n^2}{2}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>若 $\displaystyle a_1&#x3D;1,a_{n+1}&#x3D;1+\frac{1}{a_n}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li></ol></li><li>上界放缩（见常用放缩技巧）</li></ol></li><li>$\mathrm{Stolz}$ 定理<ol><li>分子或分母为数列形式</li><li>分子或分母为 $n$<ol><li>证明：若 $\displaystyle a_0&#x3D;1,a_n&#x3D;\sin{a_{n-1}}$，则 $\displaystyle \lim_{n\to \infty}\sqrt{\frac{n}{3}}a_n&#x3D;1$</li><li>求 $\displaystyle\lim_{n\to \infty}\sqrt[n]{\frac{n!}{n^n}}$</li></ol></li></ol></li><li>利用函数（见函数极限）</li></ol></li><li>证明<ol><li>单调收敛原理</li><li>四则运算：若 $\displaystyle\lim_{n\to \infty}\left(a_n+a_{n+1}\right)&#x3D;\lim_{n\to \infty}\left(a_n+a_{n+2}\right)&#x3D;a$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>$\mathrm{Cauchy}$ 收敛原理<ol start="0"><li>核心：将两元化为一元&#x2F;放缩（见常用放缩技巧）</li><li>证明：若 $\displaystyle a_1&#x3D;1,a_{n+1}&#x3D;a_n+\frac{1}{\sum_{k&#x3D;1}^{n}a_k}$，则 $a_n$ 收敛</li><li>证明：若 $0\lt a\lt 1$，则存在唯一的 $x$，使得 $x-a\sin x&#x3D;b$ </li><li>证明：若 $\displaystyle\exists M\gt 0,s.t.\forall n,\sum_{k&#x3D;1}^n{|x_{k+1}-x_k}|\le M$，则 $\{x_n\}$ 为 $\mathrm{Cauchy}$ 列</li><li>证明：若 $\displaystyle\forall n,p\in \mathbb N,|x_n-x_{n+p}|\le\frac{p}{n^2}$，则 $\{x_n\}$ 为 $\mathrm{Cauchy}$ 列</li></ol></li><li>反证法：证明 $a_n&#x3D;\tan n,a_n&#x3D;\sin n$ 发散</li><li>不同子列收敛到不同极限：证明 $\{(-1)^n\}$ 发散</li><li>常用证明技巧<ol><li>二分区间</li><li>取有界列的收敛子列</li></ol></li><li>常见陷阱<ol><li>无穷个子列的并收敛到同一极限 $\neq$ 极限存在</li><li>$\displaystyle\lim_{n\to \infty}|x_n-x_{n+p}|&#x3D;0,\forall p\in \mathbb N\rightarrow \{x_n\}$ 为 $\mathrm{Cauchy}$ 列？反例：$\displaystyle \sqrt n,\ln n,\sum_{k&#x3D;1}^{n}\frac{1}{k}$ </li><li>$\displaystyle|x_n-x_{n+p}|\le\frac{p}{n},\forall n,p\in \mathbb N\rightarrow \{x_n\}$ 为 $\mathrm{Cauchy}$ 列？反例： $\displaystyle\sum_{k&#x3D;1}^{n}\frac{1}{k}$</li></ol></li></ol></li></ol><h2 id="二、函数极限"><a href="#二、函数极限" class="headerlink" title="二、函数极限"></a>二、函数极限</h2><ol><li>函数极限<ol><li>利用数列<ol><li>取整</li><li>$\mathrm{Heine}$ 定理</li><li>从数列极限继承的方法</li><li>三角换元</li></ol></li><li>常见陷阱<ol><li>无穷多个无穷小量的乘积不一定是无穷小量</li><li>$\displaystyle a\gt 1,n\rightarrow \infty,n \cdot o\left(\frac{1}{n^a}\right)\neq o\left(\frac{1}{n^{a-1}}\right)$ </li><li>$0^0,1^\infty,\infty ^0$ 无意义</li><li>复合函数极限 $g(x)\neq u_0$ 或 $f(x)$ 连续</li><li>极限为 $0$ 的函数不一定为 $k$ 阶无穷小量：$\displaystyle\lim_{x\to 0}x\sin \frac{1}{x}$ </li><li>局部取极限&#x2F;等价因子替换：改用小 $o$ 或 $\mathrm{Taylor}$ 公式</li><li>$\mathrm{L’Hospital}$ 法则：<ol><li>分母的导函数在邻域上不为零</li><li>导函数不一定连续</li><li>若 $f(x)$ 二阶可导，求 $\displaystyle\lim_{h\to 0}\frac{f(a+h)-2f(a)+f(a-h)}{h^2}$ </li><li>若 $f(x)$ 可导，且 $\displaystyle f(0)&#x3D;f’(0)&#x3D;1$，求 $\displaystyle \lim_{x\to 0}\frac{f(\sin x)-1}{\ln f(x)}$</li></ol></li></ol></li><li>例题<ol><li>求 $\displaystyle \lim_{n\to \infty}n^p\sin \left(\sqrt 2+1\right)^n\pi$，其中 $p\gt 0$ </li><li>对于 $-1\lt a_0\lt 1$，若 $\displaystyle a_n&#x3D;\sqrt{\frac{1+a_{n-1}}{2}},b_n&#x3D;4^n\left(1-a_n\right)$，求 $\displaystyle \lim_{n\to \infty}b_n$ </li><li>已知 $\displaystyle b_1\gt a_1\gt 0$，若 $\displaystyle a_{n+1}&#x3D;\frac{a_n+b_n}{2},b_{n+1}&#x3D;\sqrt{a_{n+1}b_n}$，求 $\displaystyle\lim_{n\to \infty}a_n,\lim_{n\to \infty}b_n$ </li><li>求 $\displaystyle\lim_{n\to \infty}\sum_{k&#x3D;1}^{n}\left(\sqrt[3]{1+\frac{k}{n^2}}-1\right)$</li></ol></li></ol></li><li>连续函数<ol><li>常见反例函数<ol><li>$x^n\sin \frac{1}{x}$</li><li>$\mathrm{Dirichlet}$ 函数：$D(x)&#x3D;\begin{cases}0,x\in \mathbb R-\mathbb Q\\1,x\in Q\end{cases}$ </li><li>$\mathrm{Riemann}$ 函数：$R(x)&#x3D;\begin{cases}0,x\in \mathbb R-\mathbb Q\\\frac{1}{q},x&#x3D;\frac{p}{q},p,q互质,q\gt 0\end{cases}$</li></ol></li><li>闭区间上连续函数的性质<ol><li>零点定理</li><li>介值定理</li><li>有界性定理</li><li>最大最小值定理</li></ol></li><li>其他常用定理<ol><li>开区间上的单调函数：不存在可去间断点</li><li>区间上的单调函数：值域为区间 $\leftrightarrow$ 连续</li><li>区间上的严格单调连续函数：值域为区间，且反函数在原函数值域上连续</li></ol></li><li>一致连续<ol><li>等价条件<ol><li>闭区间上：连续</li><li>开区间上：$\exists M,\forall x,y,|f(y)-f(x)|\le M|y-x|^p,p\gt 0$ </li><li>证伪：$\displaystyle\exists \epsilon_0 \gt 0,\exists \{u_n\},\{v_n\},\lim_{n\to \infty}\left(u_n-v_n\right)&#x3D;0,|f(u_n)-f(v_n)|\gt \epsilon_0$</li></ol></li><li>例题：判断下列函数在给定区间上是否一致连续<ol><li>$\ln x,[2,+\infty)$ </li><li>$\sin x,[1,+\infty)$ </li><li>$x^\frac{1}{2},[0,+\infty)$ </li><li>$\sin x^2,x\in \mathbb R$</li></ol></li></ol></li><li>常用证明技巧<ol><li>二分区间</li><li>闭区间套定理</li><li>取有界列的收敛子列</li><li>$\displaystyle\lim_{x\to +\infty}f(x)&#x3D;+\infty\Leftrightarrow \exists \{x_n\},x_n\rightarrow +\infty,f(x_n)\lt a$ </li><li>补充间断点或无穷远点构造闭区间连续条件</li></ol></li><li>例题<ol><li>已知 $f,g\in C[a,b],\{x_n\}\subset [a,b]$，若 $f(x_1)&lt;g(x_1)$，且 $\forall x\in \mathbb N,g(x_n)&#x3D;f(x_{n+1})$，证明：$\exists \xi \in [a,b],s.t. f(\xi)&#x3D;g(\xi).$ </li><li>已知 $f\in C\{0\}$，若 $f(x+y)&#x3D;f(x)+f(y),\forall x,y\in \mathbb R$，证明：$f(x)&#x3D;cx.$ </li><li>证明：若 $f(x)$ 只有可去间断点，令 $\displaystyle g(x)&#x3D;\lim_{t\to x}f(t)$，则 $g(x)$ 为连续函数</li><li>$(2023)$ 设 $f(x)$ 在区间 $[a,+\infty)$ 上连续. 假设极限 $\displaystyle\lim_{x\to +\infty}f(x)$ 存在且有限，证明 $f(x)$ 在区间 $[a,+\infty)$ 上或者有最大值，或者有最小值.</li></ol></li></ol></li></ol><h2 id="三、导数与微分"><a href="#三、导数与微分" class="headerlink" title="三、导数与微分"></a>三、导数与微分</h2><ol><li>导数<ol><li>常见陷阱<ol><li>存在 $\mathrm{Weierstrass}$ 函数处处连续处处不可导</li><li>导数的四则运算要求 $f(x),g(x)$ 导数存在</li><li>$f(x)$ 在 $[a,b]$ 上可导 $\to$ $f’(x)$ 在 $[a,b]$ 上连续？反例：$\displaystyle x^2\sin \frac{1}{x}$ </li><li>$f(x)\in C[a,b]$，$f(x)$ 在 $(a,b)$ 上可导 $\to$ $f’_+(a),f’_-(b)$ 存在？反例：$\displaystyle|x|^a\sin \frac{1}{x},0\lt a\le 1$ </li><li>可导的严格单调递增函数 $f’(x)\gt 0$ ？反例：$x^3$ </li><li>导函数的左极限 $\neq$ 左导数</li></ol></li><li>例题<ol><li>利用微分求近似：$\sin 29°$ </li><li>求滑动门的包络线：$\begin{cases}\frac{x}{\cos \theta}+\frac{y}{\sin \theta}&#x3D;1\\\frac{y’(\theta)}{x’(\theta)}&#x3D;\frac{dy}{dx}&#x3D;-\tan \theta\end{cases}$ </li><li>$(2023)$ 求常数 $a$ 和 $b$，使得函数 $f\left(x\right)&#x3D;\begin{cases}\cos x, x\ge 0\\\frac{x^2+ax+b}{1+x}, x\lt 0\end{cases}$ 在点 $x&#x3D;0$ 处可导.</li></ol></li><li>高阶导数<ol><li>递推法<ol><li>令 $y&#x3D;(\arcsin x)^2$，求 $y^{(n)}(0)$ </li><li>令 $y&#x3D;\left(x+\sqrt{x^2+1}\right)^m$，求 $y^{(n)}(0)$ </li><li>令 $f(x)&#x3D;\arctan x$，证明：$(1+x^2)f^{(n+2)}(x)+2(n+1)xf^{(n+1)}(x)+n(n+1)f^{(n)}(x)&#x3D;0$，并求 $f^{(n)}(0)$</li></ol></li><li>利用多项式性质<ol><li>令 $\displaystyle P_{n,m}(x)&#x3D;\frac{d^n}{dx^n}\left(1-x^m\right)^n$，求 $P_{n,m}(1)$ </li><li>证明 $f(x)&#x3D;\begin{cases}e^{-\frac{1}{x^2}},x\neq 0\\0,x&#x3D;0\end{cases}$ 任意阶可导，并求 $f^{(n)}(0)$</li></ol></li><li>利用 $\mathrm{Euler}$ 公式：$e^{x+iy}&#x3D;e^x (\cos y+i\sin y)$ <ol><li>令 $f (x)&#x3D;e^x\sin x$，求 $f^{(n)}(x)$</li></ol></li><li>利用级数 $\displaystyle\frac{1}{1-x}&#x3D;\sum^\infty_{n&#x3D;0}x^n$ <ol><li>$(2023)$ 求函数 $f (x)$ 在点 $x&#x3D;0$ 处的 $2023$ 阶导数值 $f^{(2023)}(0)$</li></ol></li></ol></li></ol></li><li>微分中值定理<ol><li>定理内容<ol><li>$\mathrm{Fermat}$ 引理</li><li>$f(x),g(x)\in C[a,b],f(x),g(x)$ 在 $(a,b)$ 上可导<ol><li>$\mathrm{Rolle}$ 中值定理</li><li>$\mathrm{Lagrange}$ 中值定理</li><li>$\mathrm{Cauchy}$ 中值定理</li></ol></li><li>$f(x)$ 在 $[a,b]$ 上可导：$\mathrm{Darboux}$ 定理<ol><li>推论：导函数没有第一类间断点（即导函数的介值性质）</li></ol></li><li>广义 $\mathrm{Rolle}$ 中值定理<ol><li>$f(x)$ 在 $(a,b)$ 上可导，$\displaystyle\lim_{x\to a^+}f(x)&#x3D;\lim_{x\to b^-}f(x)$，则 $\exists \xi \in (a,b),s.t.f’(\xi)&#x3D;0$ </li><li>$f(x)$ 在 $(a,+\infty)$ 上可导，$\displaystyle\lim_{x\to a^+}f(x)&#x3D;\lim_{x\to +\infty}f(x)$，则 $\exists \xi \in (a,+\infty),s.t.f’(\xi)&#x3D;0$</li></ol></li></ol></li><li>应用<ol><li>求极限<ol><li>求 $\displaystyle\lim_{x\to e}\frac{\tan x^x-\tan e^x}{e^{x^x}-e^{e^x}}$ </li><li>求$\displaystyle\lim_{n\to \infty}n(\arctan \ln (n+1)-\arctan \ln n))$</li></ol></li><li>证明不等式<ol><li>证明： $\displaystyle\frac{x}{1+x}\lt \ln (1+x)\lt x$，其中 $x\gt -1$，且 $x\neq 0$ </li><li>证明： $px^{p-1}\le (x+1)^p-x^p\le p(x+1)^{p-1}$，其中 $p\gt 0$，并求 $\displaystyle\lim_{n\to \infty}\frac{1^p+2^p+\dots +n^p}{(n+1)^{p+1}}$</li><li>证明： $\displaystyle\frac{a^\frac{1}{n+1}}{(n+1)^2}\lt \frac{a^\frac{1}{n}-a^\frac{1}{n+1}}{\ln a}\lt \frac{a^\frac{1}{n}}{n^2}$ </li><li>证明： $a^y-a^x\gt (\cos x-\cos y)a^x\ln a$，其中 $\displaystyle 0\lt x\lt y\lt \frac{\pi}{2},a\gt 1$ </li><li>已知 $f(x)$ 在 $[0,+\infty)$ 上可导，若 $f’(x)$ 单调递减，且 $f(0)&#x3D;0$，证明：$f(x_1+x_2)\le f(x_1)+f(x_2)$</li></ol></li><li>利用 $\mathrm{Rolle}$ 分析零点存在性<ol><li>证明： $x^4+2x^3+6x^2-4x-5&#x3D;0$ 有且仅有两个不同的实根</li><li>证明： $n$ 阶 $\mathrm{Laguerre}$ 多项式 $\displaystyle L_n(x)&#x3D;e^x\frac{d^n}{dx^n}(x^ne^{-x})$ 在 $(0,+\infty)$ 上有且仅有 $n$ 个根</li></ol></li><li>辅助函数 $(\mathrm{I})$：利用 $e^x$ <ol><li>$f’(x)+g’(x)f(x)$：构造 $(f(x)e^{g(x)})’$ </li><li>$f’’(x)+2f’(x)+f(x)$：构造 $(f(x)e^x)’’$</li><li>$f’’(x)-f(x)$：构造 $(e^x(f’(x)-f(x)))’$ 或 $(e^{-x}(f’(x)+f(x)))’$ </li><li>$f’’(x)-f’(x)$：构造 $(f’(x)-f(x))’$ 或 $(e^{-x}f’(x))’$ </li><li>若 $f(x)$ 在 $\displaystyle\left[\frac{3\pi}{4},\frac{7\pi}{4}\right]$ 上可导，$\displaystyle f\left(\frac{3\pi}{4}\right)&#x3D;f\left(\frac{7\pi}{4}\right)&#x3D;0$，证明：$\displaystyle\exists \xi \in \left(\frac{3\pi}{4},\frac{7\pi}{4}\right),f’(\xi)+f(\xi)&#x3D;\cos \xi$</li></ol></li><li>辅助函数 $(\mathrm{II})$：利用微分方程<ol><li>若 $f(x),g(x)$ 在 $[a,b]$ 上二阶可导，$f(a)&#x3D;f(b)&#x3D;g(a)&#x3D;g(b)&#x3D;0,g’’(x)\neq 0(x\in (a,b))$，证明：$\displaystyle\exists \xi \in (a,b),s.t.\frac{f(\xi)}{g(\xi)}&#x3D;\frac{f’’(\xi)}{g’’(\xi)}$：构造 $h(x)&#x3D;f’(x)g(x)-f(x)g’(x)$ </li><li>若 $f(x),g(x)$ 在 $[a,b]$ 上可导，$g’(x)\neq 0(x\in (a,b))$，证明：$\displaystyle\exists \xi \in (a,b),s.t.\frac{f(a)-f(\xi)}{g(\xi)-g(b)}&#x3D;\frac{f’(\xi)}{g’(\xi)}$：构造 $h(x)&#x3D;(f(a)-f(x))(g(x)-g(b))$ </li><li>若 $f(x)$ 在 $[0,1]$ 上可导，$f(0)&#x3D;0,f(x)\gt 0(0\lt x\lt 1)$，证明：$\displaystyle\exists \xi \in (0,1),s.t.\frac{2f’(\xi)}{f(\xi)}&#x3D;\frac{f’(1-\xi)}{f(1-\xi)}$：构造 $h(x)&#x3D;f^2(x)f(1-x)$ </li><li>若 $f(x)$ 在 $[0,1]$ 上二阶可导，$f(x)&gt;0(x\in [0,1]),f’(0)&#x3D;f’(1)&#x3D;0$，证明：$\exists \xi \in (0,1),s.t.f(\xi)f’’(\xi)-2(f’(\xi))^2&#x3D;0$：构造 $\displaystyle h(x)&#x3D;\frac{f’(x)}{f^2(x)}$</li></ol></li></ol></li><li>例题<ol><li>若 $f(x)$ 在 $[a,c]$ 上连续，在 $(a,b)\cup (b,c)$ 上可导，证明：$\displaystyle\exists \xi \in [a,c],s.t.\left| \frac{f(c)-f(a)}{c-a}\right| \le \vert f’(\xi)\vert$</li><li>若 $\displaystyle f(x)\in C^1[0,+\infty)$，且 $\displaystyle0\le f(x)\le \frac{x}{1+x^2}$，证明：$\displaystyle\exists \xi \gt 0,s.t. f’(\xi)&#x3D;\frac{1-\xi ^2}{(1+\xi ^2)^2}$ </li><li>已知 $f(x)$ 在 $(a,+\infty)$ 上可导，若 $\displaystyle\displaystyle\lim_{x\to +\infty}f(x)$ 存在且有限，且 $\vert f’(x)\vert$ 在 $(a,+\infty)$ 上递减，证明：$\displaystyle\lim_{x\to +\infty}xf’(x)&#x3D;0$</li></ol></li></ol></li><li>$\mathrm{Taylor}$ 公式<ol><li>求法<ol><li>典式：$e^x,\sin x,\cos x,\tan x,\ln (1+x),(1+x)^a,(1+x)^{-1},(1-x)^{-1}$ </li><li>变量替换：$\displaystyle \frac{1}{2x-x^2}(x&#x3D;1),e^{\sin ^2x}$ </li><li>长除法：$\displaystyle \frac{1}{\cos x},\frac{x}{x^2-2x+2}(x&#x3D;1)(2023)$ </li><li>利用奇偶性待定系数：$\displaystyle \frac{1}{\cos x},\arcsin x$ </li><li>利用级数（见高阶导数）：$\displaystyle \frac{x}{x^2-2x+2}(x&#x3D;1)(2023)$</li></ol></li><li>应用<ol><li>求近似：$\sqrt[12]{4000}$ </li><li>利用带 $\mathrm{Lagrange}$ 余项的 $\mathrm{Taylor}$ 展式<ol><li>设 $f(x)$ 在 $[a,b]$ 上二阶可导，证明：$\displaystyle \exists \xi \in (a,b),f(b)-2f\left(\frac{a+b}{2}\right)+f(a)&#x3D;\frac{(b-a)^2}{4}f’’(\xi)$ </li><li>证明：$e\in \mathbb R-\mathbb Q$ </li><li>令 $f (x)&#x3D;f (0)+f’ (0) x+\frac{1}{2}f’’ (\theta (x) x) x^2,\theta (x)\in (0,1)$，证明：若 $f’’’ (x)\neq 0$，则 $\displaystyle\lim_{x\to 0}\theta (x)&#x3D;\frac{1}{3}$</li></ol></li><li>求数列极限：若 $\displaystyle a_n&#x3D;1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+\dots \frac{-1^{n-1}}{n}$，求 $\displaystyle \lim_{n\to \infty}a_n$ </li><li>利用两个对称的 $\mathrm{Taylor}$ 展式<ol><li>若 $f (x)$ 在 $[-1,1]$ 上三阶可导，且 $f (1)&#x3D;1, f (-1)&#x3D;0, f’ (0)&#x3D;0$，证明：$\exists \xi \in [-1,1], f’’’ (\xi)&#x3D;3$ </li><li>若 $\forall x\in \mathbb R,\vert f (x)\vert \le M_0, \vert f’’ (x)\vert \le M_2$，证明：$\vert f’ (x)\vert \le \sqrt{2 M_0 M_2}$ </li><li>若 $\forall x\in (0,1),\vert f (x)\vert \le M_0, \vert f’’ (x)\vert \le M_2$，证明：$\vert f’ (x)\vert \le 2M_0+\frac{1}{2}M_2$</li></ol></li></ol></li></ol></li><li>导数的应用<ol><li>凹凸性<ol><li>开区间上的凸函数连续，且每一点处左右导数存在</li><li>闭区间反例：$\arcsin x, x\in[0,1], f (x)&#x3D;\begin{cases}x^2, -1\lt x\lt 1\\2, x&#x3D;\pm 2 \end{cases}$ （左右端点处）</li><li>开&#x2F;闭区间可导，则闭区间下凸 $\Leftrightarrow$  每一点切线在曲线下方</li><li>闭区间连续、开区间可导，则闭区间下凸 $\Leftrightarrow$ 导函数在开区间单增</li><li>闭区间连续、开区间二阶可导，则闭区间下凸 $\Leftrightarrow$ 二阶导 $\ge 0$</li></ol></li><li>$\mathrm{Newton}$ 法<ol><li>设 $f\in C^2[a, b], f (a) f (b)\lt 0,\forall x\in[a, b], f’(x) f’’(x)\neq 0$，且 $f$ 在 $(a, b)$ 上有唯一零点 $c$，则任取 $x_0\in[a, b]$，令 $\displaystyle x_{n+1}&#x3D;x_n-\frac{f (x_n)}{f’ (x_n)}$，若 $x_1\in [a, b]$，则 $\displaystyle \lim_{n\to \infty}x_n&#x3D;c$，且 $\displaystyle |x_{n+1}-c|\le \frac{M}{2 m}|x_n-c|^2, M&#x3D;\sup_{x\in[a, b]}|f’’ (x)|, m&#x3D;\inf_{x\in[a, b]}|f’ (x)|$</li></ol></li><li>函数作图<ol><li>要点：定义域、周期性、奇偶性、对称性、渐近线、增减性、凹凸性、特殊点</li><li>斜渐近线 $\displaystyle \Leftrightarrow \lim_{x\to \infty} \frac{f (x)}{x}&#x3D;a,\lim_{x\to \infty}(f (x)-ax)&#x3D;b$</li></ol></li><li>例题<ol><li>证明：$\displaystyle ab\le \frac{a^p}{p}+\frac{b^q}{q}$，其中 $\displaystyle p\gt 1, q\gt 1,\frac{1}{p}+\frac{1}{q}&#x3D;1, a\gt 0, b\gt 0$ </li><li>求曲线 $y^3-x^3+3 xy&#x3D;0$ 的渐近线</li><li>$(2024)$ 利用函数的凹凸性证明：<ol><li>$\forall x\in (0,1),n\in \mathbb N$，$\displaystyle \frac{n^x\cdot n!}{(x+1)\cdots (x+n)}\lt 1$ </li><li>$\displaystyle \lim_{n\to +\infty}\frac{n^x\cdot n!}{(x+1)\cdots (x+n)}$ 存在</li></ol></li></ol></li></ol></li></ol><h2 id="四、积分"><a href="#四、积分" class="headerlink" title="四、积分"></a>四、积分</h2><ol><li>不定积分<ol><li>常用方法<ol><li>分部积分</li><li>有理分式分解</li><li>三角换元</li><li>万能替换</li><li>可化为有理式的简单无理式</li><li>$\mathrm{Euler}$ 换元</li><li>联合积分法</li><li>递推法</li></ol></li><li>例题<ol><li>$\displaystyle \int \sqrt{x^2+a^2} dx$ </li><li>$\displaystyle \int \left((x+a)^2+b^2\right)^{-k}dx, b\neq 0$ </li><li>$\displaystyle I&#x3D;\int e^{ax}\sin bx dx, J&#x3D;\int e^{ax} \cos bx dx$ </li><li>$\displaystyle \int \frac{\alpha \cos x+\beta \sin x}{\lambda \cos x+\mu \sin x}dx$</li><li>$\displaystyle I&#x3D;\int \frac{1}{1+x^2+x^4}dx, J&#x3D;\int \frac{x^2}{1+x^2+x^4}dx$ </li><li>$\displaystyle I&#x3D;\int \frac{\cos^3 x}{\cos x+\sin x}dx, J&#x3D;\int \frac{\sin^3 x}{\cos x+\sin x}dx$ </li><li>$\displaystyle \int \frac{1}{\sin (x+a)\sin (x+b)}dx, a-b\neq k\pi, k\in \mathbb Z$</li><li>$\displaystyle \int e^x\left (\frac{1-x}{1+x^2}\right)^2 dx$ </li><li>$\displaystyle \int \frac{1+\sin x}{1+\cos x}e^x dx$ </li><li>$\displaystyle \int \frac{x^2-1}{x^2+1}\frac{dx}{\sqrt{1+x^2+x^4}}$ </li><li>$\displaystyle \int \frac{5 x^3+3 x-1}{(x^3+3 x+1)^3}dx$ </li><li>$\displaystyle \int \frac{1-2 x^3}{(x^2-x+1)^3}dx$ </li><li>$\displaystyle \int \frac{1}{x^4+1}dx$</li></ol></li></ol></li><li>定积分与广义积分<ol><li>常用方法<ol><li>转为不定积分（见不定积分）</li><li>颠倒积分区间后相加</li><li>递推法</li><li>拆积分区间</li></ol></li><li>例题<ol><li>$\displaystyle \int_0^{+\infty} \frac{\arctan x}{(1+x^2)^\frac{3}{2}}dx$ </li><li>$\displaystyle \int_0^1 \frac{\ln (1+x)}{1+x^2}dx$ </li><li>$\displaystyle \int_0^{\frac{\pi}{2}}\ln\cos xdx$ </li><li>$\displaystyle \int_0^{+\infty} \frac{x\ln x}{(1+x^2)^2}dx$ </li><li>$\displaystyle \int_0^{+\infty} \frac{\arctan ax-\arctan bx}{x}dx$，其中 $a,b\gt 0$ </li><li>证明：$\displaystyle I_n&#x3D;\int_0^{\frac{\pi}{2}}\sin^nxdx&#x3D;\int_0^{\frac{\pi}{2}} \cos^nxdx$，并求 $I_n$ </li><li>$f\in C[1,+\infty)$，证明：$\forall a\gt 1,\displaystyle \int_1^a f (x^2+\frac{a^2}{x^2})\frac{dx}{x}&#x3D;\int_1^a f (x+\frac{a^2}{x})\frac{dx}{x}$</li></ol></li></ol></li><li>应用<ol><li>平面区域的面积：函数形式、极坐标形式、参数方程形式</li><li>曲线弧长：函数形式、参数方程形式（极坐标转化为参数方程）</li><li>旋转体的体积：函数形式、参数方程形式</li><li>旋转面的面积：函数形式、参数方程形式（极坐标转化为参数方程）</li><li>平面曲线的曲率</li><li>积分的物理应用</li></ol></li><li>积分审敛<ol><li>$\mathrm{Cauchy}$ 收敛原理</li><li>非负函数：比较判别法</li><li>变号函数：$\mathrm{Dirichlet}$ 判别法、$\mathrm{Abel}$ 判别法</li></ol></li><li>证明<ol><li>常用定理<ol><li>积分估值</li><li>$\mathrm{Cauchy}$ 不等式</li><li>积分第一中值定理</li><li>积分第二中值定理</li><li>$\mathrm{Newton-Leibnitz}$ 公式</li><li>带积分余项的 $\mathrm{Taylor}$ 公式：余项为 $\displaystyle \frac{1}{n!}\int_{x_0}^x (x-t)^n f^{(n+1)}(t) dt$</li></ol></li><li>例题<ol><li>$f$ 在 $[0,1]$ 上可导，$\displaystyle f (1)&#x3D;4\int_{0}^{\frac{1}{4}}e^{1-x^3}f (x) dx$，证明：$\exists \xi \in[0,1], s.t. f’ (\xi)&#x3D;3\xi^2 f (\xi)$ </li><li>$f$ 可导，$f’ (0)\neq 0$，$\displaystyle \int_{0}^{x}f (t) dt&#x3D;f (\xi (x)) x$，其中 $\xi (x)&#x3D;(0, x)$，求 $\displaystyle \lim_{x\to 0}\frac{\xi (x)}{x}$ </li><li>$f\in C^2[-1,1]$，$f (0)&#x3D;0$，证明：$\displaystyle \exists \xi \in [-1,1], s.t.f’’ (\xi)&#x3D;3\int_{-1}^{1}f (x) dx$ </li><li>$\displaystyle f, g\in C[a, b],\int_{a}^{x}f (t) dt\ge \int_{a}^{x}g (t) dt$，其中 $a\le x\le b$，且 $\displaystyle \int_{a}^{b}f (t) dt&#x3D;\int_{a}^{b}g (t) dt$，证明：$\displaystyle \int_{a}^{b}xf (x) dx\le \int_{a}^{b}xg (x) dx$ </li><li>$f\in C^1[a, b]$，且 $f (a)&#x3D;0$，证明：$\displaystyle \int_a^b f^2 (x) dx\le \frac{(b-a)^2}{2}\int_a^b (f’ (x))^2 dx-\frac{1}{2}\int_a^b (x-a)^2 (f’ (x))^2 dx$ </li><li>证明：$\displaystyle \left (\frac{2 n-1}{e}\right)^{\frac{2 n-1}{2}}\lt 1\cdot 3\cdot 5\cdot \dots \cdot (2 n-1)\lt \left (\frac{2 n+1}{e}\right)^{\frac{2 n+1}{2}}$ </li><li>$f\in C^1[0, a]$，$f (0)&#x3D;0$，证明：$\displaystyle \int_0^a|f (x) f’ (x)|dx\le \frac{a}{2}\int_0^a (f’ (x))^2 dx$ </li><li>$f\in C^1[0,1]$，证明：<ol><li>$\displaystyle |f (x)|\le\int_0^1|f (t)|dt+\int_0^1|f’ (t)|dt$，其中 $x\in[0,1]$ </li><li>$\displaystyle \left|f \left(\frac{1}{2}\right)\right|\le\int_0^1|f (t)|dt+\frac{1}{2}\int_0^1|f’ (t)|dt$</li></ol></li><li>证明：$\displaystyle \int_0^{\frac{\pi}{2}}e^{-R\sin x}\begin{cases}\lt \frac{\pi}{2 R}(1-e^{-R}), R\gt 0\\\gt \frac{\pi}{2 R}(1-e^{-R}), R\lt 0 \end{cases}$ </li><li>证明下列等式：<ol><li>$\displaystyle \sum_{k&#x3D;1}^n (-1)^{k+1}\frac{1}{k}C_n^k&#x3D;1+\frac{1}{2}+\dots +\frac{1}{n}$ </li><li>$\displaystyle \sum_{k&#x3D;0}^n (-1)^k\frac{1}{2 k+1}C_n^k&#x3D;\frac{(2 n)!!}{(2 n+1)!!}$</li></ol></li><li>设 $f (x)$ 在每个有限区间上可积，且 $\displaystyle \lim_{x\to +\infty}f (x)&#x3D;A,\lim_{x\to -\infty}f (x)&#x3D;B$，其中 $A, B$ 都是有限数，证明：$\displaystyle \forall a\gt 0,\int_{-\infty}^{+\infty}(f (x+a)-f (x)) dx$ 存在，并求其值</li><li>设函数 $f (x)$ 在 $[0,+\infty)$ 上连续且极限 $\displaystyle \lim_{x\to +\infty}f (x)$ 存在，记作 $f (+\infty)$，证明：$\displaystyle \int_0^{+\infty}\frac{f (ax)-f (bx)}{x}dx&#x3D;(f (0)-f (+\infty)) \ln\frac{b}{a}$，其中 $a, b$ 为两个正数</li><li>$\displaystyle \int_a^{+\infty} f (x) dx$ 收敛，$f (x)$ 在 $[a,+\infty)$ 上单调，证明：$\displaystyle \lim_{x\to +\infty}xf (x)&#x3D;0$ </li><li>设 $f (x)$ 在 $(0,1]$ 上单调，在 $x&#x3D;0$ 的邻域内无界，证明：$\displaystyle \int_0^1 f (x) dx$ 收敛时，有 $\displaystyle \int_0^1 f (x) dx&#x3D;\lim_{n\to \infty}\frac{1}{n}\sum_{i&#x3D;1}^n f\left(\frac{i}{n}\right)$；对于一般的 $f (x)$，瑕积分 $\displaystyle \int_a^b f (x) dx$ 是否可以看成相应 $\mathrm{Riemann}$ 和 $\displaystyle \sum_{i&#x3D;1}^nf (\xi_i)\Delta x_i$ 的极限？</li><li>设 $f\in C (0,+\infty)$，且 $\forall a\gt 0, b\gt 1$，都有积分值 $\displaystyle \int_a^{ab}f (x) dx$ 与 $a$ 无关，求证：存在常数 $C$，使得 $\displaystyle f (x)&#x3D;\frac{C}{x}, x\in (0,+\infty)$</li></ol></li></ol></li></ol><h2 id="五、常微分方程"><a href="#五、常微分方程" class="headerlink" title="五、常微分方程"></a>五、常微分方程</h2><ol><li>$\mathrm{ODE}$ 的计算<ol><li>一阶 $\mathrm{ODE}$<ol><li>变量分离法</li><li>常数变易法</li><li>齐次方程：$\displaystyle y’&#x3D;f \left(\frac{y}{x}\right)\Rightarrow$ 令 $\displaystyle u&#x3D;\frac{y}{x}$ </li><li>一次分式：$\displaystyle y’&#x3D;\frac{a_1 x+b_1 y+c_1}{a_2 x+b_2 y+c_2}$<ol><li>$\displaystyle c_1&#x3D;c_2&#x3D;0\Rightarrow y’&#x3D;\frac{a_1+b_1\frac{y}{x}}{a_2+b_2\frac{y}{x}}$，再令 $\displaystyle u&#x3D;\frac{y}{x}$ </li><li>$\displaystyle \frac{a_1}{a_2}&#x3D;\frac{b_1}{b_2}&#x3D;k\Rightarrow$ 令 $\displaystyle a_2 x+b_2 y&#x3D;u$</li><li>$\displaystyle \begin{cases}a_1 x+b_1 y+c_1\\a_2 x+b_2 y+c_2 \end{cases}$ 交于一点 $(x_0, y_0)\Rightarrow$ 令 $\displaystyle \begin{cases}X&#x3D;x-x_{0}\\Y&#x3D;y-y_{0} \end{cases}$，再令 $\displaystyle u&#x3D;\frac{Y}{X}$</li></ol></li><li>一阶隐方程<ol><li>$y&#x3D;f (x, y’)\Rightarrow$ 令 $u&#x3D;y’$，再两边对 $x$ 求导</li><li>$x&#x3D;f (y, y’)\Rightarrow$ 令 $u&#x3D;y’$，再两边对 $y$ 求导</li><li>$F (x, y’)&#x3D;0\Rightarrow$ 令 $u&#x3D;y’$，若 $\displaystyle \begin{cases}x&#x3D;f(t)\\u&#x3D;g (t) \end{cases}$，则 $\displaystyle \begin{cases}x&#x3D;f(t)\\y&#x3D;\int g (t) f’ (t) dt+C \end{cases}$ </li><li>$F (y, y’)&#x3D;0\Rightarrow$ 令 $u&#x3D;y’$，若 $\displaystyle \begin{cases}y&#x3D;f(t)\u&#x3D;g (t) \end{cases}$，则 $\displaystyle \begin{cases}x&#x3D;\int g(t) f’(t) dt+C\y&#x3D;f (t) \end{cases}$</li></ol></li><li>恰当方程<ol><li>$ydx+xdy&#x3D;d (xy)$ </li><li>$\displaystyle \frac{ydx-xdy}{y^2}&#x3D;d\left (\frac{y}{x}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2}&#x3D;-d\left (\frac{x}{y}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{xy}&#x3D;d\left (\ln\left|\frac{x}{y}\right|\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2+y^2}&#x3D;d\left (\arctan \frac{x}{y}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2-y^2}&#x3D;d\left (\ln\left|\frac{x-y}{x+y}\right|\right)$</li></ol></li><li>特殊方程<ol><li>$\displaystyle \frac{dy}{dx}&#x3D;p (x) y+q (x) y^n\Rightarrow y^{-n}\frac{dy}{dx}&#x3D;p (x) y^{1-n}+q (x)\Rightarrow$ 令 $z&#x3D;y^{1-n}$ </li><li>$\displaystyle \frac{dy}{dx}&#x3D;p (x) y^2+q (x) y+r (x)\Rightarrow$ 找特解 $\psi (x)$，再令 $z&#x3D;y-\psi (x)$</li></ol></li></ol></li><li>高阶 $\mathrm{ODE}$<ol><li>降阶法<ol><li>$F (x, y^{(k)}, y^{(k+1)},\dots ,y^{(n)})&#x3D;0\Rightarrow$ 令 $u&#x3D;y^{(k)}$ </li><li>$F (y, y’, \dots ,y^{(n)})&#x3D;0\Rightarrow$ 令 $u&#x3D;y’$ </li><li>$y, y’, \dots ,y^{(n)}$ 以齐次多项式出现 $\Rightarrow$ 令 $\displaystyle u&#x3D;\frac{y’}{y}$</li></ol></li><li>二阶线性 $\mathrm{ODE}$ 的常数变易法<ol><li>已知两个线性无关解：假设 $c_1’ (x) y_1(x)+c_2’ (x) y_2 (x)&#x3D;0$ </li><li>已知一个非零解</li></ol></li><li>常系数 $\mathrm{ODE}$ 的特征法<ol><li>齐次：单实根、单复根、多重实根、多重复根</li><li>非齐次<ol><li>$p (t) e^{\lambda t}\Rightarrow q (t) t^ke^{\lambda t}$ </li><li>$p (t) e^{\alpha t}\sin \beta t$ 或 $p (t) e^{\alpha t}\cos \beta t\Rightarrow t^k[P (t) \cos\beta t+Q (t)\sin \beta t]e^{\alpha t}$ </li><li>叠加原理</li></ol></li></ol></li><li>$\mathrm{Euler}$ 方程：$x^ny^{(n)}+a_1 x^{n-1}y^{(n-1)}+\dots +a_{n-1}xy’+a_nx&#x3D;f (x)$<ol><li>令 $u&#x3D;\ln|x|\Rightarrow x^ny^{(n)}&#x3D;D (D-1)\dots (D-n+1) y$，其中 $D$ 表示 $\displaystyle \frac{d}{du}$</li></ol></li></ol></li><li>微分方程组：计算相似对角化 $\Rightarrow$ 计算矩阵幂次 $\Rightarrow$ 常数变易</li><li>例题<ol><li>$xy’+y&#x3D;y\ln (xy)$ </li><li>$xdy-ydx&#x3D;\sqrt{x^2+y^2}dx$ </li><li>$y’’\cos x-2 y’\sin x+3 y\cos x&#x3D;e^x$ </li><li>$(x-2 xy-y^2) y’+y^2&#x3D;0$ </li><li>$y^4 dx+(2 x^2-3 xy^3) dy&#x3D;0$ </li><li>$x’&#x3D;\begin{pmatrix} 3&amp;5\\ -5&amp;3\end{pmatrix}x$</li><li>$\begin{cases} x’&#x3D;-3x-y\\y’&#x3D;x-y\end{cases}$</li><li>$x’&#x3D;\begin{pmatrix} 1&amp;1 \\ 0&amp;1 \end{pmatrix} x+\begin{pmatrix} e^{-t} \\ 0 \end{pmatrix}$，$x(0)&#x3D;\begin{pmatrix} -1\\1 \end{pmatrix}$</li><li>$\begin{cases} x’&#x3D;y+z\\y’&#x3D;z+x\\z’&#x3D;x+y\end{cases}$，$\begin{cases}x(0)&#x3D;1\\y(0)&#x3D;0\\z(0)&#x3D;5\end{cases}$</li></ol></li></ol></li><li>证明题<ol><li>解的存在唯一性定理<ol><li>一阶 $\mathrm{ODE}$</li><li>一阶线性 $\mathrm{ODE}$</li><li>高阶线性 $\mathrm{ODE}$</li><li>微分方程组</li></ol></li><li>例题<ol><li>$\displaystyle f\in C^1[0,+\infty),\lim_{x\to +\infty}f (x)+f’ (x)&#x3D;0$，求 $\displaystyle \lim_{x\to +\infty} f (x)$ </li><li>$f (x), g (x), y (x)\in C[a, b], f (x)\gt 0,\displaystyle y (x)\le g (x)+\int_a^x f (t) y (t) dt,\forall x\in [a, b]$，证明：$\displaystyle y (x)\le g (x)+\int_a^xf (t) g (t) e^{\int_t^xf (s) ds}dt,\forall x\in[a, b]$ </li><li>$f (x)$ 在 $[0,+\infty)$ 上连续，$\displaystyle \forall x\ge 0,0\le \int_0^xf (t) dt\le f^2 (x)$，证明：<ol><li>若存在 $0\le a\lt b, f (a)&#x3D;f (b)&#x3D;0$，则 $\forall x\in[a, b], f (x)&#x3D;0$ </li><li>若存在 $c\gt 0, f (c)\neq 0$，则 $\displaystyle f (x)\gt \frac{1}{2}(x-c)$</li></ol></li><li>设 $f (x)$ 在 $[0,1]$ 上非负连续，且满足 $\displaystyle (f (x))^2\le 1+2\int_0^x f (t) dt, x\in [0,1]$，证明：$f (x)\le 1+x, x\in[0,1]$ </li><li>$(2023)$ 在微分方程 $y’+a (x) y&#x3D;b (x)$ 中，已知 $a(x), b(x)\in C(\mathbb R)$，若 $\exists c\gt 0, s.t. a (x)\ge c,\forall x\ge 0$，且 $\displaystyle \lim_{x\to +\infty}b (x)&#x3D;0$，证明：该方程的任意解 $y (x)$ 均满足 $\displaystyle \lim_{x\to +\infty} y (x)&#x3D;0$ </li><li>$(2023)$ 设函数 $f (x)\in C[0,1]$，且满足 $\displaystyle |f (x)|\le 1+\int_0^x f (t) dt,\forall x\in[0,1]$，证明：$|f (x)|\le e^x,\forall x\in [0,1]$ </li><li>设 $p (x)&#x3D;x^n+a_{n-1}x^{n-1}+\dots +a_1 x+a_0$ 为实系数 $n$ 次多项式，若 $p (x)\ge 0, x\in \mathbb R$，证明：$p (x)+p’ (x)+\dots +p^{(n)}(x)\ge 0, x\in \mathbb R$</li><li>证明：若函数 $f$ 在 $\mathbb R$ 上可导，且 $\forall x\in \mathbb R$，$\begin{cases} |f’(x)|\ge |f(x)|\\ |f(x)|\le \sqrt{2}\end{cases}$，则 $f&#x3D;0$</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础</title>
    <link href="/CProgramming/"/>
    <url>/CProgramming/</url>
    
    <content type="html"><![CDATA[<p>大一上学期程序设计基础的CheatSheet，目前已完结。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="一、随机数"><a href="#一、随机数" class="headerlink" title="一、随机数"></a>一、随机数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">double</span> a,b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>    <span class="hljs-type">double</span> d=<span class="hljs-built_in">rand</span>()/(<span class="hljs-type">double</span>)(RAND_MAX<span class="hljs-number">+1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,a+d*(b-a<span class="hljs-number">+1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、二维动态数组"><a href="#二、二维动态数组" class="headerlink" title="二、二维动态数组"></a>二、二维动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-type">int</span> **a = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span> *));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        a[i] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-built_in">free</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、链表"><a href="#三、链表" class="headerlink" title="三、链表"></a>三、链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *last;<br>&#125;NODE;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    NODE *head = <span class="hljs-literal">NULL</span>;<br>    NODE *tail = <span class="hljs-literal">NULL</span>;<br>    NODE *temp = <span class="hljs-literal">NULL</span>;<br>    NODE *newNode = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        newNode = (NODE *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(NODE));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newNode-&gt;data);<br>        newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            head = newNode;<br>            tail = newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tail-&gt;next = newNode;<br>            newNode-&gt;last = tail;<br>            tail = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(temp-&gt;data==x)&#123;<br>            <span class="hljs-keyword">if</span>(temp==head)&#123;<br>                head = head-&gt;next;<br>                head-&gt;last = <span class="hljs-literal">NULL</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp==tail)&#123;<br>                tail = tail-&gt;last;<br>                tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp-&gt;last-&gt;next = temp-&gt;next;<br>                temp-&gt;next-&gt;last = temp-&gt;last;<br>            &#125;<br>            <span class="hljs-built_in">free</span>(temp);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 循环链表</span><br>    tail-&gt;next = head;<br>    head-&gt;last = tail;<br>    <br>    <span class="hljs-comment">// 取消循环</span><br>    tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;last = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    NODE *p = head;<br>    NODE *q = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        q = p-&gt;last;<br>        p-&gt;last = p-&gt;next;<br>        p-&gt;next = q;<br>        p = p-&gt;last;<br>    &#125;<br>    head = q-&gt;last;<br><br>    <span class="hljs-comment">// 正向输出</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">// 反向输出</span><br>    temp = tail;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>        temp = temp-&gt;last;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">// 链表排序</span><br>    NODE *p1 = head;<br>    NODE *p2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span>)&#123;<br>        p2 = p1-&gt;next;<br>        <span class="hljs-keyword">while</span>(p2!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)&#123;<br>                <span class="hljs-type">int</span> temp = p1-&gt;data;<br>                p1-&gt;data = p2-&gt;data;<br>                p2-&gt;data = temp;<br>            &#125;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 释放链表</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、快排与二分"><a href="#四、快排与二分" class="headerlink" title="四、快排与二分"></a>四、快排与二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> i=l,j=r;<br>        <span class="hljs-type">int</span> pivot=a[l];<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;=pivot &amp;&amp; i&lt;r)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(a[j]&gt;pivot)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                <span class="hljs-type">int</span> temp=a[i];<br>                a[i]=a[j];<br>                a[j]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> temp=a[l];<br>        a[l]=a[j];<br>        a[j]=temp;<br>        <span class="hljs-built_in">qsort</span>(a,l,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">qsort</span>(a,j<span class="hljs-number">+1</span>,r);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]==x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&gt;x)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">bsearch</span>(a,l,mid<span class="hljs-number">-1</span>,x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">bsearch</span>(a,mid<span class="hljs-number">+1</span>,r,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowerbound</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=x)&#123;<br>            <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">0</span> || a[mid<span class="hljs-number">-1</span>]&lt;x)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowerbound</span>(a,l,mid<span class="hljs-number">-1</span>,x);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowerbound</span>(a,mid<span class="hljs-number">+1</span>,r,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> *a=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-built_in">qsort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 二分查找等于</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">bsearch</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,x));<br><br>    <span class="hljs-comment">// 二分查找大于等于</span><br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">lowerbound</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,y));<br>    <br>    <span class="hljs-comment">// 二分查找大于</span><br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;z);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">lowerbound</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,z<span class="hljs-number">+1</span>));<br>    <br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、STL-Deque"><a href="#五、STL-Deque" class="headerlink" title="五、STL Deque"></a>五、STL Deque</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tuple_cmp</span><span class="hljs-params">(tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a,tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)==<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a)&lt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)&lt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_matrix</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;deque&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>            temp.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        matrix.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,matrix[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_sorted_tuple</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; sorted_tuple;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>        sorted_tuple.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_tuple</span>(x,y));<br>    &#125;<br>    <span class="hljs-built_in">stable_sort</span>(sorted_tuple.<span class="hljs-built_in">begin</span>(),sorted_tuple.<span class="hljs-built_in">end</span>(),tuple_cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(sorted_tuple[i]),<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(sorted_tuple[i]));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_stack</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        stack.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack.<span class="hljs-built_in">back</span>());<br>        stack.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        queue.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,queue.<span class="hljs-built_in">front</span>());<br>        queue.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>        <span class="hljs-built_in">create_matrix</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>        <span class="hljs-built_in">create_sorted_tuple</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>        <span class="hljs-built_in">create_stack</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>        <span class="hljs-built_in">create_queue</span>(); <br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、STL-Set"><a href="#六、STL-Set" class="headerlink" title="六、STL Set"></a>六、STL Set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; s1,s2,cap,cup,diff;<br>    <span class="hljs-type">int</span> n1,n2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n2; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_union</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cup, cup.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">begin</span>(); it!=cup.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_intersection</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cap, cap.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cap.<span class="hljs-built_in">begin</span>(); it!=cap.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_difference</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(diff, diff.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=diff.<span class="hljs-built_in">begin</span>(); it!=diff.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator a=cup.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator b=cup.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, *it, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),it));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),a), *a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),b), *b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CheatSheet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一上</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数(1)</title>
    <link href="/LinearAlgebra-1/"/>
    <url>/LinearAlgebra-1/</url>
    
    <content type="html"><![CDATA[<font face="霞鹜文楷等宽"><p>大一上学期线性代数(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、基本定义"><a href="#一、基本定义" class="headerlink" title="一、基本定义"></a>一、基本定义</h2><ol><li>映射：详见<a href="https://sqzr2319.github.io/DiscreteMath-1">离散数学(1)</a></li><li>数域：非空且对四则运算封闭，$\mathbb Q\subset \mathbb F\subset \mathbb R$</li></ol><h2 id="二、矩阵与消元"><a href="#二、矩阵与消元" class="headerlink" title="二、矩阵与消元"></a>二、矩阵与消元</h2><ol><li>证明<ol><li>$AB&#x3D;A*B$ 的列 $&#x3D;A$ 的行 $*B&#x3D;\sum A$ 的列 $*B$ 的行</li><li>上&#x2F;下三角矩阵的乘积仍然是上&#x2F;下三角矩阵</li><li>上&#x2F;下三角矩阵的逆仍然是上&#x2F;下三角矩阵</li><li>可逆矩阵存在 $\mathrm{LU}$ 分解 $\Leftrightarrow$ 各阶顺序主子式非零</li><li>$\mathrm{LDU}$ 分解唯一 $\Rightarrow$ 对称矩阵 $S&#x3D;LDL^T\Rightarrow$ 正定矩阵 $S&#x3D;CC^T$</li></ol></li><li>计算<ol><li>线性方程组的唯一解</li><li>矩阵的逆</li><li>$\mathrm{LU&#x2F;LDU&#x2F;PLU&#x2F;LUP&#x2F;Cholesky}$ 分解</li></ol></li><li>分块矩阵<ol><li>乘法条件：$A&#x3D;(A_{ij})_{m\times n},B&#x3D;(B_{jk})_{n\times p},\forall 1\le j\le n, A_{ij}$ 的行指标 $&#x3D;B_{jk}$ 的列指标</li><li>$A&#x3D;\mathrm{diag}\{A_1,\dots ,A_n\}$ 可逆 $\leftrightarrow$ $\forall 1\le i\le n, A_i$  可逆，且 $A^{-1}&#x3D;\mathrm{diag}\{A_1^{-1},\dots ,A_n^{-1}\}$</li><li>上三角分块矩阵可逆 $\leftrightarrow$ 对角线矩阵均可逆，且逆矩阵的对角线为对角线矩阵的逆</li><li>$M&#x3D;\begin{bmatrix} A&amp;B \\ C&amp;D \end{bmatrix}$ 可逆 $\Rightarrow$ $A$ 可逆 $\Leftrightarrow D-CA^{-1}B$ 可逆 $\Leftrightarrow D$ 可逆 $\Leftrightarrow A-BD^{-1}C$ 可逆</li><li>$A\in M_n (\mathbb F)$ 可逆，$u, v\in \mathbb F^n$，则 $A+uv^T$ 可逆 $\leftrightarrow$ $1+v^TA^{-1} u\neq 0$ ，且当 $A+uv^T$ 可逆时，$(A+uv^T)^{-1}&#x3D;A^{-1}-\frac{A^{-1}uv^TA^{-1}}{1+v^TA^{-1}u}$</li><li>$I+uv^T$ 可逆 $\leftrightarrow$ $1+v^Tu\neq 0$，且当 $I+uv^T$ 可逆时，$(1+uv^T)^{-1}&#x3D;I-\frac{uv^T}{1+v^Tu}$</li></ol></li><li>例题<ol><li>$(2023)$ 证明：若 $A\in \mathbb M_n (\mathbb R)$ 正定，则 $\forall x\in \mathbb R^n, 0\le x^T (A+xx^T)^{-1}x\lt 1$</li></ol></li></ol><h2 id="三、线性空间"><a href="#三、线性空间" class="headerlink" title="三、线性空间"></a>三、线性空间</h2><ol><li>线性空间<ol><li>定义：$+$ 封闭&#x2F;零元&#x2F;负元&#x2F;交换&#x2F;结合；$\times$ 封闭&#x2F;结合&#x2F;一元&#x2F;分配</li><li>子空间：$+,\times$ 封闭</li></ol></li><li>证明<ol><li>矩阵秩的性质<ol><li>$r&#x3D;\begin{bmatrix}A&amp;0\\0&amp;B\end{bmatrix}&#x3D;r (A)+r (B)$</li><li>$r&#x3D;\begin{bmatrix}A&amp;0\\C&amp;B\end{bmatrix}\ge r (A)+r (B)$</li><li>$r (A)+r (B)-n\le r (AB)\le \min\{r (A), r (B)\}$，其中 $A\in M_{m, n}, B\in M_{n, p}$</li><li>$\max\{r (A), r (B)\}\le r (A|B)\le r (A)+r (B)$</li><li>$r (A+B)\le r (A)+r (B)$</li></ol></li><li>矩阵迹的性质<ol><li>$\mathrm{tr} (AB)&#x3D;\mathrm{tr} (BA), \mathrm{tr} (ABC)&#x3D;\mathrm{tr} (BCA)&#x3D;\mathrm{tr} (CAB)$</li><li>$AB-BA\neq I_n$</li><li>$\displaystyle A&#x3D;\begin{bmatrix} a_1&amp;a_2 \\ a_3&amp;a_4 \end{bmatrix}, B&#x3D;\begin{bmatrix} b_1&amp;b_2 \\ b_3&amp;b_4 \end{bmatrix}, \mathrm{tr} (A^TB)&#x3D;\sum_{i&#x3D;1}^4 a_ib_i$</li><li>$\displaystyle \mathrm{tr} (A^TA)&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^na_{ij}^2$</li><li>$\displaystyle x^TAx&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n a_{ij}x_ix_j&#x3D;\mathrm{tr} (Axx^T)$，反对称阵 $x^TAx&#x3D;0$</li></ol></li></ol></li><li>计算<ol><li>极大线性无关组</li><li>$C (A), N (A), C (A^T), N (A^T)$</li><li>线性方程组的所有解</li><li>满秩分解：$Q_1 AQ_2&#x3D;\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}&#x3D;\begin{bmatrix} I_r \\ 0 \end{bmatrix}*\begin{bmatrix} I_r&amp;0 \end{bmatrix}\Rightarrow A&#x3D;Q_1^{-1}\begin{bmatrix} I_r \\ 0 \end{bmatrix}*\begin{bmatrix} I_r&amp;0 \end{bmatrix} Q_2^{-1}$</li></ol></li><li>例题<ol><li>证明：若 $A&#x3D;\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}, B&#x3D;\begin{bmatrix}I&amp;G\\0&amp;0\end{bmatrix}$ 同型且具有相同的四个子空间，则 $F&#x3D;G$</li><li>证明：若 $A, B$ 为同型矩阵，且 $N (A)&#x3D;N (B)$，$\mathrm{rref} (A)&#x3D;\mathrm{rref} (B)$</li><li>证明：对 $n$ 阶方阵 $A$，<ol><li>$A^2&#x3D;A\Leftrightarrow r (A)+r (I_n-A)&#x3D;n$</li><li>$A^2&#x3D;I_n\Leftrightarrow r (I_n+A)+r (I_n-A)&#x3D;n$</li></ol></li><li>证明：对 $\mathbb R^n$ 中线性无关的向量组 $x_0, x_1,\dots ,x_t$，存在满足如下条件的非齐次线性方程组：$x_0, x_1,\dots ,x_t$ 都是该方程组的解且任意解都能被 $x_0, x_1,\dots ,x_t$ 线性表示</li><li>证明：若 $S:\alpha_1,\dots ,\alpha_r$ 线性无关，且可被 $T:\beta_1,\dots ,\beta_t$ 线性表示，可以选择 $T$ 中的 $r$ 个向量换成 $S$，得到的新的向量组与 $T$ 线性等价</li></ol></li></ol><h2 id="四、内积空间"><a href="#四、内积空间" class="headerlink" title="四、内积空间"></a>四、内积空间</h2><ol><li>内积<ol><li>定义：非负性、线性、对称性</li><li>性质：勾股定理、$\mathrm{Cauchy-Schwarz}$ 不等式</li></ol></li><li>证明<ol><li>$N (A)\oplus C (A^T)&#x3D;\mathbb R^n, N (A^T)\oplus C (A)&#x3D;\mathbb R^m$</li><li>$\mathrm{dim} (U+V)+\mathrm{dim} (U\cap V)&#x3D;\mathrm{dim}U+\mathrm{dim}V$</li><li>$A\in M_{n, r}(\mathbb R)$，则 $A^TA$ 可逆 $\Leftrightarrow r (A)&#x3D;r$，即 $N(A^TA)&#x3D;N(A)$</li><li>$P$ 是正交投影矩阵 $\Leftrightarrow P^2&#x3D;P, P^T&#x3D;P\Leftrightarrow P&#x3D;\mathbb P_{C (P)}$</li><li>$A: C (A^T)\to C (A)$ 是双射；$A^T: C (A)\to C (A^T)$ 是双射</li><li>$Q$ 是正交矩阵 $\Leftrightarrow Q^TQ&#x3D;I_n\Leftrightarrow Q^T$ 是正交矩阵，$Q_1, Q_2$ 正交 $\Rightarrow Q_1 Q_2$ 正交</li><li>$Q$ 是正交矩阵 $\Leftrightarrow Qx\cdot Qy&#x3D;x\cdot y\Leftrightarrow |Qx|&#x3D;|x|$（保距、保角度）</li><li>直线投影：$\mathbb P&#x3D;\frac{uu^T}{|u|^2}$，关于法线对称变换：$I-2\mathbb P$，关于直线对称变换：$2\mathbb P-I$</li><li>$QR$ 分解的唯一性 $\Rightarrow A$ 是正交阵且是对角线为正的上三角阵则 $A&#x3D;I_n$</li></ol></li><li>计算<ol><li>$U+V, U\cap V$</li><li>正交投影矩阵</li><li>最小二乘法</li><li>$N (A), C (A^T)$ 分解</li><li>$\mathrm{Gram-Schmidt}$ 正交化</li><li>$QR$ 分解</li></ol></li><li>投影和 $QR$ 的推广<ol><li>投影矩阵：$P^2&#x3D;P$</li><li>$A\in M_{m, n}(\mathbb R), r (M)\lt n\le m$ 的 $QR$ 分解<ol><li>$A&#x3D;BC, B$ 可逆，$C$ 为行简化阶梯矩阵，记 $C&#x3D;\begin{bmatrix} C_1 \\ 0 \end{bmatrix}, C_1$ 对角非负上三角</li><li>对 $B$ 使用 $QR$ 分解，$B&#x3D;QR_B&#x3D;\begin{bmatrix} Q_{1}&amp;Q_{2} \end{bmatrix}*\begin{bmatrix} R_{11}&amp;R_{12} \\ 0&amp;R_{22} \end{bmatrix}, R_{11}, R_{22}$ 上三角</li><li>$A&#x3D;\begin{bmatrix} Q_{1}&amp;Q_{2} \end{bmatrix}\cdot \begin{bmatrix} R_{11}C_1 \\ 0 \end{bmatrix}&#x3D;Q_1\cdot R_{11}C_1$，$Q_1$ 列正交，$R_{11}C_1$ 对角非负上三角</li><li>推广的 $QR$ 分解不唯一</li></ol></li></ol></li><li>例题<ol><li>证明：若 $A, B$ 是正交投影矩阵，则 $A+B$ 是正交投影矩阵 $\Leftrightarrow C (A), C (B)$ 正交</li><li>证明：$n$ 阶方阵 $P$ 是关于 $A$ 的正交投影矩阵 $\Leftrightarrow \forall x\in \mathbb R^n, Px\in C (A), x-Px\in N (A^T)$</li><li>证明：若可逆矩阵 $A$ 对应的线性变换保持向量之间的角度不变，则<ol><li>对 $A$ 进行 $QR$ 分解，则 $R$ 也保持向量之间的角度不变</li><li>$R$ 为对角矩阵</li><li>$R&#x3D;kI_n$，则 $A$ 为正交矩阵的常数倍</li></ol></li><li>证明：反对称矩阵的秩是偶数</li><li>证明：若 $A\in M_n (\mathbb R)$ 可逆且反对称，$b\in \mathbb R^n$，则<ol><li>$r (A+bb^T)&#x3D;n$</li><li>$r \begin{pmatrix} A&amp;b \\ b^T&amp;0 \end{pmatrix}&#x3D;n$</li></ol></li><li>$(2024)$ 证明：若 $\mathbb R^n$ 中的向量 $\alpha_1,\alpha_2,\alpha_3,\alpha_4$ 满足两两之间的标准内积 $a_i^Ta_j&lt;0$，则 $\alpha_1,\alpha_2,\alpha_3,\alpha_4$ 中任意三个向量线性无关</li></ol></li></ol><h2 id="五、行列式"><a href="#五、行列式" class="headerlink" title="五、行列式"></a>五、行列式</h2><ol><li>计算<ol><li>高斯消元</li><li>分块矩阵<ol><li>$\mathrm{det}\begin{pmatrix} A&amp;B \\ C&amp;D \end{pmatrix}&#x3D;\mathrm{det}A*\mathrm{det} (D-CA^{-1}B)$</li><li>$\mathrm{det}\begin{pmatrix} A&amp;B \\ B&amp;A \end{pmatrix}&#x3D;\mathrm{det}(A+B)*\mathrm{det} (A-B)$</li><li>$AB&#x3D;BA\Rightarrow \mathrm{det}\begin{pmatrix} A&amp;B \\ -B&amp;A \end{pmatrix}&#x3D;\mathrm{det}(A^2+B^2)$</li></ol></li><li>$\mathrm{Leibnitz}$ 展开</li><li>$\mathrm{Laplace}$ 展开</li></ol></li><li>应用<ol><li>$\mathrm{Vandemonde}$ 行列式：若 $v_{ij}&#x3D;a_j^{i-1}$，则 $\displaystyle \mathrm{det}V&#x3D;\prod_{1\le i\lt j\le n}(a_i-a_j)$</li><li>$\mathrm{Cauchy}$ 行列式：若 $c_{ij}&#x3D;\frac{1}{x_i+y_j}$，则 $\displaystyle \mathrm{det}C&#x3D;\frac{\prod_{1\le i\lt j\le n}(x_i-x_j)(y_i-y_j)}{\prod_{1\le i, j\lt n}(x_i+y_j)}$</li><li>$\mathrm{Cramer}$ 法则：$\displaystyle x_i&#x3D;\frac{\mathrm{det} (A_1,\dots, A_{i-1}, b, A_{i+1},\dots ,A_n)}{\mathrm{det}A}$</li><li>伴随矩阵：$\displaystyle A^{-1}&#x3D;\frac{A^*}{\mathrm{det}A}, A^*&#x3D;((A_{ij})_{n\times n})^T$</li><li>摄动法<ol><li>$(A^*)^{-1}&#x3D;(A^{-1})^*,(A^T)^*&#x3D;(A^*)^T$</li><li>$A$ 不可逆时，$EA&#x3D;U, U+\epsilon I_n$ 可逆，则 $A_\epsilon&#x3D;E^{-1}(U+\epsilon I_n)&#x3D;A+\epsilon E^{-1}$ 可逆</li></ol></li><li>$\mathrm{det} (I_n+AB)&#x3D;\mathrm{det} (I_m+BA)$</li></ol></li><li>例题<ol><li>证明：若 $A$ 对角占优且对角线元素为正，则 $\mathrm{det}A\gt 0$</li><li>证明：若 $A$ 不可逆，则其伴随矩阵的秩为 $0$ 或 $1$</li><li>证明：若 $A&#x3D;[t_1,\dots ,t_n]$，则 $|\mathrm{det}T|\le||t_1||\dots ||t_n||$</li><li>证明：若 $A$ 可逆且元素为整数，则 $A^{-1}$ 元素为整数 $\Leftrightarrow |\mathrm{det}A|&#x3D;1$</li><li>利用摄动法证明：<ol><li>给定 $A, B\in M_n (\mathbb R)$，则 $\forall \epsilon_0\gt 0,\exists C, s.t. \forall \epsilon\in (0,\epsilon_0),|\mathrm{det} (A+\epsilon B)-\mathrm{det}A|\le C\epsilon$</li><li>记 $A$ 的伴随矩阵为 $A^*$，则 $\displaystyle \lim_{\epsilon\to 0}||(A_\epsilon)^*-A^*||_2&#x3D;0$</li></ol></li></ol></li></ol><h2 id="六、特征值"><a href="#六、特征值" class="headerlink" title="六、特征值"></a>六、特征值</h2><ol><li>特征值<ol><li>$\displaystyle P_A (\lambda)&#x3D;\sum_{k&#x3D;0}^n (-1)^{n-k}S_{n-k}\lambda^{k}$，其中 $S_k$ 是 $A$ 的全体 $k$ 阶主子式的和</li><li>$\displaystyle S_{k}&#x3D;\sum_{1\le i_1\lt \dots \lt i_k\le n}\lambda_{i_1}\dots \lambda_{i_k}, k&#x3D;1\Rightarrow \sum_{i&#x3D;1}^n\lambda_i&#x3D;\mathrm{tr}A, k&#x3D;n\Rightarrow \prod_{i&#x3D;1}^n\lambda_i&#x3D;\mathrm{det}A$</li><li>圆盘定理：$\displaystyle \exists i,|\lambda-a_{ii}|\le\sum_{j\neq i}|a_{ij}|$（对角占优）</li><li>同时对角化 $\Leftrightarrow$ $AB&#x3D;BA$</li></ol></li><li>实对称矩阵<ol><li>实对称矩阵的特征值为实数，实反对称矩阵的特征值为纯虚数或零</li><li>$\displaystyle \lambda_1&#x3D;\max_{x\neq 0}\frac{x^TAx}{x^Tx},\lambda_i&#x3D;\max_{x\notin span\{q_1,\dots ,q_{i-1}\}}\frac{x^TAx}{x^Tx}&#x3D;\min_{x\notin\{q_{i+1},\dots ,q_n\}}\frac{x^TAx}{x^Tx},\lambda_n&#x3D;\min_{x\neq 0}\frac{x^TAx}{x^Tx}$</li><li>$A$ 正定 $\Leftrightarrow$ $P^TAP$ 正定 $\Leftrightarrow A$ 的特征值为正数 $\Leftrightarrow A&#x3D;C^TC\Leftrightarrow A&#x3D;LDL^T$，$D$ 对角为正 $\Leftrightarrow A$ 的各阶顺序主子式为正 $\Leftrightarrow A$ 的所有各阶主子式为正</li><li>$A$ 半正定 $\Leftrightarrow A$ 的特征值非负 $\Leftrightarrow A&#x3D;C^TC\Leftrightarrow A&#x3D;LDL^T$，$D$ 对角非负 $\Leftrightarrow A$ 的各阶主子式非负（注意：各阶顺序主子式非负 $\neq$ 半正定）</li><li>$A$ 负定 $\Leftrightarrow A$ 的各阶顺序主子式负正相间</li><li>实对称矩阵 $A$ 的合同标准形唯一存在 $\begin{bmatrix} I_P&amp; &amp;  \\  &amp;-I_{r-p}&amp; \\ &amp; &amp;0 \end{bmatrix}$，对应正、负、零特征值</li><li>步骤：对 $A$ 作行变换，再对 $\begin{bmatrix} A \\ I \end{bmatrix}$ 作相同的初等列变换，则 $I$ 转变为 $P$</li></ol></li><li>相似对角化的推广：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a><ol><li>$\mathrm{Schur}$ 分解（上三角化）</li><li>$\mathrm{Hamilton-Cayley}$ 定理</li><li>广义特征空间</li><li>$\mathrm{Jordan}$ 标准形</li></ol></li><li>例题<ol><li>若 $A&#x3D;X\Lambda X^{-1}$，求 $\begin{bmatrix} O&amp;A \\ A&amp;O \end{bmatrix}$ 的相似对角化</li><li>$(2023)$ 已知三阶方阵 $A$ 满足 $A^2-2 A-3 I&#x3D;O$，求 $\mathrm{det} (A+2 I)$ 的所有可能取值</li><li>证明：若 $A\in M_n (\mathbb R)$ 反对称，则 $I-A^2$ 正定</li><li>证明：若复矩阵 $A, B$ 可交换，则 $A, B$ 至少有一个公共的特征向量</li><li>证明：若 $A^2&#x3D;A$，则 $A$ 可对角化</li><li>证明：对 $m$ 阶方阵 $A_1$，$n$ 阶矩阵 $A_2$ 和 $m\times n$ 阶矩阵 $B$，若 $A_1, A_2$ 没有相同的特征值，则关于 $m\times n$ 矩阵 $X$ 的矩阵方程 $A_1 X-XA_2&#x3D;B$ 有唯一解</li><li>证明：若 $AB&#x3D;BA$，且 $A$ 有 $n$ 个不同的特征值，则存在不超过 $n-1$ 次的多项式 $f (x), s.t. B&#x3D;f (A)$</li><li>$(2023)$ 证明：若 $A\in M_n (\mathbb R)$ 对称，则 $A$ 至少有 $k$ 个计重数的特征值 $\Leftrightarrow$ 存在 $k$ 维子空间 $V$ 使得对于任意非零向量 $v\in V, v^TAv\gt 0$</li><li>证明：任意迹为 $0$ 的方阵相似于一个对角元素全为 $0$ 的方阵</li><li>证明：若 $A_1,\dots ,A_m$ 是 $m$ 个两两可交换的实对称阵，则它们可同时正交对角化</li><li>证明：若 $A, B$ 满足以下条件，则存在可逆阵 $T$，$T^TAT, T^TBT$ 为对角阵<ol><li>$A$ 正定，$B$ 实对称</li><li>$A, B$ 半正定</li></ol></li><li>证明：给定 $n$ 阶正定矩阵 $A$，则<ol><li>对任意 $y$，$\mathrm{det}\begin{pmatrix} A&amp;y \\ y^T&amp;0 \end{pmatrix}\le 0$</li><li>$\mathrm{det}A\le a_{nn}\mathrm{det} (A_{n-1})$，其中 $A_{n-1}$ 是 $A$ 的顺序主子阵</li><li>$\mathrm{det} (A)\le a_{11}a_{22}\dots a_{nn}$</li><li>对任意实可逆阵 $T$，$\displaystyle (\mathrm{det}T)^2\le \prod_{i&#x3D;1}^n (t_{1 i}^2+t_{2 i}^2+\dots +t_{ni}^2)$</li></ol></li></ol></li></ol><h2 id="七、奇异值分解"><a href="#七、奇异值分解" class="headerlink" title="七、奇异值分解"></a>七、奇异值分解</h2><ol><li>奇异值分解<ol><li>$A^TA$ 与 $AA^T$ 有相同的特征值</li><li>$A: V_\lambda (A^TA)\to V_\lambda (AA^T)$ 是双射</li><li>$A^T: V_\lambda (AA^T)\to V_\lambda (A^TA)$ 是双射</li><li>$\xi_1,\dots ,\xi_s$ 是 $V_\lambda (A^TA)$ 的标准正交基 $\Rightarrow \frac{A\xi_1}{\sqrt{\lambda}},\dots ,\frac{A\xi_s}{\sqrt{\lambda}}$ 是 $V_\lambda (AA^T)$ 的标准正交基</li><li>$\displaystyle A&#x3D;U\Sigma V^T\Rightarrow A^TA&#x3D;V\Lambda V^T, AA^T&#x3D;U\Lambda U^T, A&#x3D;\sum_{i&#x3D;1}^r\sigma_iu_iv_i^T$</li><li>$(u_1,\dots ,u_r) (v_1,\dots ,v_r),(u_{r+1},\dots ,u_m), (v_{r+1},\dots, v_n)$ 分别是 $C (A), C(A^T), N(A^T), N(A)$ 的标准正交基</li><li>步骤：$A^TA$ 的对角化得出 $V,\Sigma\Rightarrow$ 得出 $(u_1,\dots ,u_r)\Rightarrow$ $N (A^T)$ 的标准正交基</li></ol></li><li>应用<ol><li>极分解：$A&#x3D;U\Sigma V^T&#x3D;UV^T*V\Sigma V^T&#x3D;QS$，$Q$ 为正交阵，$S$ 为半正定矩阵</li><li>伪逆<ol><li>定义：$AA^+A&#x3D;A, A^+AA^+&#x3D;A^+, (AA^+)^T&#x3D;AA^+, (A^+A)^T&#x3D;A^+A$</li><li>性质：唯一性；$A^+&#x3D;A^{-1}$；$(A^+)^T&#x3D;(A^T)^+$</li><li>$A\in M_{m, n}, r (A)&#x3D;n\Rightarrow A^+&#x3D;(A^TA)^{-1}A^T; r (A)&#x3D;m\Rightarrow A^+&#x3D;A^T (AA^T)^{-1}$</li><li>$\mathbb P_{C (A)}&#x3D;AA^+,\mathbb P_{C (A^T)}&#x3D;A^+A$</li><li>$T: C (A^T)\to C (A), T (x)&#x3D;Ax, T^{-1}&#x3D;A^+$</li><li>求解：$A&#x3D;U\Sigma V^T\Rightarrow A^+&#x3D;V\Sigma^+U^T$</li></ol></li></ol></li><li>谱范数<ol><li>定义：$\displaystyle ||A||&#x3D;\sup_{x\in \mathbb R^n}\frac{|Ax|}{|x|}&#x3D;\sigma_1$，其中 $\sigma_1$ 是 $A$ 最大的特征值</li><li>性质：$||A+B||\le ||A||+||B||,||AB||\le ||A||||B||,||kA||&#x3D;|k|||A||,||A||&#x3D;0\Leftrightarrow A&#x3D;0$</li><li>$U, V$ 正交 $\Rightarrow ||UAV^T||&#x3D;||A||$</li><li>$|\lambda|\gt||A||\Rightarrow \lambda I-A$ 可逆 $\Leftrightarrow A$ 的特征值在 $[-||A||,||A||]$ 里</li><li>低秩逼近：$\displaystyle \min_{r (B)&#x3D;k}||A-B||&#x3D;\sigma_{k+1}, B&#x3D;\sum_{i&#x3D;1}^k\sigma_iu_iv_i^T$</li><li>正交逼近：$\displaystyle A&#x3D;U\Sigma V^T\Rightarrow \min_{B正交}||A-B||&#x3D;||A-UV^T||$</li></ol></li><li>$\mathrm{Frobenius}$ 范数<ol><li>定义：$\displaystyle||A||_F&#x3D;\sqrt{\mathrm{tr} (A^TA)}&#x3D;\sqrt{\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^na_{ij}^2}&#x3D;\sqrt{\sum_{i&#x3D;1}^r\sigma_i^2}$</li><li>性质：$||A||_F&#x3D;0\Leftrightarrow A&#x3D;0,||kA||_F&#x3D;|k|||A||_F,||A+B||_F\le ||A||_F+||B||_F$</li><li>$U, V$ 正交 $\Rightarrow ||UAV^T||_F&#x3D;||A||_F$</li><li>$||AB||_F\le ||A||_F||B||,||AB||_F\le ||A||||B||_F$</li><li>低秩逼近：$\displaystyle \min_{r (B)\le k}||A-B||_F^2&#x3D;\sum_{i&#x3D;k+1}^r\sigma_i^2, B&#x3D;\sum_{i&#x3D;1}^k\sigma_iu_iv_i^T$</li><li>$\displaystyle A&#x3D;\sum_{i&#x3D;1}^r\sigma_iu_iv_i^T$，则 $\displaystyle \max_{r (Q)\le k, Q 列正交}\mathrm{tr} (Q^TAA^TQ)&#x3D;\sum_{i&#x3D;1}^k\sigma_i^2, Q&#x3D;[u_1,\dots ,u_k]$</li></ol></li><li>例题<ol><li>若 $A&#x3D;U\Sigma V^T$，求 $\begin{bmatrix} O&amp;A^T \ A&amp;O \end{bmatrix}$ 的相似对角化</li><li>证明：若对称阵 $A\in M_n (\mathbb R)$ 有特征值 $\lambda_1\ge \dots \ge \lambda_n$，对应特征向量 $u_1,\dots ,u_n$，则 $\displaystyle \forall m\lt n,\max_{Q\in M_{m, n}(\mathbb R), Q列正交}\mathrm{tr} (Q^TAQ)&#x3D;\sum_{i&#x3D;1}^m\lambda_i$，且 $Q&#x3D;[u_1,\dots ,u_m]$ 时最大</li></ol></li></ol><h2 id="八、线性变换"><a href="#八、线性变换" class="headerlink" title="八、线性变换"></a>八、线性变换</h2><ol><li>证明<ol><li>同构：线性双射，且 $\mathrm{dim} U&#x3D;\mathrm{dim} V&#x3D;n\Rightarrow U\approx V\approx \mathbb F^n$</li><li>相似：线性变换 $T: V\to V$ 在不同基底下的表示矩阵</li><li>相抵：线性变换 $T: V_1\to V_2$ 在不同基底下的表示矩阵</li><li>合同：二次型 $T: V\times V\to \mathbb R$ 在不同基底下的对称阵表示</li></ol></li><li>计算<ol><li>线性变换的表示矩阵</li><li>线性变换的值域与核</li><li>线性变换的特征值、特征向量</li><li>线性变换的相似对角化：$T\alpha&#x3D;\alpha A, AP&#x3D;P\Lambda$，令 $\eta&#x3D;\alpha P\Rightarrow T\eta&#x3D;\eta\Lambda$</li><li>线性变换的相抵标准形：$T\alpha&#x3D;\beta A,P_2 AP_1&#x3D;\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}$ ，令 $\eta&#x3D;\alpha P_1,\gamma&#x3D;\beta P_2^{-1}, T\eta&#x3D;\gamma\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}$</li><li>过渡矩阵：$\begin{bmatrix} A&amp;B \end{bmatrix}$ 高斯消元得 $\begin{bmatrix} I_r&amp;C \\ 0&amp;0 \end{bmatrix}$，则 $P&#x3D;C$（$A$ 可逆时 $P&#x3D;C&#x3D;A^{-1}B$）</li></ol></li><li>相似对角化的推广：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a><ol><li>线性变换的 $\mathrm{Jordan}$ 化</li><li>线性变换的 $\mathrm{Hamilton-Cayley}$ 定理</li></ol></li><li>例题<ol><li>证明：设 $V$ 是 $n$ 维线性空间，$f$ 是其上的线性变换，且存在向量 $a\in V, s.t. f^{n-1}(a)\neq 0, f^n (a)&#x3D;0$，则 $V$ 存在一组基，使得 $f$ 在该组基下的矩阵 $J_n&#x3D;\begin{bmatrix} 0&amp;1&amp; &amp;  \\  &amp;\ddots&amp;\ddots&amp; \\  &amp; &amp;0&amp;1\\ &amp; &amp; &amp;0 \end{bmatrix}$</li></ol></li></ol><h2 id="九、空间解析几何"><a href="#九、空间解析几何" class="headerlink" title="九、空间解析几何"></a>九、空间解析几何</h2><ol><li>叉积与混合积：$x\times y&#x3D;\mathrm{det}\begin{pmatrix} e_1&amp;e_2&amp;e_3  \\  x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \end{pmatrix},(x\times y)*z&#x3D;\mathrm{det}\begin{pmatrix} z_1&amp;z_2&amp;z_3  \\  x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \end{pmatrix}$</li><li>直线与平面<ol><li>$x, y, z$ 共面 $\Leftrightarrow \mathrm{det}\begin{pmatrix} x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \\ z_1&amp;z_2&amp;z_3 \end{pmatrix}&#x3D;0$</li><li>平面的参数方程：$\begin{cases} x&#x3D;x_0+t_1 x_1+t_2 x_2 \\ y&#x3D;y_0+t_1 y_1+t_2 y_2\\ z&#x3D;z_0+t_1 z_1+t_2 z_2 \end{cases}$</li><li>平面的一般方程：$\mathrm{det}\begin{pmatrix} x-x_0&amp;y-y_0&amp;z-z_0 \\ x_1&amp;y_1&amp;z_1 \\ x_2&amp;y_2&amp;z_2 \end{pmatrix}&#x3D;0\Rightarrow Ax+By+Cz+D&#x3D;0$</li><li>平面与平面的位置关系：相交 &#x2F; 平行 &#x2F; 重合</li><li>直线的参数方程：$\begin{cases} x&#x3D;x_0+tX \\ y&#x3D;y_0+tY\\ z&#x3D;z_0+tZ \end{cases}$，消去参数化为标准方程</li><li>直线的标准方程：$\displaystyle \frac{x-x_0}{X}&#x3D;\frac{y-y_0}{Y}&#x3D;\frac{z-z_0}{Z}$，展开化为一般方程</li><li>直线的一般方程：$\begin{cases} A_1 x+B_1 y+C_1 z+D_1&#x3D;0 \\ A_2 x+B_2 y+C_2 z+D_2&#x3D;0 \end{cases}$，取点化为标准方程</li><li>直线与直线的位置关系：异面 &#x2F; 相交 &#x2F; 平行 &#x2F; 重合</li><li>直线与平面的位置关系：$(AX+BY+CZ) t+Ax_0+By_0+Cz_0+D&#x3D;0$ 解的个数</li><li>点到平面的距离：$\displaystyle d&#x3D;\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}$</li><li>点到直线的距离：$\displaystyle d&#x3D;\frac{|AB\times v|}{|v|}$</li><li>异面直线的距离：$\displaystyle d&#x3D;\frac{|(v_1\times v_2)*P_1 P_2|}{|v_1\times v_2|}$</li></ol></li><li>曲面与二次曲面<ol><li>二次型的化简：$A&#x3D;P^TBP$，令 $x&#x3D;Py$，则 $x^TAx&#x3D;y^TBy$</li><li>球面方程：$x^2+y^2+z^2+ax+by+cz+d&#x3D;0$</li><li>柱面方程：$f (x, y)&#x3D;0$ 或 $f (x, z)&#x3D;0$ 或 $f (y, z)&#x3D;0$</li><li>旋转面方程：$f (x,\sqrt{y^2+z^2})&#x3D;0$ 或 $f (y,\sqrt{x^2+z^2})&#x3D;0$ 或 $f (z, \sqrt{x^2+y^2})&#x3D;0$</li><li>空间曲线的方程：两个曲面的交线 $\begin{cases} f(x, y, z)&#x3D;0 \\ g(x, y, z)&#x3D;0 \end{cases}$</li><li>椭球面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}&#x3D;1$</li><li>单叶双曲面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}&#x3D;1$</li><li>双叶双曲面：$\displaystyle \frac{z^2}{c^2}-\frac{x^2}{a^2}-\frac{y^2}{b^2}&#x3D;1$</li><li>锥面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}&#x3D;0$</li><li>椭圆抛物面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}&#x3D;z$</li><li>双曲抛物面：$\displaystyle \frac{x^2}{a^2}-\frac{y^2}{b^2}&#x3D;z$</li></ol></li><li>例题<ol><li>在直角坐标系中，已知平面 $\pi$ 过点 $(1,1,0), (0,0,1), (0,1,1)$，求与平面 $\pi$ 垂直且过点 $(1,1,1)$ 的直线的标准方程</li><li>求 $x_1^2+x_2^2+x_3^2+4 x_1 x_2+4 x_1 x_3-4 x_2 x_3&#x3D;1$ 表示的二次曲面类型</li><li>求过点 $(3,2,1)$ 与直线 $\displaystyle \frac{x}{3}&#x3D;\frac{y}{0}&#x3D;z$ 平行且与平面 $x-y+z+1&#x3D;0$ 垂直的平面方程</li><li>求实二次型 $f (x_1, x_2, x_3)&#x3D;x_1^2+x_2^2-x_3^2-2 x_1 x_3$ 的规范形</li><li>设三元二次型 $f (x_1, x_2, x_3)&#x3D;x_1^2+\frac{1}{2}x_2^2+ax_3^2-x_2 x_3$ 的秩为 $2$<ol><li>求参数 $a$</li><li>求正交阵 $Q$，作正交替换 $X&#x3D;QY$，化二次型 $f (x_1, x_2, x_3)$ 为标准形</li><li>指出 $f (x_1, x_2, x_3)$ 表示何种二次曲面</li></ol></li></ol></li></ol><h2 id="十、应用"><a href="#十、应用" class="headerlink" title="十、应用"></a>十、应用</h2><ol><li>函数的标准内积：$\displaystyle (f,g)&#x3D;f^Tg&#x3D;\int_{-\infty}^{+\infty} f(x)g(x)dx$</li><li>求导算子：$\displaystyle D&#x3D;\frac{d}{dx}$，则 $\displaystyle (Df,g)&#x3D;(f,D^Tg)\Rightarrow D^T&#x3D;-\frac{d}{dx}&#x3D;-D$（由分部积分）</li><li>标准正交多项式：$\mathrm{Jacobi&#x2F;Chebyshev&#x2F;Legendre&#x2F;Laguerre&#x2F;Bernstein}$ 多项式</li><li>求平面区域面积：$\displaystyle S&#x3D;\frac{1}{2}\int_{x_1}^{x_2} \mathrm{det}\begin{pmatrix} x&amp;dx\\y&amp;dy\end{pmatrix}$</li><li>求解微分方程组：详见<a href="https://sqzr2319.github.io/Calculus-A1">微积分A(1)</a></li><li>图像压缩算法：利用 $\mathrm{SVD}$ 分解</li><li>$\mathrm{3D}$ 显示算法：利用正交投影</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学(1)</title>
    <link href="/DiscreteMath-1/"/>
    <url>/DiscreteMath-1/</url>
    
    <content type="html"><![CDATA[<p>大一上学期离散数学(1)的复习笔记，目前已完结。</p><span id="more"></span><font face="霞鹜文楷等宽"><h2 id="一、命题逻辑"><a href="#一、命题逻辑" class="headerlink" title="一、命题逻辑"></a>一、命题逻辑</h2><ol><li>基本定义<ol><li>命题：真值<strong>非真即假或待定</strong>的<strong>陈述句</strong></li><li>合式公式：<strong>有限次</strong>联结，<strong>不包含空公式</strong></li></ol></li><li>命题形式化：注意<strong>异或</strong>和<strong>充要条件</strong>的判断</li><li>波兰表达式<ol><li>中缀表示的扫描：发现第一个右括号 $\to$  返回最近的左括号 $\to$  向右继续扫描</li><li>中缀式 $\Rightarrow$ 波兰式：根据优先级加括号 $\to$  从内层括号逐步向外层脱开</li><li>波兰式 $\Rightarrow$ 中缀式：压栈</li><li>$\neg A$ 的前缀为 $\neg A$，后缀为 $A\neg$</li></ol></li><li>等值公式<ol><li>蕴含<strong>没有结合律、交换律</strong></li><li>双蕴含<strong>没有分配律</strong></li><li>前提合取合并：$P\to (Q\to R)&#x3D;(P\wedge Q)\to R$ </li><li>前提析取合并：$(P\to R)\wedge (Q\to R)&#x3D;(P\vee Q)\to R$ </li><li>前提交换：$P\to (Q\to R)&#x3D;Q\to (P\to R)$ </li><li>从 $T$ 行写双蕴含：$P\leftrightarrow Q&#x3D;(P\wedge Q)\vee (\neg P\wedge \neg Q)$ </li><li>从 $F$ 行写双蕴含：$P\leftrightarrow Q&#x3D;(P\vee \neg Q)\wedge (\neg P\vee Q)$ </li><li>归谬论：$(P\to Q)\wedge (P\to \neg Q)&#x3D;\neg P$ </li><li>代入规则：只能对<strong>重言式</strong>中的<strong>原子命题</strong>使用，且必须<strong>全部代换</strong></li><li>置换规则：只需等值</li></ol></li><li>真值表<ol><li>从 $T$ 行写：一个个情况累加，$1&#x3D;T, 0&#x3D;F$，用极小项构成主析取范式</li><li>从 $F$ 行写：一个个情况排除，$1&#x3D;F, 0&#x3D;T$，用极大项构成主合取范式</li></ol></li><li>真值函项：对 $n$ 个命题变元，每个变元有 $m$ 种取值：可定义 $m^{m^n}$ 个 $n$ 元联结词</li><li>完备集：$\{\neg ,\wedge ,\vee\},\{\neg,\wedge \},\{\neg,\vee\},\{\neg,\to\},\{\uparrow\},\{\downarrow\}$</li><li>对偶式<ol><li>$A^*$：将 $A$ 中出现的 $\wedge ,\vee ,T, F$ 分别用 $\vee, \wedge ,F, T$ 代换</li><li>$A^-$：将 $A$ 中的命题变项分别用各自的互补对代换</li><li>$\neg A&#x3D;A^{*-}$</li></ol></li><li>范式<ol><li>步骤：消去蕴含 $\to$ 将否定内移到命题变项上 $\to$ 利用分配律或<strong>利用真值表</strong><ol><li>$A\wedge (B\vee C)&#x3D;(A\wedge B)\vee (A\wedge C)$ 多用于求析取范式</li><li>$A\vee (B\wedge C)&#x3D;(A\vee B)\wedge (A\vee C)$ 多用于求合取范式</li></ol></li><li>快速填满变项：$\neg P\vee Q&#x3D;m^{0 x}\vee m^{x 1}&#x3D;\bigvee_{0,1,3}$ </li><li>极大项与极小项的关系：$\neg m_2&#x3D;M_5,\neg M_2&#x3D;m_5$ </li><li>否定：$A&#x3D;\bigvee_{0,1,3}\Leftrightarrow \neg A&#x3D;\bigvee_{2,4,5,6,7}, B&#x3D;\bigwedge_{0,1,3}\Leftrightarrow \neg B&#x3D;\bigwedge_{2,4,5,6,7}$ </li><li>主合取范式与主析取范式的转换：$\bigvee_{0,1,3}&#x3D;\neg \neg \bigvee_{0,1,3}&#x3D;\neg \bigwedge_{4,6,7}&#x3D;\bigwedge_{0,1,2,3,5}$ </li><li>永真式的主合取范式、矛盾式的主析取范式为空公式</li></ol></li><li>推理公式<ol><li>$P\wedge Q\Rightarrow P\Rightarrow P\vee Q$ </li><li>假言推理： $P\wedge (P\to Q)\Rightarrow Q$ </li><li>三段论：$(P\to Q)\wedge (Q\to R)\Rightarrow P\to R$</li></ol></li><li>推理演算：注意附加前提引入</li><li>归结推理<ol><li>证明 $A\Rightarrow B$ 步骤：将 $A,\neg B$ 分别化为合取范式，建立子句集，归结出矛盾</li><li><strong>半完备性</strong>：对真命题能够归结出空子句，对假命题得不到任何结论</li></ol></li><li>公理系统<ol><li>公理<ol><li>$(P\vee P)\to P$ </li><li>$P\to (P\vee Q)$</li><li>$(P\vee Q)\to (Q\vee P)$ </li><li>$(Q\to R)\to ((P\vee Q)\to (P\vee R))$ </li><li>$\to,\wedge,\leftrightarrow$ 的定义</li><li>代入、置换、分离规则</li><li>演绎定理：若 $A$ 推出 $B$ 过程中不使用代入规则，则 $A\to B$ 成立</li></ol></li><li>定理<ol><li>$(Q\to R)\to ((P\to Q)\to (P\to R))$ </li><li>$P\to P$ </li><li>$\neg P\vee P$ </li><li>$P\vee \neg P$ </li><li>$P\to \neg \neg P$ </li><li>$\neg \neg P\to P$ </li><li>$(P\to Q)\to (\neg Q\to \neg P)$</li></ol></li><li>例题<ol><li>$(P\vee Q)\to (Q\to (P\vee Q))$ </li><li>$(2022) (\neg Q\to P)\to (\neg P\to Q)$</li></ol></li></ol></li><li>性质<ol><li>满足完备性：是否所有的定理都可由公理系统推导出来</li><li>满足可靠性：非重言式或不成立的公式是否也可推导出来</li><li>满足可判定性：存在一种机械的方法在有穷步内判定任意公式是否为定理</li></ol></li></ol><h2 id="二、谓词逻辑"><a href="#二、谓词逻辑" class="headerlink" title="二、谓词逻辑"></a>二、谓词逻辑</h2><ol><li>基本定义<ol><li>与命题逻辑的关系<ol><li>谓词逻辑 $&#x3D;$ 命题逻辑 $+$ 个体词 $+$ 谓词 $+$ 量词 $+$ 函数</li><li>$P (x), Q (f(x), y)$ 是<strong>命题形式</strong>，<strong>取定谓词、函数，并量化个体词后化为命题</strong></li><li>一个命题是<strong>没有自由变元的谓词常项</strong></li></ol></li><li>合式公式<ol><li>两个合式公式的连接：<strong>无变元 $x$ 在 $A, B$ 中的一个是约束的而在另一个中是自由的</strong></li><li>$A$ 是合式公式，且 $x$ 在 $A$ 中是<strong>自由</strong>变元，则 $(\forall x) A, (\exists x) A$ 是合式公式</li><li>反例：$(\forall x) F (x)\wedge G (x), (\exists x)(\forall x) F (x), (\forall x) P (y)$</li></ol></li></ol></li><li>自然语句的形式化：注意<strong>唯一性</strong>的表示</li><li>有限域下公式的表示法<ol><li>解释：须取定谓词、函数</li><li>有限域下公式的可满足性和普遍有效性依赖且仅依赖于个体域个体的数目</li><li>在 $k$ 个体域上普遍有效 $\Rightarrow$ 在 $k-1$ 个体域上普遍有效</li><li>在 $k$ 个体域上可满足 $\Rightarrow$ 在 $k+1$ 个体域上可满足</li></ol></li><li>等值公式<ol><li>由命题逻辑移植来的等值式</li><li>量词的否定</li><li>量词对无关命题变项的分配律（$\to$ 前件不变后件变）</li><li>量词 $\forall$ 对 $\wedge$、量词 $\exists$ 对 $\vee$ 的分配律</li><li>变元易名</li></ol></li><li>范式<ol><li>前束范式：消去蕴含 $\to$ 否定符内移 $\to$ 量词左移 $\to$ 变元易名</li><li>$\mathrm{Skolem}$ 标准形：$(\exists x)(\forall y)(\exists z) P (x, y, z)&#x3D;P (a, y, f (y))$ </li><li>前束范式与 $\mathrm{Skolem}$ 标准形在<strong>不可满足</strong>的意义下一致</li></ol></li><li>推理公式<ol><li>$(\forall x) P (x)\vee (\forall x) Q (x)\Rightarrow (\forall x)(P (x)\vee Q (x))$ </li><li>$(\exists x)(P (x)\wedge Q (x))\Rightarrow (\exists x) P (x)\wedge (\exists x) Q (x)$ </li><li>$(\forall x)(P (x)\to Q (x))\Rightarrow (\forall x)P(x)\to (\forall x)Q(x)$ </li><li>$(\forall x)(P (x)\to Q (x))\Rightarrow (\exists x)P(x)\to (\exists x)Q(x)$ </li><li>$(\forall x)(P (x)\leftrightarrow Q (x))\Rightarrow (\forall x) P (x)\leftrightarrow (\forall x) Q (x)$ </li><li>$(\forall x)(P (x)\leftrightarrow Q (x))\Rightarrow (\exists x) P (x)\leftrightarrow (\exists x) Q (x)$ </li><li>$(\forall x)(P (x)\to Q (x))\wedge (\forall x)(Q (x)\to R (x))\Rightarrow (\forall x)(P (x)\to R (x))$ </li><li>$(\forall x)(P (x)\to Q (x))\wedge P (a)\Rightarrow Q (a)$ </li><li>$(\forall x)(\forall y) P (x, y)\Rightarrow (\exists x)(\forall y) P (x, y)\Rightarrow (\forall y)(\exists x) P (x, y)$</li></ol></li><li>推理演算<ol><li>$UI$：$(\forall x) P (x)\Rightarrow P (y)$，其中 $y$ 不在 $P (x)$ 中约束出现</li><li>$UG$：$P (y)\Rightarrow (\forall x) P (x)$，其中 $x$ 不在 $P (y)$ 中约束出现</li><li>$EI$：$(\exists x) P (x)\Rightarrow P (c)$，其中 $c$ 不在 $P (x)$ 中出现，<strong>且 $P (x)$ 中无自由变元</strong><ol><li>反例：$(\exists x)(x&gt;y)$ 成立，但 $c&gt;y$ 不成立</li></ol></li><li>$EG$：$P (c)\Rightarrow (\exists x) P (x)$，其中 $x$ 不在 $P (c)$ 中出现</li></ol></li><li>归结推理<ol><li>步骤：将 $A,\neg B$ 分别化为前束范式，再化为 $\mathrm{Skolem}$ 标准形，建立子句集</li><li>归结方法：$P (x)\vee Q (x)$ 与 $\neg P (a)\vee R (y)$ 归结出 $Q (a)\vee R (y)$</li></ol></li><li>一阶逻辑公理系统<ol><li>由命题逻辑移植来的公理（演绎定理除外）</li><li>$(\forall x) P (x)\to P (y)$ </li><li>$P (y)\to (\exists x) P (x)$ </li><li>约束变元易名规则</li><li>后件概括规则：若 $A\to B (x)$ 且 $x$ 在 $A$ 中不出现，则 $A\to (\forall x) B (x)$ </li><li>前件存在规则：若 $A (x)\to B$ 且 $x$ 在 $B$ 中不出现，则 $(\exists x) A (x)\to B$ </li><li>演绎定理：不使用代入规则、前件存在和后件概括规则</li></ol></li><li>性质<ol><li>满足完备性</li><li>满足可靠性</li><li><strong>不满足可判定性</strong>，但有子类是可判定的<ol><li>只含有一元谓词变项的公式是可判定的</li><li>个体域有穷时的谓词公式是可判定的</li><li>$\exists,\forall$ 前束范式的母式中无量词和其他自由变项时是可判定的</li></ol></li></ol></li></ol><h2 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h2><ol><li>集合的运算<ol><li>$A\subseteq B\Leftrightarrow P (A)\subseteq P (B)$</li><li>$A&#x3D;B\Leftrightarrow P (A)&#x3D;P (B)$ </li><li>$P (A)\in P (B)\Rightarrow A\in B$ </li><li>$P (A)\cap P (B)&#x3D;P (A\cap B)$ </li><li>$P (A)\cup P (B)\subseteq P (A\cup B)$</li><li>$P (A-B)\subseteq (P (A)-P (B))\cup \{\emptyset\}$ </li><li>传递集合：$(\forall x)(\forall y)((x\in y\wedge y\in A)\to x\in A)$ <ol><li>等价描述 $1$：传递集合元素的元素都是它的元素</li><li>等价描述 $2$：传递集合的元素都是它的子集</li></ol></li><li>$A$ 是传递集合 $\Leftrightarrow$ $A\subseteq P (A)\Leftrightarrow P(A)$ 是传递集合</li><li>$A\subseteq B\Rightarrow \bigcup A\subseteq \bigcup B$ </li><li>$A\subseteq B\Rightarrow \bigcap B\subseteq \bigcap A$，其中 $A, B$ 非空</li><li>$\bigcup (A\cup B)&#x3D;(\bigcup A)\cup (\bigcup B)$ </li><li>$\bigcap (A\cup B)&#x3D;(\bigcap A)\cap (\bigcap B)$，其中 $A, B$ 非空</li><li>$\bigcup (P (A))&#x3D;A$ </li><li>$A$ 是传递集合 $\Rightarrow$ $\bigcup A$ 是传递集合</li><li>$A$ 的元素都是传递集合 $\Rightarrow$ $\bigcup A$ 是传递集合</li><li>非空集合 $A$ 是传递集合 $\Rightarrow$ $\bigcap A$ 是传递集合，且 $\bigcap A&#x3D;\emptyset$</li><li>非空集合 $A$ 的元素都是传递集合 $\Rightarrow$ $\bigcap A$ 是传递集合</li></ol></li><li>集合论公理系统<ol><li>外延公理</li><li>空集合存在定理</li><li>无序对集合存在定理</li><li>广义并集合存在定理</li><li>子集公理模式</li><li>幂集合公理</li><li>无穷公理</li><li>替换公理模式</li><li>正则公理：任意非空集合 $S$ 存在元素 $x$ 使得 $S$ 和 $x$ 不相交</li><li>选择公理：对任意关系 $R$ 存在函数 $f$ 使得 $f\subseteq R, dom (f)&#x3D;dom (R)$ <ol><li>等价形式：良序定理、$\mathrm{Zorn}$ 引理、基数的三歧性</li></ol></li></ol></li></ol><h2 id="四、关系"><a href="#四、关系" class="headerlink" title="四、关系"></a>四、关系</h2><ol><li>关系的运算<ol><li>$R_1\circ (R_2\cup R_3)&#x3D;R_1\circ R_2 \cup R_1\circ R_3$ </li><li>$R_1\circ (R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$ </li><li>$(R_1\cup R_2)\circ R_3&#x3D;R_1\circ R_3\cup R_2\circ R_3$ </li><li>$(R_1\cap R_2)\circ R_3\subseteq R_1\circ R_3\cap R_2\circ R_3$ </li><li>$R[A\cup B]&#x3D;R[A]\cup R[B]$ </li><li>$R[\bigcup A]&#x3D;\bigcup\{R[B]|B\in A\}$ </li><li>$R[A\cap B]\subseteq R[A]\cap R[B]$ </li><li>$R[\bigcap A]\subseteq \bigcap\{R[B]|B\in A\}$，其中 $A$ 非空</li><li>$R[A]-R[B]\subseteq R[A-B]$ </li><li>$R\uparrow(A\cup B)&#x3D;R\uparrow A\cup R\uparrow B$ </li><li>$R\uparrow (A\cap B)&#x3D;R\uparrow A\cap R\uparrow B$</li></ol></li><li>关系的性质<ol><li>自反：$I_A\subseteq R, r (R)&#x3D;R\cup I_A$  </li><li>反自反：$R\cap I_A&#x3D;\emptyset$ </li><li>对称：$R&#x3D;R^{-1}, s (R)&#x3D;R\cup R^{-1}$ </li><li>反对称：$R\cap R^{-1}\subseteq I_A$ </li><li>传递：$R\circ R\subseteq R, t (R)$ 使用 $\mathrm{Warshall}$ 算法 </li><li>$R_1,R_2$ 自反 $\Rightarrow R^{-1}, R_1\cap R_2, R_1\cup R_2, R_1\circ R_2$ 自反</li><li>$R_1, R_2$ 反自反&#x2F;对称 $\Rightarrow R^{-1}, R_1\cap R_2, R_1\cup R_2, R_1-R_2$ 反自反&#x2F;对称</li><li>$R_1, R_2$ 反对称 $\Rightarrow R^{-1}, R_1\cap R_2, R_1-R_2$ 反对称</li><li>$R_1, R_2$ 传递 $\Rightarrow R^{-1}, R_1\cap R_2$ 传递</li><li>$R_1\subseteq R_2\Rightarrow r&#x2F;s&#x2F;t (R_1)\subseteq r&#x2F;s&#x2F;t (R_2)$ </li><li>$r&#x2F;s (R_1)\cup r&#x2F;s (R_2)&#x3D;r&#x2F;s (R_1\cup R_2)$ </li><li>$t (R_1)\cup t (R_2)\subseteq t (R_1\cup R_2)$ </li><li>$R$ 自反 $\Rightarrow s&#x2F;t (R)$ 自反</li><li>$R$ 对称 $\Rightarrow r&#x2F;t (R)$ 对称</li><li>$R$ 传递 $\Rightarrow r (R)$ 传递</li><li>$rs (R)&#x3D;sr (R)$ </li><li>$rt (R)&#x3D;tr (R)$ </li><li>$st (R)\subseteq ts (R)$ </li><li>$(2022) R$ 的等价闭包：$tsr (R), trs (R), rts (R)$</li></ol></li><li>特殊关系<ol><li>等价关系：自反、对称、传递</li><li>相容关系：自反、对称</li><li>偏序关系：自反、反对称、传递</li><li>拟序关系：反自反、反对称、传递</li><li>全序关系：两两都可比的偏序关系</li><li>良序关系：任意非空子集都有最小元的偏序关系</li><li>偏序关系八大元与链<ol><li>最大&#x2F;小元、上&#x2F;下确界不一定存在，若存在必唯一</li><li>非空有限集合中极大&#x2F;小元一定存在，但不一定唯一</li><li>最大&#x2F;小元为极大&#x2F;小元、上&#x2F;下界、上&#x2F;下确界</li><li>属于子集的上&#x2F;下界为子集的最大&#x2F;小元</li><li>最长链的长度为 $n\Rightarrow$ 至少存在 $n$ 个不相交的反链</li></ol></li><li>良序集一定是全序集</li><li>有限全序集一定是良序集</li><li>良序定理：任意集合都可以良序化</li></ol></li></ol><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><ol><li>函数的性质<ol><li>$f, g$ 是满射&#x2F;单射&#x2F;双射 $\Rightarrow f\circ g$ 是满射&#x2F;单射&#x2F;双射</li><li>$f\circ g$ 是满射 $\Rightarrow f$ 是满射</li><li>$f\circ g$ 是单射 $\Rightarrow g$ 是单射</li><li>$f\circ g$ 是双射 $\Rightarrow f$ 是满射，$g$ 是单射</li><li>左逆：$g\circ f&#x3D;I_A$；右逆：$f\circ g&#x3D;I_A$ </li><li>$f$ 存在左逆&#x2F;右逆 $\Leftrightarrow$ $f$ 是单射&#x2F;满射</li><li>$f$ 存在左逆、右逆且两者相等 $\Leftrightarrow f$ 是双射</li><li>存在单射：$m\le n$；满射：$m\ge n\gt 0\vee m&#x3D;n&#x3D;0$；双射：$m&#x3D;n$ </li><li>函数与函数相容：$x\in A\cap C\Rightarrow f (x)&#x3D;g (x)$ </li><li>函数与等价关系相容：$\langle x, y\rangle\in R\Rightarrow \langle f (x), f (y)\rangle \in R$ </li><li>$f, g$ 相容 $\Leftrightarrow$ $f\cup g$ 是函数 $\Leftrightarrow f\uparrow (A\cap C)&#x3D;g\uparrow (A\cap C)$ </li><li>函数集合 $C$ 相容 $\Rightarrow F&#x3D;\bigcup C$ 是函数，$dom (F)&#x3D;\bigcup \{dom (f)|f\in C\}$ </li><li>$R$ 与 $f$ 相容 $\Rightarrow$ $\exists ! F: A&#x2F;R\to A&#x2F;R, F ([x]_R)&#x3D;[f (x)]_R$</li></ol></li><li>开集与闭集<ol><li>闭集：导集是原集合的子集</li><li>任意集合的导集是闭集</li><li>任意个闭集的交集是闭集，有限个闭集的并集是闭集</li><li>开集：原集合是内点集合的子集</li><li>任意个开集的并集是开集，有限个开集的交集是开集</li><li>若 $A$ 是开集&#x2F;闭集，则 $\mathbb R-A$ 是闭集&#x2F;开集</li></ol></li><li>实数<ol><li>$\mathbb N\to \mathbb Z\to \mathbb Q_1\to \mathbb Q\to \mathbb B\to \mathbb R$ </li><li>$1_\mathbb N&#x3D;\{\emptyset\}, -1_\mathbb Z&#x3D;\langle 0,1\rangle,-1_\mathbb Q&#x3D;\{\frac{1}{-1},\frac{-1}{1},\frac{2}{-2},\frac{-2}{2},\dots\},-1_\mathbb R&#x3D;\{-1,-1+\frac{1}{n},\dots\}$ </li><li>$\mathbb N\approx \mathbb Z, \mathbb R\approx \mathbb R^+, \mathbb N\times \mathbb N\approx \mathbb N, \mathbb N\approx \mathbb Q, (0,1)\approx \mathbb R,[0,1]\approx (0,1),\neg \mathbb N\approx \mathbb R$</li><li>$P (A)\approx A_2,\neg A\approx P (A)$ </li><li>$(2022) \mathbb R\approx \mathbb R\times \mathbb N$</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第二讲 数学软件与线性代数</title>
    <link href="/43Class-2/"/>
    <url>/43Class-2/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第二讲，介绍了 Mathematica 和 MATLAB 的基本用法，主要包括线性方程组的求解、线性空间与内积空间的相关理论、行列式、特征值与奇异值分解等内容。</p><span id="more"></span><font face="霞鹜文楷等宽"><blockquote><p>计算的目的不在于数字本身，而在于洞察其背后的意义。 -Richard Hamming</p></blockquote><p>笃实 43 班的同学们大家好，这里是学委小组的第二期推送。本期我们将结合 Mathematica、MATLAB，帮助大家从头开始复习一遍线性代数。</p><p>考虑到不同老师的教学顺序不同，我们将采用我们自己认为最合理的顺序进行复习。如果屏幕前你的老师是从行列式讲起的，我们希望这篇推送能帮你重新建立起对线性代数的整体理解。</p><h2 id="前言：Mathematica-与-MATLAB-简介"><a href="#前言：Mathematica-与-MATLAB-简介" class="headerlink" title="前言：Mathematica 与 MATLAB 简介"></a>前言：Mathematica 与 MATLAB 简介</h2><p>Mathematica 是由 Wolfram 开发的一款科学计算软件，内置了大量函数可以直接调用，能够大大简化解决数学问题时的计算过程。此外，Wolfram 还提供了一个线上计算平台：<a href="https://www.wolframalpha.com/%E3%80%82">https://www.wolframalpha.com/。</a></p><p>MATLAB 则更加强大，在深度学习、计算机视觉、图像识别等领域都有广泛的应用。但考虑到篇幅所限以及解释型语言较难入门，本文只介绍 MATLAB 的基本矩阵运算指令。</p><p>Mathematica 和 MATLAB 的下载与安装详见信息服务中心 its.tsinghua.edu.cn，篇幅有限，此处不再赘述。</p><p><img src="/img/43Class-2-1.jpg"></p><p>上图是 Mathematica 的启动界面，点按新文档按钮进入如下图所示的编辑界面：</p><p><img src="/img/43Class-2-2.jpg"></p><p>在空白页面中输入指令完毕后点按红色的计算按钮运行指令。</p><p><img src="/img/43Class-2-3.jpg"></p><p>上图是 MATLAB 的操作界面，在命令行窗口中输入指令后按回车键执行指令。</p><h2 id="一、逆矩阵：求解线性方程组唯一解"><a href="#一、逆矩阵：求解线性方程组唯一解" class="headerlink" title="一、逆矩阵：求解线性方程组唯一解"></a>一、逆矩阵：求解线性方程组唯一解</h2><p>线性代数的建立源于对线性方程组的求解。对于有唯一解的线性方程组，我们可以通过对系数矩阵求逆来求出方程的唯一解。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算逆矩阵 *)<br>Inverse[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算逆矩阵</span><br>inv([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>如何保存求逆时高斯消元的具体过程呢？为此我们推出了 LU 分解，又因为 LU 分解不唯一以及 LU 分解与逆矩阵的存在性不等价，我们分别推出了 LDU 分解和 PLU 分解。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 LU/PLU 分解 *)<br>LUDecomposition[&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>&#125;&#125;]<br>(* 输出的第一个元素为一个 <span class="hljs-number">3</span>*<span class="hljs-number">3</span> 矩阵，其中包含对角线的上三角为 U 矩阵，不含对角线的下三角加上 I 为 L 矩阵；输出的第二个 <span class="hljs-number">3</span>*<span class="hljs-number">1</span> 的元素代表 P 矩阵 *)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 LU/LUP 分解</span><br>[L,U,P]=lu([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>])<br></code></pre></td></tr></table></figure><p>而对于有无数解的线性方程组，我们需要线性空间相关理论求出线性方程组的全体解；对于无解的线性方程组，我们可以通过最小二乘法求出最接近解的伪解，而这需要内积空间的相关理论。接下来，我们将按照线性空间→内积空间的顺序依次解决这两个问题。</p><h2 id="二、线性空间：求解线性方程组全体解"><a href="#二、线性空间：求解线性方程组全体解" class="headerlink" title="二、线性空间：求解线性方程组全体解"></a>二、线性空间：求解线性方程组全体解</h2><p>通过 10 条性质，我们定义了抽象线性空间，又通过极大线性无关组、张成、基、维数研究了线性空间的基本性质。接着我们从线性空间回到矩阵，将向量组的秩推广到了矩阵的秩，并定义了矩阵的四个子空间。最后我们推出了线性代数基本定理 1。</p><p>线性代数基本定理 1：对于一个 $m\times n$ 矩阵，</p><ol><li>行空间与列空间的维数相等，等于矩阵的秩。</li><li>行空间与零空间都是 $\mathbb R^n$ 的子空间，且维数之和等于矩阵的行数。</li><li>列空间与左零空间都是 $\mathbb R^m$ 的子空间，且维数之和等于矩阵的行数。</li><li>借助线性空间理论，我们得出了线性方程组全体解的求解方法：全体解&#x3D;特解+零空间。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算线性方程组全体解 *)<br>(* 第一步：计算特解 *)<br>LinearSolve[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;]<br>(* 第二步：计算零空间 *)<br>NullSpace[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算线性方程组全体解</span><br><span class="hljs-comment">% 第一步：计算特解</span><br>x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]\[<span class="hljs-number">2</span>;<span class="hljs-number">5</span>;<span class="hljs-number">8</span>]<br><span class="hljs-comment">% 第二步：计算零空间</span><br>null([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><h2 id="三、内积空间：求解无解线性方程组的伪解"><a href="#三、内积空间：求解无解线性方程组的伪解" class="headerlink" title="三、内积空间：求解无解线性方程组的伪解"></a>三、内积空间：求解无解线性方程组的伪解</h2><p>我们首先定义了线性空间上的内积，推出了勾股定理、Cauchy-Schwarz 不等式，并通过内积定义了正交。接着我们借助正交理论研究矩阵的四个子空间，推出了线性代数基本定理 2。</p><p>线性代数基本定理 2：对于一个 $m\times n$ 矩阵 $A$，</p><ol><li>$A$ 的零空间与行空间互为 $\mathbb R^n$ 上的正交补。</li><li>$A$ 的左零空间与列空间互为 $\mathbb R^m$ 上的正交补。</li><li>$A$ 的行空间到列空间上存在双射 $T_1(x)&#x3D;Ax$。</li><li>$A$ 的列空间到行空间上存在双射 $T_2(x)&#x3D;A^Tx$。</li></ol><p>借助内积空间理论，我们研究了向量到矩阵列空间的投影。对于列向量线性无关的矩阵 $A$，我们推出了投影矩阵 $\mathbb P_{C(A)}&#x3D;A(A^TA)^{-1}A^T$，并推出了最小二乘法。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算最小二乘法 *)<br>LeastSquares[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算最小二乘法</span><br>A=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>b=[<span class="hljs-number">7</span>;<span class="hljs-number">7</span>;<span class="hljs-number">8</span>]<br>x=inv(A&#x27;*A)*A&#x27;*b<br></code></pre></td></tr></table></figure><p>但我们发现投影矩阵的求解过程计算量过大，于是我们借助 Gram-Schmidt 正交化得到了正交矩阵，对于正交矩阵 $Q$，投影矩阵 $\mathbb P_{C(Q)}&#x3D;QQ^T$，大大简化了计算。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 QR 分解 *)<br>&#123;q,r&#125;=QRDecomposition[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 QR 分解</span><br>[Q,R]=qr([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>而对于列向量线性相关的矩阵 $A$，$A^TA$ 不可逆，求解投影矩阵需要先求出伪逆，而伪逆需要奇异值分解相关理论，接下来我们将通过行列式→特征值→奇异值分解的顺序解决这个问题。</p><h2 id="四、行列式，特征值与奇异值：求解伪逆"><a href="#四、行列式，特征值与奇异值：求解伪逆" class="headerlink" title="四、行列式，特征值与奇异值：求解伪逆"></a>四、行列式，特征值与奇异值：求解伪逆</h2><p>行列式的讲解方法一直存在很大争议。我们认为，通过行列式的线性性质推出 Leibnitz 展开，再推出 Laplace 展开是比较合理的顺序。借助行列式，我们推出了矩阵可逆的充要条件是矩阵的行列式不为零。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算矩阵行列式 *)<br>Det[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算矩阵行列式</span><br>det([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br><span class="hljs-comment">% 行列式为 0 时由于浮点数误差往往输出并不为 0</span><br></code></pre></td></tr></table></figure><p>借助行列式理论，我们得到了特征值与特征向量的求解方法：求解方程 $det(\lambda I_n-A)&#x3D;0$，再求解 $N(\lambda I_n-A)$。若特征向量足够张成整个 $\mathbb R^n$，则矩阵可以相似对角化。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算矩阵特征值与特征向量 *)<br>Eigensystem[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br>(* 输出的第一个元素为特征值集合，第二个元素为特征值分别对应的特征向量 *)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算矩阵特征值与特征向量</span><br>[V,D]=eig([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br><span class="hljs-comment">% V 为特征向量矩阵，D 为特征值矩阵</span><br></code></pre></td></tr></table></figure><p>但并非所有矩阵都能够相似对角化，但我们发现所有方阵都与上三角矩阵相似，于是我们推出了 Schur 分解以及 Jordan 分解。这部分内容会在下学期的高等线性代数选讲课程中详细介绍，不在本学期考察范围内，有大致了解即可。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 Schur 分解和 Jordan 分解 *)<br>&#123;q,t&#125;=SchurDecomposition[&#123;&#123;<span class="hljs-number">2.7</span>,<span class="hljs-number">4.8</span>,<span class="hljs-number">8.1</span>&#125;,&#123;<span class="hljs-number">-0.6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>&#125;&#125;]<br>&#123;v,<span class="hljs-built_in">j</span>&#125;=JordanDecomposition[&#123;&#123;<span class="hljs-number">27</span>,<span class="hljs-number">48</span>,<span class="hljs-number">81</span>&#125;,&#123;<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 Schur 分解和 Jordan 分解</span><br>[Q,T]=schur([<span class="hljs-number">2.7</span>,<span class="hljs-number">4.8</span>,<span class="hljs-number">8.1</span>;<span class="hljs-number">-0.6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>])<br>[V,J]=jordan([<span class="hljs-number">27</span>,<span class="hljs-number">48</span>,<span class="hljs-number">81</span>;<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])<br><span class="hljs-comment">% jordan 函数需要 Symbolic Math Toolbox 库</span><br></code></pre></td></tr></table></figure><p>然而有一类矩阵一定能够相似对角化：实对称矩阵，且其特征向量之间还满足正交性，于是我们研究了实对称矩阵以及其特殊分支正定矩阵的正交相似对角化。</p><p>至此，我们终于得到了足够的理论依据，得以推出奇异值分解理论。奇异值分解的求解方法是：先求解 $A^TA$ 的特征值与特征向量，得出右奇异向量以及奇异值，再借助右奇异向量和 $N(A^T)$ 解出左奇异向量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算奇异值分解 *)<br>&#123;u,s,v&#125;=SingularValueDecomposition[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算奇异值分解</span><br>[U,S,V]=svd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>借助奇异值分解，我们推出了伪逆的求解方法：设 $A$ 的奇异值分解为 $A&#x3D;U\Sigma V^T$，则 $A$ 的伪逆 $A^+&#x3D;V\Sigma^+ U^T$，其中 $\Sigma^+$ 为 $\Sigma$ 取转置后再取对角元素的倒数。借助伪逆，我们得以求解列向量线性相关矩阵的投影矩阵：$\mathbb P_{C(A)}&#x3D;AA^+$。此外，可以证明，对于前文线性代数基本定理2中的双射 $T_1(x)$ 和 $T_2(x)$，其逆映射分别为 $T_1^{-1}(x)&#x3D;A^+x,T_2^{-1}(x)&#x3D;A^{T^+}x$。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算伪逆 *)<br>PseudoInverse[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算伪逆</span><br>pinv([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><p>至此，我们已经完全解决了线性方程组 $Ax&#x3D;b$ 的求解或伪解问题。那如果将向量 $x$ 和 $b$ 也分别替换为矩阵 $X$ 和 $B$，我们又该如何求矩阵方程 $AX&#x3D;B$ 的解或伪解呢？</p><p>显然当 $A$ 固定时伪解可以逐列求得，即 $X&#x3D;A^+B$ ，因此更值得讨论的是当 $A$ 变化时如何寻找一个最佳的 $A$ 使得伪解 $X$ 的误差最小。用矩阵论的语言来说，就是当 $rank(A)&#x3D;k$ 固定时，寻找一个最佳矩阵 $A_k$ 使得 $B-\mathbb P_{C(A_k)}B$ 的 Frobenius 范数最小，而这就是主成分分析问题。</p><p>实际上若 $A_k$ 满足条件，则所有列空间与 $A_k$ 的列空间相同的矩阵都满足条件：与其说我们求解的是一个最佳矩阵，不如说我们求解的是一个最佳子空间。因此我们不妨取一个列向量为该子空间标准正交基的矩阵 $Q_k$，借助奇异值分解理论，可以证明：若 $B$ 有奇异值分解 $\displaystyle B&#x3D;U\Sigma V^T&#x3D;\sum^r_{i&#x3D;1}\sigma_i u_i v_i^T$，则当 $Q_k&#x3D;[u_1,u_2,\dots ,u_k]$ 时，有 $\displaystyle||B-\mathbb P_{C(Q_k)}B||_{F_{min}}&#x3D;\sum^r_{i&#x3D;k+1}\sigma_i^2$。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>篇幅所限，课程中涉及的大量推论、应用和证明技巧以及和微积分的联系在本文中都没有覆盖到，还请大家认真复习。最后，下面两个表格分别是特殊矩阵的特征根与特征向量和矩阵可逆与奇异的等价条件。希望能帮助大家串联起整个线性代数体系。</p><p><img src="/img/43Class-2-4.jpg"></p><p><img src="/img/43Class-2-5.jpg"></p><p>这期的内容到这里就结束了，感谢大家读到这里。这里推荐一本书《Introduction to Linear Algebra》-Gilbert Strang，事实上本文的复习顺序就是受到了这本书的启发，且上面的两个表格也正来自这本书。</p><p>原定本期更新的 Markdown 和 LaTeX 环境的配置过程和入门语法将顺延到寒假期间更新，在这里先预祝各位同学期末考试顺利。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第一讲 Standard Template Library (STL)</title>
    <link href="/43Class-1/"/>
    <url>/43Class-1/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第一讲，介绍了 STL 库的基本用法，主要包括 deque 和 set 的使用方法以及一些常用的 STL 函数。</p><span id="more"></span><font face="霞鹜文楷等宽"><p>笃实43班的同学们大家好，这里是学委小组的第一期推送。</p><p>经过半学期的沉淀<del>（摸鱼）</del>，在小组内部以及和吴导商量过后，我们已经有了接下来工作计划的雏形：由褚一枫同学来负责制作介绍编程相关知识的推送，而邓写意同学负责编程月赛等活动的组织工作。</p><p>考虑到篇幅所限，每期介绍的内容不会很多、很深，会以一些课上不讲的小技巧以及一些实用软件的简略介绍为主，更多细节最终还是要靠大家自己去探索。</p><p>本学期内我们预计将发布四期：</p><ol><li>STL</li><li>Markdown 与 LaTeX</li><li>常用数学软件</li><li>常用编程 AI</li></ol><p>废话不多说，让我们直接进入正题。</p><h2 id="一、What-is-STL"><a href="#一、What-is-STL" class="headerlink" title="一、What is STL ?"></a>一、What is STL ?</h2><p>如果直接去百度上搜索，大概率会得到如下结果：</p><blockquote><p>STL 是 C++ 标准模板库（Standard Template Library）的缩写，是 C++ 标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。</p></blockquote><p>问题来了，数据结构又是什么？</p><p>简而言之，数据结构就是数据存储在计算机里的样子。比如一维数组就是一个最简单的数据结构，数据在内存里连续排列，可以按照顺序逐个访问。</p><p>更“高级”一点的数据结构还包括二维数组（矩阵）、链表、栈、队列、树、图等等，其中二维数组和链表我们已经在程设课上接触过了，而栈和队列分别是深度优先搜索（DFS）和广度优先搜索（BFS）的底层架构，再过两周程设课就会讲到，至于树和图，则是离散数学和数据结构这两门课的常客。</p><p>就像我们只需要引入标准输入输出库 stdio.h 就可以直接实现输入和输出而无需进行命令行操作一样，我们只需要引入 STL 库和 std 命名空间，就可以通过一些简单的函数直接实现这些数据结构。</p><p>而不同于标准输入输出库，STL 库是很多个库的合称，如 vector、stack、algorithm 等，考虑到篇幅所限，我们今天主要介绍两个模板：双端队列 deque 和集合 set。</p><h2 id="二、What-is-Deque"><a href="#二、What-is-Deque" class="headerlink" title="二、What is Deque ?"></a>二、What is Deque ?</h2><p>还记得前面说到的栈和队列吗？我们先简要介绍一下这两个数据结构。</p><p>栈的特点是“先进后出”，简而言之，可以把它理解成往一个桶里一边塞衣服一边把衣服取出来，显然只能取出叠在最上面的衣服，而塞的越早的衣服就叠在越下面，也就要越晚才能再次被取出来。</p><p>举一个简单的例子，按顺序进行以下操作：</p><p>1 入栈，2 入栈，3 入栈，3 出栈，2 出栈，4 入栈，4 出栈，1 出栈，5 入栈，5 出栈。</p><p>这样我们就成功的把 [1,2,3,4,5] 通过一个栈转化成了 [3,2,4,1,5]。</p><p>下面这张图可以辅助大家理解：</p><p><img src="/img/43Class-1-1.jpg"></p><p>而队列则和栈恰好相反，特点是“先进先出”，可以理解为在食堂排队，先入队的自然能先领到午饭。</p><p>同样举一个简单的例子：</p><p>1 入队，2 入队，3 入队，1 出队，4 入队，2 出队，3 出队，5 入队，4 出队，5 出队。</p><p>可能你会发现，这样一通操作下来不还是 [1,2,3,4,5] 吗？没错，因为这并不是队列的正确用途。等大家学到广度优先搜索就会明白队列的作用了。</p><p>同样给一张图辅助大家理解：</p><p><img src="/img/43Class-1-2.jpg"></p><p>所以讲了那么久的栈和队列，Deque呢？</p><p>我知道你很急，但你先别急。</p><p>Deque 的全称是 Double Queue（双端队列），简而言之，它既可以从前面插入可以从后面插入，既可以从前面取出也可以从后面取出。</p><p>可见，数组、栈和队列都可以视作 Deque 的一个“特殊情况”：数组只从后面插入而不取出，栈从后插入、从后取出，队列从后插入、从前取出。那么二维数组呢？也很简单，只需要让一个 Deque 的每个元素又都各是一个 Deque 即可。而且 Deque 模板无需提前给定大小，也就是自动实现了动态数组的功能。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tuple_cmp</span><span class="hljs-params">(tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a,tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)==<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a)&gt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)&gt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b);<br>&#125;<span class="hljs-comment">//基于tuple的二元组降序排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_matrix</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;deque&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>            temp.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        matrix.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<span class="hljs-comment">//输入：先创建临时一维deque存储一行，再把一整行导入二维deque</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,matrix[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-comment">//输出：deque允许通过下标访问</span><br>&#125;<span class="hljs-comment">//基于deque的动态二元数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_sorted_tuple</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; sorted_tuple;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>        tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; temp=<span class="hljs-built_in">make_tuple</span>(x,y);<br>        sorted_tuple.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<span class="hljs-comment">//输入：先创建临时tuple存储二元组，再将整个tuple导入deque</span><br>    <span class="hljs-built_in">stable_sort</span>(sorted_tuple.<span class="hljs-built_in">begin</span>(),sorted_tuple.<span class="hljs-built_in">end</span>(),tuple_cmp);<span class="hljs-comment">//对tuple组成的deque进行降序排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(sorted_tuple[i]),<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(sorted_tuple[i]));<br>    &#125;<span class="hljs-comment">//输出：tuple不允许用下标[0][1]访问，只能用get函数</span><br>&#125;<span class="hljs-comment">//基于deque&amp;tuple&amp;sort的降序二元组数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_stack</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        stack.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<span class="hljs-comment">//入栈</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack.<span class="hljs-built_in">back</span>());<br>        stack.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<span class="hljs-comment">//出栈</span><br>&#125;<span class="hljs-comment">//基于deque的栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        queue.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<span class="hljs-comment">//入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,queue.<span class="hljs-built_in">front</span>());<br>        queue.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<span class="hljs-comment">//出队</span><br>&#125;<span class="hljs-comment">//基于deque的队列</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>          <span class="hljs-built_in">create_matrix</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>          <span class="hljs-built_in">create_sorted_tuple</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>          <span class="hljs-built_in">create_stack</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>          <span class="hljs-built_in">create_queue</span>();<br>          <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，case 1&amp;3&amp;4 已经包括了如何创建一个 Deque、如何从前后插入和取出元素，接下来我们解释一下 case 2 中用到的多元组 tuple 和 sort 函数。</p><p>简而言之，tuple 是几个子元素组成的有序对，可以看成结构体的平替。case 2 的代码中已经包括了如何创建一个 tuple 元素、如何取出一个 tuple 中特定位置的子元素。</p><p>sort 函数位于 algorithm 库中，时间复杂度（可以简单理解为算法的效率）为 O(nlgn)，远远优秀于程设课讲的 O(n²) 的冒泡排序。其默认参数为对单元素（即非 tuple、pair、struct）组成的一维数组进行升序排列，因此上面 case 2 在对 tuple 进行降序排列时，需要自己写一个比较函数。此外，case 2 中使用了 stable_sort，其与 sort 的区别在于 stable_sort 会保持排序前后两个相同元素的相对位置，而 sort 不一定。</p><p>再补充一点，实际上 deque 库中同样有在任意位置插入或删除的函数 d.insert(n,x) 和 d.erase(n)，但由于底层架构的原因这两个操作的复杂度都是 O(n) 而非 O(1)，无法平替链表。如需使用 STL 实现链表可以引入 list 库，这里由于篇幅所限就不展开了。<del>留给读者作为课后习题</del></p><h2 id="三、What-is-Set"><a href="#三、What-is-Set" class="headerlink" title="三、What is Set ?"></a>三、What is Set ?</h2><p>高中数学告诉我们，集合具有互异性，而 STL 中的 set 也是如此，可以将输入的数据自动去重。不同的是，它还能实现自动排序。如向一个 set 中输入 [1,5,3,5,7,4]，输出的结果会是 [1,3,4,5,7]。值得一提的是，set 的插入操作时间复杂度为 O(lgn)，也就是说它可以做到以 sort 函数的效率持续维护一个升序数组。</p><p>此外，STL 也提供了 multiset（升序，不去重）、unordered_set（无序，去重）、unordered_multiset（无序，不去重）等功能，可以按需使用。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; s1,s2,cap,cup,diff;<br>    <span class="hljs-type">int</span> n1,n2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<span class="hljs-comment">//输入s1</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1：set不允许通过下标访问，只能通过迭代器访问</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n2; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<span class="hljs-comment">//输入s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_union</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cup, cup.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1∪s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">begin</span>(); it!=cup.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1∪s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_intersection</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cap, cap.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1∩s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cap.<span class="hljs-built_in">begin</span>(); it!=cap.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1∩s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_difference</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(diff, diff.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1-s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=diff.<span class="hljs-built_in">begin</span>(); it!=diff.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1-s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中的第一个3</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator a=cup.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中第一个≥3的数</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator b=cup.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中第一个＞3的数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, *it, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),it));<span class="hljs-comment">//输出第一个3的“下标”</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),a), *a);<span class="hljs-comment">//输出第一个≥3的数的“下标”</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),b), *b);<span class="hljs-comment">//输出第一个&gt;3的数的“下标”</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中已经包含了如何创建一个 set、如何向 set 中插入元素，接下来我们解释一下代码中用到的迭代器 iterator 和几个 algorithm 库函数。</p><p>强调一点：set 与 deque 不同，不能直接通过下标访问，只能通过地址访问。而 iterator 可以简单理解为 STL 容器专用指针，注意这里不能直接用指针的原因是通过 STL 容器存储的元素在内存中的位置不一定是连续的，用指针的 ++ 操作很可能访问到内存中错误的位置，而使用 iterator 就可以避免这个问题。</p><p>此外，代码中用到了七个 algorithm 库函数，我们分别做一下简要介绍：</p><ol><li>set_union：求两个有序列表的并集</li><li>set_intersection：求两个有序列表的交集</li><li>set_difference：求两个有序列表的差集</li><li>s.find(x)：返回列表中x元素第一次出现的地址</li><li>s.lowerbound(x)：返回有序列表中第一个≥x的元素的地址</li><li>s.upperbound(x)：返回有序列表中第一个&gt;x的元素的地址</li><li>distance：求两个迭代器之间的距离</li></ol><p>上面的代码稍作修改就可以无痛速通这道程设 OJ 作业：</p><p><img src="/img/43Class-1-3.jpg"></p><p>当然，这道题的输入数据已经是升序排列的了，也就不需要再使用 set 容器，直接使用普通数组或前面介绍的 deque 容器配合上述 algorithm 库函数即可。实际上 algorithm 库中还有很多有奇效的函数，如 next_permutation 等等，由于篇幅所限就不展开了。<del>同样留作课后习题</del></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>考虑到初学 C 语言的同学了解底层架构的必要性，STL 库在 OJ 作业和期末考试中是禁用的，切勿模板一时爽期末火葬场（据学长所说数据结构课也是禁用 STL 的）。然而在大作业中 STL 库可以随意使用，能够大幅提升代码构建效率和运行效率。此外，对于想参加算法竞赛的同学，个人建议在熟练使用的同时也去了解一下 STL 库函数的底层实现，可以大大加深对数据结构与算法优化的理解。</p><p>这期的内容到这里就结束了，感谢大家读到这里。下期我们将为大家简要介绍 Markdown 和 LaTeX 环境的配置过程和入门语法，这些内容对正在修读离散数学（1）的同学可能并不陌生，希望能够帮到未选课的同学。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
