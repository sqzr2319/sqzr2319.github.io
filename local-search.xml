<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/25Fall/DSA/"/>
    <url>/25Fall/DSA/</url>
    
    <content type="html"><![CDATA[<p>大二上学期数据结构的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>数据：程序能处理的符号的总称</li><li>数据元素：数据的基本单位，由数据项组成（有独立含义的最小单位）</li><li>数据结构：有相互关系的数据元素的集合，三元素：逻辑结构、运算、存储结构（物理结构，元素及关系的存储表示，顺序&#x2F;链式&#x2F;索引&#x2F;散列），表现为逻辑抽象模型（抽象数据类型）和具体实现</li><li>数据类型：性质相同的值的集合和集合上定义的操作的总称</li><li>抽象数据类型 ADT：数据元素的集合（数据对象）、关系集合、操作集合</li><li>算法：解决方案的准确完整描述，有穷&#x2F;确定&#x2F;可行&#x2F;输入&#x2F;输出，正确&#x2F;可读&#x2F;健壮&#x2F;高效，设计取决于逻辑结构，实现依赖于存储结构</li><li>程序：数据结构+算法，基于编程语言的算法实现</li></ol><h3 id="2-渐进分析"><a href="#2-渐进分析" class="headerlink" title="2. 渐进分析"></a>2. 渐进分析</h3><ol><li>渐进上界&#x2F;紧界&#x2F;下界：$O&#x2F;\Theta&#x2F;\Omega$，记作 $T\le&#x2F;&#x3D;&#x2F;\ge g$，$\forall n\ge n_0,c_1g(n)\le f(n)\le c_2g(n)$，$O$ 与 $\Theta$ 常混用</li><li>时间复杂度是空间复杂度的上界</li><li>主定理：$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，$a\ge 1,b&gt;1$<ol><li>若 $f(n)&#x3D;O(n^{\log_b a-\epsilon})$，则 $T(n)&#x3D;\Theta(n^{\log_b a})$</li><li>若 $f(n)&#x3D;\Theta(n^{\log_b a}\log^k n)$，则 $T(n)&#x3D;\Theta(n^{\log_b a}\log^{k+1} n)$</li><li>若 $f(n)&#x3D;\Omega(n^{\log_b a+\epsilon})$，且 $af(n&#x2F;b)\le cf(n)$，则 $T(n)&#x3D;\Theta(f(n))$</li></ol></li></ol><h3 id="3-常见算法"><a href="#3-常见算法" class="headerlink" title="3. 常见算法"></a>3. 常见算法</h3><ol><li>斐波那契数列</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f=<span class="hljs-number">1</span>,g=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>&lt;n--)&#123;<br>    g=g+f;<br>    f=g-f;<br>&#125;<span class="hljs-comment">//f为上一轮的g</span><br><span class="hljs-keyword">return</span> g;<br></code></pre></td></tr></table></figure><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>线性表（序列）：数据元素的有限序列</li><li>向量（顺序表）：线性表基于数组的存储表示</li><li>列表（链表）：线性表基于链式存储的表示</li><li>串：字符组成的有限序列，空串&#x2F;空白串</li><li>排序码：排序依据</li></ol><h3 id="2-向量"><a href="#2-向量" class="headerlink" title="2. 向量"></a>2. 向量</h3><ol><li>随机打乱</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=V.<span class="hljs-built_in">size</span>();i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-built_in">swap</span>(V[i<span class="hljs-number">-1</span>],V[<span class="hljs-built_in">rand</span>()%i]);<br>&#125;<span class="hljs-comment">//V[i-1]与V[0,i)中某一随机元素交换</span><br></code></pre></td></tr></table></figure><ol start="2"><li>二分查找</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(lo&lt;hi)&#123;<br>    Rank mi=(lo+hi)&gt;&gt;<span class="hljs-number">1</span>;<br>    (e&lt;A[mi])?hi=mi:lo=mi<span class="hljs-number">+1</span>;<br>&#125;<span class="hljs-comment">//循环终止时lo=hi,A[lo-1]&lt;=e&lt;A[hi]</span><br><span class="hljs-keyword">return</span> --lo;<span class="hljs-comment">//&lt;=e的最后一个元素</span><br></code></pre></td></tr></table></figure><ol start="3"><li>归并排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(i&lt;mid&amp;&amp;j&lt;last)<br>    <span class="hljs-keyword">if</span>(data[i]&lt;data[j]) sorted[k++]=data[i++];<br>    <span class="hljs-keyword">else</span> sorted[k++]=data[j++];<br><span class="hljs-keyword">while</span>(i&lt;mid) sorted[k++]=data[i++];<br><span class="hljs-keyword">while</span>(j&lt;last) sorted[k++]=data[j++];<br><span class="hljs-keyword">for</span>(i=first;i&lt;last;i++) data[i]=sorted[i];<br></code></pre></td></tr></table></figure><ol start="4"><li>快速排序（可用于 K-选取，$O(n)$ 平均复杂度）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pivotL=l,pivotR=r,x=data[l];<br><span class="hljs-keyword">while</span>(pivotL&lt;pivotR)&#123;<br>    <span class="hljs-keyword">while</span>(pivotL&lt;pivotR&amp;&amp;data[pivotR]&gt;x) pivotR--;<br>    <span class="hljs-keyword">if</span>(pivotL&lt;pivotR) data[pivotL++]=data[pivotR];<br>    <span class="hljs-keyword">while</span>(pivotL&lt;pivotR&amp;&amp;data[pivotL]&lt;x) pivotL++;<br>    <span class="hljs-keyword">if</span>(pivotL&lt;pivotR) data[pivotR--]=data[pivotL];<br>&#125;<br>data[pivotL]=x;<br><span class="hljs-comment">//改进：小样本采用插入排序；三数取中法选主元</span><br></code></pre></td></tr></table></figure><ol start="5"><li>排序算法比较</li></ol><table><thead><tr><th>方法</th><th>平均情况</th><th>最好情况</th><th>最差情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔</td><td>$O(n\log^2 n)$</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>堆</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>不稳定</td></tr></tbody></table><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h3><ol><li>归并排序：原地归并</li><li>排序算法比较：选择排序稳定</li></ol><h3 id="4-串"><a href="#4-串" class="headerlink" title="4. 串"></a>4. 串</h3><ol><li>蛮力匹配</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(j&lt;m&amp;&amp;i&lt;n)&#123;<br>    <span class="hljs-keyword">if</span>(T[i]==P[j])&#123;<br>        i++;j++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        i=i-j<span class="hljs-number">+1</span>; j=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> i-j;<span class="hljs-comment">//i-j&gt;n-m则匹配失败</span><br></code></pre></td></tr></table></figure><ol start="2"><li>KMP next</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(j&lt;m&amp;&amp;i&lt;n)&#123;<br>    <span class="hljs-keyword">if</span>(T[i]==P[j]||j&lt;<span class="hljs-number">0</span>)&#123;<br>        i++;j++;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        j=next[j];<br>    &#125;<br>&#125;<span class="hljs-comment">//O(n)</span><br><br><span class="hljs-type">int</span> t=next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j&lt;m<span class="hljs-number">-1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>||P[j]==P[t])&#123;<br>        j++;t++;<br>        next[j]=t;<br>    &#125;<br>    <span class="hljs-keyword">else</span> t=next[t];<br>&#125;<span class="hljs-comment">//next表构建，O(m)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>KMP nextval</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> t=nextval[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j&lt;m<span class="hljs-number">-1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>||P[j]==P[t])&#123;<br>        j++;t++;<br>        <span class="hljs-keyword">if</span>(P[j]!=P[t]) nextval[j]=t;<br>        <span class="hljs-keyword">else</span> nextval[j]=nextval[t];<br>    &#125;<br>    <span class="hljs-keyword">else</span> t=nextval[t];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、栈与队列"><a href="#三、栈与队列" class="headerlink" title="三、栈与队列"></a>三、栈与队列</h2><h3 id="1-表达式求值"><a href="#1-表达式求值" class="headerlink" title="1. 表达式求值"></a>1. 表达式求值</h3><ol><li>中缀转后缀：数字直接过，左括号入栈，右括号弹栈至左括号，运算符弹栈至栈顶优先级小于自身</li><li>后缀求值：数字入栈，遇运算符弹栈两元素，结果入栈</li><li>优先级：阶乘 $&gt;$ 指数</li></ol><h3 id="2-栈混洗"><a href="#2-栈混洗" class="headerlink" title="2. 栈混洗"></a>2. 栈混洗</h3><ol><li>$n$ 元素：卡特兰数 $h(n)&#x3D;\frac{C^{n}_{2n}}{n+1}$</li><li>递推：$h(n)&#x3D;h(n-1)h(0)+h(n-2)h(1)+\cdots+h(0)h(n-1)$</li><li>判断可行混洗序列</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>    <span class="hljs-keyword">while</span>(S.<span class="hljs-built_in">empty</span>()||B[k]!=S.<span class="hljs-built_in">top</span>())&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        S.<span class="hljs-built_in">push</span>(i++);<br>    &#125;<br>    S.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="3-单调栈"><a href="#3-单调栈" class="headerlink" title="3. 单调栈"></a>3. 单调栈</h3><ol><li>求每个元素右侧第一个比它大的元素下标</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(!S.<span class="hljs-built_in">empty</span>()&amp;&amp;A[S.<span class="hljs-built_in">top</span>()]&lt;A[i])&#123;<br>        temp=S.<span class="hljs-built_in">pop</span>();<br>        res[temp]=i;<br>    &#125;<br>    S.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-二项式展开系数"><a href="#4-二项式展开系数" class="headerlink" title="4. 二项式展开系数"></a>4. 二项式展开系数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">enqueue</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-built_in">enqueue</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">+2</span>;j++)&#123;<br>        s=<span class="hljs-built_in">dequeue</span>();<br>        e=<span class="hljs-built_in">front</span>();<br>        <span class="hljs-built_in">enqueue</span>(s+e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、树"><a href="#四、树" class="headerlink" title="四、树"></a>四、树</h2><h3 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>深度：从根到节点的路径长度（根节点为0）</li><li>高度：到叶子节点的最长路径长度</li><li>树高：根节点高度（单节点为0，空树为-1）</li><li>完全二叉树：除最后一层全满，最后一层往左靠</li></ol><h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h3><ol><li>节点数：$n_0&#x3D;n_2+1$</li><li>顺序表示：从 $0$ 开始</li><li>形态数：卡特兰数（前序固定，中序可能情况）</li><li>重构：前&#x2F;后+中可重构，前+后不可重构（真二叉树可）</li></ol><h3 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h3><ol><li>插入：末尾插入，和父节点比较交换（上滤）</li><li>删除：根和末尾交换，和子节点比较交换（下滤）</li><li>构建：从最右的非叶节点逐个下滤，$O(n)$</li><li>用堆实现 $\mathrm{Huffman}$ 树</li></ol><h2 id="五、搜索树"><a href="#五、搜索树" class="headerlink" title="五、搜索树"></a>五、搜索树</h2><h3 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1. 二叉搜索树"></a>1. 二叉搜索树</h3><h3 id="2-AVL"><a href="#2-AVL" class="headerlink" title="2. AVL"></a>2. AVL</h3><h3 id="3-B-Tree"><a href="#3-B-Tree" class="headerlink" title="3. B-Tree"></a>3. B-Tree</h3><h3 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h3><h3 id="5-KD-Tree"><a href="#5-KD-Tree" class="headerlink" title="5. KD-Tree"></a>5. KD-Tree</h3><h2 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h2><h3 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>简单路径：路径上顶点不重复</li><li>连通分量：非连通图的极大连通子图</li><li>强连通分量：$\mathrm{Tarjan}$ 有向环缩点法</li></ol><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h3><ol><li>深度优先搜索：发现次序先序（dTime），访问次序后序（fTime）</li><li>边的类型：树边、前向边、后向边、跨边</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(<span class="hljs-built_in">status</span>(v))&#123;<br>    <span class="hljs-keyword">case</span> Undiscovered: type=Tree;<br>    <span class="hljs-keyword">case</span> Discovered: type=Backward;<br>    <span class="hljs-keyword">default</span>: type=(<span class="hljs-built_in">dTime</span>(v)&gt;<span class="hljs-built_in">dTime</span>(u))?Forward:Cross;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-图论算法"><a href="#3-图论算法" class="headerlink" title="3. 图论算法"></a>3. 图论算法</h3><ol><li>优先级搜索</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PQ.<span class="hljs-built_in">push</span>(start);<br><span class="hljs-keyword">while</span>(!PQ.<span class="hljs-built_in">empty</span>())&#123; <br>    <span class="hljs-type">int</span> v=PQ.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(VISITED==<span class="hljs-built_in">status</span>(v)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-built_in">firstNbr</span>(v);<span class="hljs-number">-1</span>&lt;u;u=<span class="hljs-built_in">nextNbr</span>(v,u))<br>        <span class="hljs-keyword">if</span>(VISITED!=<span class="hljs-built_in">status</span>(u))&#123;             <br>            <span class="hljs-built_in">priority_update</span>(v,u);<br>            PQ.<span class="hljs-built_in">push</span>(u);<br>        &#125; <br>    <span class="hljs-built_in">status</span>(v)=VISITED; <br>&#125;<br><br><span class="hljs-built_in">priority_update</span>(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> u)&#123;<br>    u.priority=<span class="hljs-built_in">min</span>(u.priority,<span class="hljs-built_in">weight</span>(v,u));<span class="hljs-comment">//Prim</span><br>    u.priority=<span class="hljs-built_in">min</span>(u.priority,v.priority+<span class="hljs-built_in">weight</span>(v,u));<span class="hljs-comment">//Dijkstra</span><br>    u.priority=v.priority<span class="hljs-number">+1</span>;<span class="hljs-comment">//BFS</span><br>    u.priority=v.priority<span class="hljs-number">-1</span>;<span class="hljs-comment">//DFS</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>$\mathrm{Bellman-Ford}$</li><li>$\mathrm{Floyd}$</li><li>拓扑排序</li></ol><h2 id="七、散列"><a href="#七、散列" class="headerlink" title="七、散列"></a>七、散列</h2><ol><li>$\mathrm{hash}&#x3D;f(\mathrm{key})$，$\mathrm{key}$ 为关键码，$f$ 为散列函数，直接定址&#x2F;除余&#x2F;MAD&#x2F;数字分析&#x2F;平方取中&#x2F;折叠&#x2F;随机</li><li>冲突处理：多槽位&#x2F;独立链&#x2F;公共溢出区</li><li>开放定址&#x2F;闭散列策略：动态删除+线性&#x2F;平方&#x2F;双向平方（表长 $M%4&#x3D;3$ 前 $M$ 次可遍历）&#x2F;随机试探+再散列（扩容）</li><li>散列码转换：强制转换&#x2F;分块求和&#x2F;字符串多项式</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>大二上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/25Fall/CSAPP/"/>
    <url>/25Fall/CSAPP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>大二上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动力学基础</title>
    <link href="/25Fall/Dynamics/"/>
    <url>/25Fall/Dynamics/</url>
    
    <content type="html"><![CDATA[<p>大二上学期动力学的复习笔记，目前更新至动力学普遍定理。</p><span id="more"></span><h2 id="一、质点运动"><a href="#一、质点运动" class="headerlink" title="一、质点运动"></a>一、质点运动</h2><h3 id="1-自然坐标"><a href="#1-自然坐标" class="headerlink" title="1. 自然坐标"></a>1. 自然坐标</h3><ol><li>速度：$\mathbf{v}(t)&#x3D;\dot{s}\boldsymbol{\tau}(s)$</li><li>加速度：$\mathbf{a}(t)&#x3D;\mathbf{a}_\tau+\mathbf{a}_n&#x3D;\ddot{s}\boldsymbol{\tau}(s)+\frac{\dot{s}^2}{\rho}\mathbf{n}(s)$</li></ol><h3 id="2-极坐标"><a href="#2-极坐标" class="headerlink" title="2. 极坐标"></a>2. 极坐标</h3><ol><li>矢径：$\mathbf{r}(t)&#x3D;\rho(t)\mathbf{e}_\rho(t)$</li><li>速度：$\mathbf{v}(t)&#x3D;\mathbf{v}_\rho+\mathbf{v}_\varphi&#x3D;\dot{\rho}\mathbf{e}_\rho+\rho\dot{\varphi}\mathbf{e}_\varphi$</li><li>加速度：$\mathbf{a}(t)&#x3D;\mathbf{a}_\rho+\mathbf{a}_\varphi&#x3D;(\ddot{\rho}-\rho\dot{\varphi}^2)\mathbf{e}_\rho+(\rho\ddot{\varphi}+2\dot{\rho}\dot{\varphi})\mathbf{e}_\varphi$</li></ol><h2 id="二、刚体运动"><a href="#二、刚体运动" class="headerlink" title="二、刚体运动"></a>二、刚体运动</h2><h3 id="1-一般运动"><a href="#1-一般运动" class="headerlink" title="1. 一般运动"></a>1. 一般运动</h3><ol><li>速度：$\mathbf{v}_P&#x3D;\mathbf{v}<em>O+\boldsymbol{\omega}\times\mathbf{r}</em>{OP}$，有投影定理</li><li>加速度：$\mathbf{a}<em>P&#x3D;\mathbf{a}<em>O+\boldsymbol{\varepsilon}\times \mathbf{r}</em>{OP}+\boldsymbol{\omega}\times(\boldsymbol{\omega}\times \mathbf{r}</em>{OP})$</li></ol><h3 id="2-平面运动"><a href="#2-平面运动" class="headerlink" title="2. 平面运动"></a>2. 平面运动</h3><ol><li>角速度：$\boldsymbol{\omega}&#x3D;\frac{\mathbf{v}<em>B\cdot\boldsymbol{\rho}-\mathbf{v}<em>A\cdot\boldsymbol{\rho}}{r</em>{AB}}$，$\boldsymbol{\rho}$ 为 $\boldsymbol{\omega}</em>{AB}\times \mathbf{r}_{AB}$ 的单位方向矢量</li><li>速度：基点法（五个变量两个方程）、速度投影定理、瞬心法、点的运动学</li><li>加速度：基点法（五个变量两个方程）、加速度瞬心法、点的运动学，$\boldsymbol{\omega}\times(\boldsymbol{\omega}\times \mathbf{r})&#x3D;-\omega^2\mathbf{r}$</li></ol><h3 id="3-定点运动"><a href="#3-定点运动" class="headerlink" title="3. 定点运动"></a>3. 定点运动</h3><ol><li>瞬时转动轴：刚体或其<strong>延拓部分</strong>上两个瞬时速度为零的点</li><li>角加速度：角速度端点的速度，$\boldsymbol{\varepsilon}_A&#x3D;\boldsymbol{\omega}_C\times\boldsymbol{\omega}_A$</li><li>思路：找瞬时转轴 $\to$ 求角速度 $\to$ 求角加速度 $\to$ 求点的速度和加速度</li></ol><h2 id="三、复合运动"><a href="#三、复合运动" class="headerlink" title="三、复合运动"></a>三、复合运动</h2><h3 id="1-点的复合运动"><a href="#1-点的复合运动" class="headerlink" title="1. 点的复合运动"></a>1. 点的复合运动</h3><ol><li>绝对运动 $&#x3D;$ 相对运动 $+$ 牵连运动</li><li>速度：$\mathbf{v}&#x3D;\mathbf{v}_O+\boldsymbol{\omega}\times \mathbf{r}+\frac{\mathrm{d}\boldsymbol{\rho}}{\mathrm{d}t}&#x3D;\mathbf{v}_e+\mathbf{v}_r$</li><li>加速度： $\mathbf{a}&#x3D;\mathbf{a}_O+\boldsymbol{\varepsilon}\times \mathbf{r}+\boldsymbol{\omega}\times(\boldsymbol{\omega}\times \mathbf{r})+\frac{\mathrm{d}\mathbf{v}_r}{\mathrm{d}t}+2\boldsymbol{\omega}\times \mathbf{v}_r&#x3D;\mathbf{a}_e+\mathbf{a}_r+\mathbf{a}_c$</li><li>思路：动点动系选在<strong>不同刚体</strong>上；动点的<strong>相对轨迹</strong>简单</li></ol><h3 id="2-刚体复合运动"><a href="#2-刚体复合运动" class="headerlink" title="2. 刚体复合运动"></a>2. 刚体复合运动</h3><ol><li>刚体相对动系作<strong>定点运动</strong>，动系相对定系作<strong>定点运动</strong></li><li>角速度：$\boldsymbol{\omega}&#x3D;\boldsymbol{\omega}_e+\boldsymbol{\omega}_r$</li><li>角加速度：$\boldsymbol{\varepsilon}&#x3D;\boldsymbol{\varepsilon}_e+\boldsymbol{\varepsilon}_r+\boldsymbol{\omega}_e\times \boldsymbol{\omega}_r$</li></ol><h2 id="四、动力学基本概念"><a href="#四、动力学基本概念" class="headerlink" title="四、动力学基本概念"></a>四、动力学基本概念</h2><h3 id="1-微分方程"><a href="#1-微分方程" class="headerlink" title="1. 微分方程"></a>1. 微分方程</h3><ol><li>$F&#x3D;F(t)$：$\int_{t_0}^t F(t)\mathrm{d}t&#x3D;m\dot{x}-m\dot{x}_0$</li><li>$F&#x3D;F(v)$：$\int_{v_0}^v \frac{m}{F(v)}\mathrm{d}v&#x3D;t-t_0$</li><li>$F&#x3D;F(x)$：$\int_{x_0}^x F(x)\mathrm{d}x&#x3D;\frac{1}{2}m v^2-\frac{1}{2}m v_0^2$</li><li>二阶线性常微分方程：$y(x)&#x3D;c_1y_1(x)+c_2y_2(x)+y^*(x)$，互异实根 $y_1(x),y_2(x)&#x3D;e^{\lambda_1 x},e^{\lambda_2 x}$，重根 $y_1(x),y_2(x)&#x3D;e^{\lambda x},xe^{\lambda x}$，共轭复根 $y_1(x),y_2(x)&#x3D;e^{\alpha x}\cos \beta x,e^{\alpha x}\sin \beta x$，特解常数变易 $y^*(x)&#x3D;c_1(x)y_1(x)+c_2(x)y_2(x)$</li></ol><h3 id="2-非惯性系"><a href="#2-非惯性系" class="headerlink" title="2. 非惯性系"></a>2. 非惯性系</h3><ol><li>惯性力：牵连惯性力 $S_e&#x3D;-m\mathbf{a}_e$，科氏惯性力 $S_c&#x3D;-m\mathbf{a}_c$</li><li>相对运动微分方程：$m\mathbf{a}_r&#x3D;\mathbf{F}+\mathbf{S}_e+\mathbf{S}_c$</li></ol><h3 id="3-力系"><a href="#3-力系" class="headerlink" title="3. 力系"></a>3. 力系</h3><ol><li>主矢量：$\mathbf{R}&#x3D;\sum \mathbf{F}_i$</li><li>力对点的矩：$\mathbf{m}_O(\mathbf{F})&#x3D;\mathbf{r}\times \mathbf{F}$</li><li>力对轴的矩：$\mathbf{m}_z(\mathbf{F})&#x3D;\mathbf{m}_O(\mathbf{F})\cdot \hat{z}&#x3D;\mathbf{m}<em>O(\mathbf{F}</em>{xy})$，$O$ 为轴与垂直面交点</li><li>力系对点的主矩：$\mathbf{M}_O&#x3D;\sum \mathbf{m}_O(\mathbf{F}_i)$</li><li>不同矩心：$\mathbf{M}_P&#x3D;\mathbf{M}<em>O+\mathbf{R}\times \mathbf{r}</em>{OP}$</li></ol><h2 id="五、动力学普遍定理"><a href="#五、动力学普遍定理" class="headerlink" title="五、动力学普遍定理"></a>五、动力学普遍定理</h2><h3 id="1-动量定理"><a href="#1-动量定理" class="headerlink" title="1. 动量定理"></a>1. 动量定理</h3><ol><li>质系动量：$\mathbf{P}&#x3D;\sum m_i \mathbf{v}_i&#x3D;m\mathbf{v}_C$</li><li>质系动量定理：$\frac{\mathrm{d}\mathbf{P}}{\mathrm{d}t}&#x3D;\mathbf{R}^\text{外}&#x3D;m\mathbf{a}_C$（质心运动定理）</li><li>投影形式只适用于<strong>固定轴</strong></li></ol><h3 id="2-动量矩定理"><a href="#2-动量矩定理" class="headerlink" title="2. 动量矩定理"></a>2. 动量矩定理</h3><ol><li>质系对点的动量矩：$\mathbf{L}<em>A&#x3D;\sum \boldsymbol{\rho}</em>{i}\times m_i \mathbf{v}_{i}$</li><li>不同矩心：$\mathbf{L}_O&#x3D;\mathbf{L}<em>A+\mathbf{r}</em>{OA}\times m\mathbf{v}_C$</li><li>定点或质心：$\mathbf{L}<em>C&#x3D;\mathbf{L}</em>{Cr}&#x3D;\sum \boldsymbol{\rho}<em>i\times m_i \mathbf{v}</em>{ir}$</li><li>定轴转动：$\mathbf{L}_z&#x3D;J_z \boldsymbol{\omega}$，转动惯量 $J_z&#x3D;\sum m_i \rho_i^2&#x3D;m\rho_z^2$，$\rho_z$ 为物体对 $z$ 轴的回转半径</li><li>常用转动惯量<ol><li>均匀圆盘或圆柱：$J_C&#x3D;\frac{1}{2}mR^2$</li><li>均匀细杆：$J_C&#x3D;\frac{1}{12}mL^2$</li><li>球：$J_C&#x3D;\frac{2}{5}mR^2$</li></ol></li><li>质系对点的动量矩定理：$\frac{\mathrm{d}\mathbf{L}_A}{\mathrm{d}t}&#x3D;\mathbf{M}_A^{\text{外}}+m\mathbf{v}_C\times \mathbf{v}_A$</li><li>定点或质心：$\frac{\mathrm{d}\mathbf{L}_O}{\mathrm{d}t}&#x3D;\mathbf{M}_O^{\text{外}}$</li><li>定轴转动：$J_z\boldsymbol{\varepsilon}&#x3D;\mathbf{M}_z^{\text{外}}$</li><li>思路：应用<strong>质心运动定理</strong>和<strong>对质心的动量矩定理</strong></li></ol><h3 id="3-动能定理"><a href="#3-动能定理" class="headerlink" title="3. 动能定理"></a>3. 动能定理</h3><ol><li>质系动能：$T&#x3D;\frac{1}{2}\sum m_i v_i^2&#x3D;\frac{1}{2}m v_C^2+J_C\omega^2$（柯尼希定理）</li><li>元功：$\mathrm{d}^\prime A&#x3D;\mathbf{F}\cdot \mathrm{d}\mathbf{r}$ 或 $\mathbf{M}\mathrm{d}\theta$</li><li>质系动能定理：$\mathrm{d}T&#x3D;\sum \mathrm{d}^\prime A_i$，积分形式 $T_2-T_1&#x3D;A_{1\to 2}$</li></ol><h3 id="4-碰撞"><a href="#4-碰撞" class="headerlink" title="4. 碰撞"></a>4. 碰撞</h3><ol><li>有限形式动量定理：$\mathbf{P}_2-\mathbf{P}_1&#x3D;\sum \mathbf{I}_i^\text{外}$，<strong>外冲量和为零则动量守恒</strong></li><li>有限形式动量矩定理：$\mathbf{L}<em>{A2}-\mathbf{L}</em>{A1}&#x3D;\sum \mathbf{M}_A(\mathbf{I}_i^\text{外})$，<strong>外冲量矩和为零则动量矩守恒</strong></li><li>恢复系数：碰撞后法向相对速度与碰撞前法向相对速度之比</li><li>$\mathbf{u}<em>{1n}&#x3D;[(m_1-em_2)\mathbf{v}</em>{1n}+(1+e)m_2\mathbf{v}<em>{2n}]&#x2F;(m_1+m_2)$，$\mathbf{u}</em>{2n}&#x3D;[(m_2-em_1)\mathbf{v}<em>{2n}+(1+e)m_1\mathbf{v}</em>{1n}]&#x2F;(m_1+m_2)$</li><li>动能损失：$\Delta T&#x3D;\frac{1}{2}\frac{m_1 m_2}{m_1+m_2}(1-e^2)(\mathbf{v}<em>{1n}-\mathbf{v}</em>{2n})^2$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理</tag>
      
      <tag>大二上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机数学与统计</title>
    <link href="/25Fall/ProbStats/"/>
    <url>/25Fall/ProbStats/</url>
    
    <content type="html"><![CDATA[<p>大二上学期随机数学与统计的复习笔记，目前更新至极限定理。</p><span id="more"></span><h2 id="一、概率与概率空间"><a href="#一、概率与概率空间" class="headerlink" title="一、概率与概率空间"></a>一、概率与概率空间</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>样本空间、基本事件（样本点）：选取不唯一</li><li>事件：样本空间的子集（样本空间的子集不一定是事件，可能不可测）</li><li>随机试验：可重复性、不确定性</li><li>等可能概型：古典概型、几何概型（须可测）</li><li>小概率原则（单次几乎不发生，足够次一定发生）、实际推断原理（否定前提）</li></ol><h3 id="2-公理化定义"><a href="#2-公理化定义" class="headerlink" title="2. 公理化定义"></a>2. 公理化定义</h3><ol><li>事件域&#x2F;族&#x2F;体（$\sigma$-代数&#x2F;域）：$\Omega$ 的子集的集合，含全集、对补和可数并封闭</li><li>例：平凡、幂集、生成、$\mathrm{Borel}$ 事件域（实数上的开集生成）</li><li>概率（概率测度）：定义在事件域上的非负函数，$P(\Omega)&#x3D;1$、可数互斥可加</li><li>随机试验的概率空间：$(\Omega, \mathcal{F}, P)$</li><li>可数&#x2F;不可数：可&#x2F;不可指定单点概率、$\mathcal{F}&#x3D;&#x2F;\neq\mathcal{P}(\Omega)$</li></ol><h3 id="3-概率的性质"><a href="#3-概率的性质" class="headerlink" title="3. 概率的性质"></a>3. 概率的性质</h3><ol><li>事件序列的下极限：$\displaystyle\underline{\lim_{n\to\infty}} A_n&#x3D;\bigcup_{n&#x3D;1}^\infty \bigcap_{k&#x3D;n}^\infty A_k$</li><li>上极限：属于无穷多个；下极限：不属于有限个</li><li>$(\displaystyle\underline{\lim_{n\to\infty}} A_n)^C&#x3D;\displaystyle\overline{\lim_{n\to\infty}} A_n^C$</li><li>概率的下连续性：非减事件序列，$\displaystyle\lim_{n\to\infty} P(A_n)&#x3D;P\left(\bigcup_{n&#x3D;1}^\infty A_n\right)$</li><li>定理：有限可加性 $+$ 连续性 $\Leftrightarrow$ 可数可加性</li></ol><h3 id="4-独立性"><a href="#4-独立性" class="headerlink" title="4. 独立性"></a>4. 独立性</h3><ol><li>$A,B$ 独立，则 $A$ 与 $B^C$、$A^C$ 与 $B$、$A^C$ 与 $B^C$ 独立</li><li>多事件独立：任意 $k$ 个独立</li><li>极端事件与任意事件独立，非极端事件独立与互斥矛盾</li><li>独立性的实质：事件 $\sigma$-域 独立（将事件序列分成 $m$ 组，可推出性质一）</li><li>独立试验序列：任一试验的事件不依赖其他试验</li><li>$X,Y$ 独立，则 $f(X),g(Y)$ 独立</li></ol><h3 id="5-条件独立"><a href="#5-条件独立" class="headerlink" title="5. 条件独立"></a>5. 条件独立</h3><ol><li>定义：$P(AB|C)&#x3D;P(A|C)P(B|C)$</li><li>$A$ 与 $B$ 独立，$A$ 与 $C$ 独立，$A$ 与 $BC$ 不一定独立</li><li>$A$ 与 $B$ 独立，对任意的 $C$，$A$ 与 $B$ 不一定关于 $C$ 条件独立</li><li>若 $A$ 与 $B$ 关于 $C$ 条件独立，$A$ 与 $B$ 不一定关于 $C^C$ 条件独立</li><li>$\mathrm{Simpson}$ 悖论：$P(A|BC)&gt;P(A|B^CC),P(A|BC^C)&gt;P(A|B^CC^C)$，但 $P(A|B)\le P(A|B^C)$</li></ol><h3 id="6-事件的相关性"><a href="#6-事件的相关性" class="headerlink" title="6. 事件的相关性"></a>6. 事件的相关性</h3><ol><li>$r(A,B)&#x3D;\frac{P(AB)-P(A)P(B)}{\sqrt{P(A)(1-P(A))P(B)(1-P(B))}}$</li><li>$-1\le r \le 1$，$r&#x3D;1$ 当且仅当 $P(A)&#x3D;P(AB)&#x3D;P(B)$；$r&#x3D;-1$ 当且仅当 $P(A^C)&#x3D;P(A^CB)&#x3D;P(B)$</li></ol><h3 id="7-典型模型"><a href="#7-典型模型" class="headerlink" title="7. 典型模型"></a>7. 典型模型</h3><ol><li>等可能分析：无限硬币</li><li>概率的连续性：实数单点概率</li><li>首步分析法：赌徒输光</li><li>末步分析法：传球</li><li>样本空间缩减法：三门问题</li><li>期望效用理论：圣彼得堡悖论，$\displaystyle EU&#x3D;\sum_{i&#x3D;1}^\infty \frac{\ln(x+2^{n-1}-C)-\ln(x)}{2^n}&lt;+\infty$</li><li>随机变量的可加性：匹配数问题</li><li>可靠性问题</li></ol><h3 id="8-例题"><a href="#8-例题" class="headerlink" title="8. 例题"></a>8. 例题</h3><ol><li>已知 $P(AB)&#x3D;P(A)P(B),AB\subset C,A^CB^C\subset C^C$，求证 $P(AC)\ge P(A)P(C)$</li><li>从 $1,2,\cdots,N$ 中有放回地取 $n$ 个数，按大小排列为 $X_1\le X_2\le \cdots\le X_n$，求 $P(X_m&#x3D;M)$</li><li>从 $1,2,\cdots,N$ 中不放回地取 $n$ 个数，按大小排列为 $X_1\lt X_2\lt \cdots\lt X_n$，试证 $E(X_n)&#x3D;(N+1)\frac{n}{n+1}$</li><li>把 $r$ 个球随机地放到 $n$ 个盒子中，记 $X$ 表示空盒个数，求 $E(X)$</li><li>设随机变量 $X\sim B(n,p),Y&#x3D;\begin{cases} 1,&amp;X\text{ 为偶数} \\ -1,&amp;X\text{ 为奇数} \end{cases}$，求 $EY$</li><li>$X\sim B(n,p)$，求 $E\left(\frac{1}{1+X}\right)$</li><li>$X\sim \mathrm{Poisson}(\lambda)$，$B$ 为事件 $X$ 为偶数，求 $X$ 在 $B$ 下的条件分布</li><li>设随机变量 $X$ 在 $[a,b]$ 中取值，证明：$DX\le \frac{(b-a)^2}{4}$，并说明取等条件</li><li>三人同时投掷硬币，每人投掷出正面向上后停止，求进行的轮数的期望。</li></ol><h2 id="二、离散型随机变量与过程"><a href="#二、离散型随机变量与过程" class="headerlink" title="二、离散型随机变量与过程"></a>二、离散型随机变量与过程</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>随机变量：定义在随机试验样本空间上的单值实函数，且 $\forall x\in \mathbb{R}, \{\omega|X(\omega)\le x\}\in \mathcal{F}$</li><li>分布函数：$F(x)&#x3D;P(X\le x)$，右连续</li><li>矩母函数：$M_X(u)&#x3D;E(e^{uX})$，$E(X^n)&#x3D;M_X^{(n)}(0)$，独立时 $M_{X+Y}(u)&#x3D;M_X(u)M_Y(u)$</li></ol><h3 id="2-常见离散型分布"><a href="#2-常见离散型分布" class="headerlink" title="2. 常见离散型分布"></a>2. 常见离散型分布</h3><ol><li>二项分布：众数 $\lfloor (n+1)p\rfloor$ 或 $(n+1)p,(n+1)p-1$</li><li>超几何分布：二项分布逼近，方差 $\frac{N-n}{N-1}$ 倍</li><li>几何分布：无记忆性，方差 $\frac{1-p}{p^2}$</li></ol><h3 id="3-期望与中位数"><a href="#3-期望与中位数" class="headerlink" title="3. 期望与中位数"></a>3. 期望与中位数</h3><ol><li>期望：绝对收敛（可换序）</li><li>分位数：$P(X\le x)\ge p,P(X\ge x)\ge 1-p$，中位数 $\frac{1}{2}\le F(x)\le \frac{1}{2}+P(X&#x3D;x)$</li><li>$E|X-C|$ 在中位数处取最小值，$E(X-C)^2$ 在期望处取最小值 $DX$</li><li>期望的性质：可加；独立则可乘；$(E(XY))^2\le E(X^2)E(Y^2)$</li><li>$\mathrm{Markov}$ 不等式：非负随机变量，$P(X\gt c)\le \frac{EX}{c}$，对 $(X-EX)^2$ 使用则 $P(|X-EX|\ge c)\le \frac{DX}{c^2}$</li></ol><h3 id="4-随机向量"><a href="#4-随机向量" class="headerlink" title="4. 随机向量"></a>4. 随机向量</h3><ol><li>联合分布函数：$F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)\ge 0$</li><li>独立性：$p_{ij}&#x3D;f(x_i)g(y_j)$，则 $P(X&#x3D;x_i)&#x3D;C_1f(x_i),P(Y&#x3D;y_j)&#x3D;C_2g(y_j),C_1C_2&#x3D;1$</li><li>$k+l$ 阶混合中心矩：$E[(X-EX)^k(Y-EY)^l]$</li></ol><h3 id="5-方差与协方差"><a href="#5-方差与协方差" class="headerlink" title="5. 方差与协方差"></a>5. 方差与协方差</h3><ol><li>协方差：$\mathrm{Cov}(X,Y)&#x3D;E[(X-EX)(Y-EY)]&#x3D;E(XY)-EXEY$</li><li>独立则 $D(\sum a_iX_i)&#x3D;\sum a_i^2DX_i$，不独立则 $\displaystyle D(\sum a_iX_i)&#x3D;\sum a_i^2DX_i+2\sum_{i&lt;j}a_ia_j\mathrm{Cov}(X_i,X_j)$</li><li>相关系数：$r_{X,Y}&#x3D;\frac{\mathrm{Cov}(X,Y)}{\sqrt{DXDY}}$，不相关是独立的必要不充分条件，但两点分布下等价</li><li>最佳线性预测：$\hat{Y}&#x3D;aX+b$，$a&#x3D;\frac{\mathrm{Cov}(X,Y)}{DX},b&#x3D;EY-aEX,E(Y-\hat{Y})^2&#x3D;DY(1-r_{X,Y}^2)$</li><li>协方差的性质：对称性、双线性性 $\mathrm{Cov}(\sum a_iX_i, \sum b_jY_j)&#x3D;\sum a_ib_j\mathrm{Cov}(X_i,Y_j)$，协方差矩阵对称非负定</li><li>相关系数的性质：$r_{aX+b,cY+d}&#x3D;\frac{ac}{|ac|}r_{X,Y}$，$X^*&#x3D;\frac{X-EX}{\sqrt{DX}}$ 时 $r_{X,Y}&#x3D;r_{X^*,Y^*}$</li></ol><h3 id="6-条件分布与期望"><a href="#6-条件分布与期望" class="headerlink" title="6. 条件分布与期望"></a>6. 条件分布与期望</h3><ol><li>条件方差：$D(Y|X)&#x3D;E[(Y-E(Y|X))^2|X]&#x3D;E(Y^2|X)-(E(Y|X))^2$</li><li>$E(Y-g(X))^2&#x3D;E(Y-E(Y|X))^2+E(E(Y|X)-g(X))^2$ 始终成立</li><li>取 $g(X)&#x3D;E(Y|X)$ 得最佳预测，预测误差 $Y-E(Y|X)$ 与预测变量 $X$ 和预测值 $E(Y|X)$ 都不相关</li><li>取 $g(X)&#x3D;EY$ 得全方差公式 $DY&#x3D;E(D(Y|X))+D(E(Y|X))$，推论：$DY\ge D(E(Y|X))$，当且仅当 $Y&#x3D;E(Y|X)$ 时取等号</li><li>例：随机变量随机和 $EY&#x3D;ENEX_1,DY&#x3D;ENDX_1+DN(EX_1)^2$</li></ol><h3 id="7-随机过程与徘徊"><a href="#7-随机过程与徘徊" class="headerlink" title="7. 随机过程与徘徊"></a>7. 随机过程与徘徊</h3><ol><li>定义：依赖参数 $t$ 的随机变量族 $\{X(t),t\in T\}$，$T$ 为指标集</li><li>对基本事件 $\omega$，$\{X(t,\omega),t\in T\}$ 是定义在 $T$ 上的实函数，称为随机过程 $X$ 的一条样本轨道</li><li>有限维分布族：$F_{t_1,t_2,\cdots,t_n}(x_1,x_2,\cdots,x_n)&#x3D;P(X(t_1)\le x_1,X(t_2)\le x_2,\cdots,X(t_n)\le x_n)$</li><li>独立增量过程：互不相交的区间 $X_{m_1}-X_{n_1},X_{m_2}-X_{n_2},\cdots,X_{m_k}-X_{n_k}$ 独立；时齐：$X_{m+n}-X_{m}$ 对 $m$ 同分布</li><li>独立增量过程一定是 $\mathrm{Markov}$ 过程，有限维分布由其增量的分布和过程的初始分布唯一决定</li><li>随机徘徊：$S_n&#x3D;S_0+\sum_{i&#x3D;1}^n X_i$，$\{X_i\}$ 独立同分布于 $\begin{pmatrix} -1 &amp; 1 \\ 1-p &amp; p \end{pmatrix}$，$X_0$ 为任意整值随机变量，$p&#x3D;\frac{1}{2}$ 时称为一维对称简单随机徘徊</li><li>$\mathrm{Cov}(S_n,S_m)&#x3D;\min(n,m)DX_1$</li></ol><h2 id="三、-mathrm-Poisson-分布与过程"><a href="#三、-mathrm-Poisson-分布与过程" class="headerlink" title="三、$\mathrm{Poisson}$ 分布与过程"></a>三、$\mathrm{Poisson}$ 分布与过程</h2><h3 id="1-物理背景"><a href="#1-物理背景" class="headerlink" title="1. 物理背景"></a>1. 物理背景</h3><ol><li>时齐的独立增量过程，连续时间、离散状态空间</li><li>普通性：$P(N_{t+h}-N_t\ge 2)&#x3D;o(h),P(N_{t+h}-N_t&#x3D;1)&#x3D;\lambda h+o(h)$</li><li>$\mathrm{Poisson}$ 定理（二项分布逼近）：$\displaystyle X\sim B(n,p_n),\lim_{n\to\infty} np_n&#x3D;\lambda$，则 $P(X&#x3D;k)\rightarrow e^{-\lambda}\frac{\lambda^k}{k!}$</li></ol><h3 id="2-mathrm-Poisson-分布"><a href="#2-mathrm-Poisson-分布" class="headerlink" title="2. $\mathrm{Poisson}$ 分布"></a>2. $\mathrm{Poisson}$ 分布</h3><ol><li>$P(X&#x3D;k)&#x3D;e^{-\lambda}\frac{\lambda^k}{k!},k&#x3D;0,1,2,\cdots$</li><li>$EX&#x3D;DX&#x3D;\lambda,M_X(u)&#x3D;e^{\lambda(e^u-1)}$</li><li>合&#x2F;分流：可加性、随机选择下的不变性</li></ol><h3 id="3-mathrm-Poisson-过程"><a href="#3-mathrm-Poisson-过程" class="headerlink" title="3. $\mathrm{Poisson}$ 过程"></a>3. $\mathrm{Poisson}$ 过程</h3><ol><li>定义：$N_0&#x3D;0$，独立增量，$N_{t+h}-N_t\sim \mathrm{Poisson}(\lambda h)$</li><li>分流选择：$\{X_t\},\{Y_t\}$ 强度分别为 $\lambda_1,\lambda_2$ 的独立 $\mathrm{Poisson}$ 过程，则 $Y_t|X_t+Y_t&#x3D;n\sim B\left(n,\frac{\lambda_2}{\lambda_1+\lambda_2}\right)$</li><li>时间选择：$X_u|X_t&#x3D;n\sim B\left(n,\frac{u}{t}\right)$</li></ol><h3 id="4-复合-mathrm-Poisson-过程"><a href="#4-复合-mathrm-Poisson-过程" class="headerlink" title="4. 复合 $\mathrm{Poisson}$ 过程"></a>4. 复合 $\mathrm{Poisson}$ 过程</h3><ol><li>定义：$\displaystyle Y_t&#x3D;\sum_{i&#x3D;1}^{N_t} X_i$，$\{X_i\}$ 独立同分布且与 $\{N_t\}$ 独立，是时齐的独立增量过程</li><li>$EY_t&#x3D;\lambda t EX_1,DY_t&#x3D;\lambda t E(X_1^2),M_{Y_t}(u)&#x3D;e^{\lambda t[M_{X_1}(u)-1]}$</li></ol><h2 id="四、连续型随机变量"><a href="#四、连续型随机变量" class="headerlink" title="四、连续型随机变量"></a>四、连续型随机变量</h2><h2 id="五、-mathrm-Gauss-分布与-mathrm-Brown-运动"><a href="#五、-mathrm-Gauss-分布与-mathrm-Brown-运动" class="headerlink" title="五、$\mathrm{Gauss}$ 分布与 $\mathrm{Brown}$ 运动"></a>五、$\mathrm{Gauss}$ 分布与 $\mathrm{Brown}$ 运动</h2><h3 id="1-留数定理"><a href="#1-留数定理" class="headerlink" title="1. 留数定理"></a>1. 留数定理</h3><ol><li>留数的计算：$\displaystyle\mathrm{Res}(f,z_0)&#x3D;\frac{1}{(m-1)!}\lim_{z\to z_0}\frac{\mathrm{d}^{m-1}}{\mathrm{d}z^{m-1}}\left[(z-z_0)^mf(z)\right]$</li><li><strong>实函数</strong>无穷积分：上半平面 $|z|\to\infty$ 时 $zf(z)\to 0$，则 $\displaystyle\int_{-\infty}^{+\infty} f(x)dx&#x3D;2\pi i\sum \mathrm{Res}f(z)$</li><li>$\mathrm{Jordan}$ 引理（上半）：若 $p\gt 0$，且上半平面 $|z|\to\infty$ 时 $Q(z)\to 0$，则 $\displaystyle\int_{-\infty}^{+\infty}Q(z)e^{ipz}dz&#x3D;2\pi i\sum \mathrm{Res}[Q(z)e^{ipz}]$</li><li>$\mathrm{Jordan}$ 引理（下半）：若 $p\lt 0$，且下半平面 $|z|\to\infty$ 时 $Q(z)\to 0$，则 $\displaystyle\int_{-\infty}^{+\infty}Q(z)e^{ipz}dz&#x3D;-2\pi i\sum \mathrm{Res}[Q(z)e^{ipz}]$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大二上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理B(2)</title>
    <link href="/25Fall/Physics-B2/"/>
    <url>/25Fall/Physics-B2/</url>
    
    <content type="html"><![CDATA[<p>大二上学期大学物理B(2)的复习笔记，目前更新至光学。</p><span id="more"></span><h2 id="四、电磁学"><a href="#四、电磁学" class="headerlink" title="四、电磁学"></a>四、电磁学</h2><h3 id="1-静电场"><a href="#1-静电场" class="headerlink" title="1. 静电场"></a>1. 静电场</h3><ol><li>电偶极矩 $\vec{p}&#x3D;q\vec{l}$，从负电荷指向正电荷</li><li>均匀带电直线：$E_x&#x3D;\frac{\lambda}{4\pi \varepsilon_0a}(\sin\theta_2-\sin\theta_1),E_y&#x3D;\frac{\lambda}{4\pi \varepsilon_0a}(\cos\theta_1-\cos\theta_2)$</li><li>无限大均匀带电平面：$E&#x3D;\frac{\sigma}{2\varepsilon_0}$</li><li>高斯定理：$\oiint \vec{E}\cdot \mathrm{d}\vec{S}&#x3D;\frac{1}{\varepsilon_0}\sum q_{\text{内}}$，适用于任何静电场（电介质的 $q$ 包括极化电荷）</li><li>静电场环路定理：$\oint \vec{E}\cdot \mathrm{d}\vec{l}&#x3D;0$</li></ol><h3 id="2-电势"><a href="#2-电势" class="headerlink" title="2. 电势"></a>2. 电势</h3><ol><li>电荷系静电能：$W&#x3D;\frac{1}{2}\sum q_i\phi_i,\phi_i$ 为其他电荷在 $q_i$ 处产生的电势</li><li>连续分布：$W&#x3D;\frac{1}{2}\int\mathrm{d}q\phi$，$\phi$ 为所有电荷在 $\mathrm{d}q$ 处产生的电势</li></ol><h3 id="3-导体"><a href="#3-导体" class="headerlink" title="3. 导体"></a>3. 导体</h3><ol><li>静电平衡条件：内部无场无电荷等势（包括连接处），表面等势，场强垂直于表面</li><li>空腔导体可屏蔽外电场</li><li>电荷分布：内部无静电荷，与曲率正相关，可用点像法模拟</li><li>接地：电势为零（不一定无电荷）</li></ol><h3 id="4-电介质"><a href="#4-电介质" class="headerlink" title="4. 电介质"></a>4. 电介质</h3><ol><li>电极化强度：$\vec{P}&#x3D;\frac{\sum\vec{p}}{\Delta V}&#x3D;n\vec{p}&#x3D;\varepsilon_0(\varepsilon_r-1)\vec{E}$</li><li>面极化电荷密度：$\sigma&#x3D;\vec{P}\cdot \hat{n}$，$q_{\text{外}}^\prime&#x3D;-q_{\text{内}}^\prime&#x3D;\oiint \vec{P}\cdot \mathrm{d}\vec{S}$</li><li>电位移矢量：$\vec{D}&#x3D;\varepsilon_0\vec{E}+\vec{P}&#x3D;\varepsilon_0\varepsilon_r\vec{E}$</li><li>电介质高斯定理：$\oiint \vec{D}\cdot \mathrm{d}\vec{S}&#x3D;\sum q_{\text{0内}}$</li><li>静电场边值关系：电位移法向连续，场强切向连续，$\frac{\tan\theta_1}{\tan\theta_2}&#x3D;\frac{\varepsilon_{r1}}{\varepsilon_{r2}}$</li><li>电容器能量 $W&#x3D;\frac{1}{2}CU^2$</li><li>电场能量密度 $w&#x3D;\frac{1}{2}\varepsilon E^2,W&#x3D;\iiint w\mathrm{d}V$</li></ol><h3 id="5-恒定电流"><a href="#5-恒定电流" class="headerlink" title="5. 恒定电流"></a>5. 恒定电流</h3><ol><li>电流：$I&#x3D;\frac{\mathrm{d}q}{\mathrm{d}t}$，电流密度：$\vec{J}&#x3D;\frac{\mathrm{d}I}{\mathrm{d}\vec{S}}$</li><li>恒定电流：$\oiint \vec{J}\cdot \mathrm{d}\vec{S}&#x3D;-\frac{\mathrm{d}q_{\text{内}}}{\mathrm{d}t}&#x3D;0$，$\sum I_i&#x3D;0$</li><li><strong>恒定电场：电荷分布不随时间改变，满足高斯定理、环路定理，但导体静电不平衡、需要能量维持</strong></li><li>电阻率：$\rho&#x3D;\rho_0(1+\alpha t)$</li><li>电导率：$\sigma&#x3D;\frac{1}{\rho},\vec{J}&#x3D;\sigma \vec{E}$</li><li>$-\sum(\pm)\varepsilon+\sum(\pm) IR&#x3D;0$，电动势从负到正；$I$ 与回路绕向一致取正</li><li>$\sigma&#x3D;\frac{ne^2\tau}{m}$，$\tau$ 为两次碰撞间的平均时间</li><li>焦耳定律：$p&#x3D;\sigma E^2$，$p$ 为电流热功率密度（单位时间体积内能）</li></ol><h3 id="6-磁场"><a href="#6-磁场" class="headerlink" title="6. 磁场"></a>6. 磁场</h3><ol><li>$\vec{E},\vec{D}$ 为极矢量（垂直反转，镜像面上平行），$\vec{B},\vec{H}$ 为轴矢量（平行反转，镜像面上垂直）</li><li>洛伦兹力：$\vec{F}&#x3D;q\vec{v}\times \vec{B}$</li><li>电流元磁场：$\mathrm{d}\vec{B}&#x3D;\frac{\mu_0}{4\pi}\frac{I\mathrm{d}\vec{l}\times \hat{r}}{r^2}$</li><li>载流直导线：$B&#x3D;\frac{\mu_0 I}{4\pi a}(\cos\phi_1-\cos\phi_2)$</li><li>螺线管：$B&#x3D;\frac{1}{2}\mu_0 n I(\cos\phi_2-\cos\phi_1)$</li><li>无限大均匀载流平面：$B&#x3D;\frac{\mu_0}{2}j$，$j$：面电流密度</li><li>磁偶极子：载有电流的小线圈，磁矩 $\vec{p}&#x3D;I\vec{S}$</li><li>高斯定理：$\oiint \vec{B}\cdot \mathrm{d}\vec{S}&#x3D;0$，磁通量仅由公共边界线决定，可定义磁矢势 $\oint \vec{A}\cdot \mathrm{d}\vec{l}&#x3D;\oiint \vec{B}\cdot \mathrm{d}\vec{S}$</li><li>安培环路定理：$\oint \vec{B}\cdot \mathrm{d}\vec{l}&#x3D;\mu_0 \sum I_{\text{内}}$，$I_{\text{内}}$：与 $L$ 套连，与 $L$ 绕行方向右手螺旋取正</li></ol><h3 id="7-磁力"><a href="#7-磁力" class="headerlink" title="7. 磁力"></a>7. 磁力</h3><ol><li>安培力：$\mathrm{d}\vec{F}&#x3D;I\mathrm{d}\vec{l}\times \vec{B}$</li><li>磁矩力矩：$\vec{M}&#x3D;\vec{m}\times \vec{B}$，可定义势能零点：$\vec{m}\perp \vec{B}$</li><li>磁矩在非均匀磁场中受力：$\vec{F}&#x3D;\vec{m}\cdot \nabla\vec{B}$</li></ol><h3 id="8-磁介质"><a href="#8-磁介质" class="headerlink" title="8. 磁介质"></a>8. 磁介质</h3><ol><li>磁化强度：$\vec{M}&#x3D;\frac{\sum \vec{m}}{\Delta V}&#x3D;n\vec{m}$</li><li>磁化电流：$I^\prime&#x3D;\int\vec{M}\cdot \mathrm{d}\vec{l}$</li><li>面磁化电流密度：$j^\prime&#x3D;\frac{\mathrm{d}I^\prime}{\mathrm{d}l}&#x3D;\vec{M}\times \hat{n}$</li><li><strong>磁化电流没有热效应，磁效应与传导电流相同</strong></li><li>磁场强度：$\vec{H}&#x3D;\frac{1}{\mu_0}\vec{B}-\vec{M}&#x3D;\frac{1}{\mu_0\mu_r}\vec{B}$（顺抗磁质）</li><li>磁介质环路定理：$\oint \vec{H}\cdot \mathrm{d}\vec{l}&#x3D;\sum I_{\text{0内}}$</li><li>磁场的边值关系：磁场强度切向连续，磁感应强度法向连续，$\frac{\tan\theta_1}{\tan\theta_2}&#x3D;\frac{\mu_{r1}}{\mu_{r2}}$</li><li>磁路定理：$\varepsilon_m&#x3D;NI&#x3D;\Phi_m\sum R_{mi}&#x3D;\Phi_m\sum \frac{l_i}{\mu_0\mu_{ri} S_i}$</li></ol><h3 id="9-电磁感应"><a href="#9-电磁感应" class="headerlink" title="9. 电磁感应"></a>9. 电磁感应</h3><ol><li>动生电动势：$\mathrm{d}\varepsilon&#x3D;(\vec{v}\times \vec{B})\cdot \mathrm{d}\vec{l}$</li><li>感生电动势：$\varepsilon&#x3D;\oint \vec{E}\cdot \mathrm{d}\vec{l}&#x3D;-\frac{\partial}{\partial t}\oiint \vec{B}\cdot \mathrm{d}\vec{S}$</li><li><strong>感生电场：非保守，电场线闭合，无源有旋</strong></li><li>自感系数：$L&#x3D;\frac{\Psi}{I}&#x3D;-\frac{\varepsilon}{\mathrm{d}I&#x2F;\mathrm{d}t}$</li><li>互感系数：$M_{12}&#x3D;M_{21}&#x3D;\frac{\Psi_{21}}{I_1}\ge 0$</li><li>顺串接 $L&#x3D;L_1+L_2+2M$，逆串接 $L&#x3D;L_1+L_2-2M$</li><li>磁能：$W&#x3D;\frac{1}{2}LI^2$</li><li>磁能密度：$w_m&#x3D;\frac{B^2}{2\mu},W&#x3D;\iiint w_m\mathrm{d}V$</li></ol><h3 id="10-mathrm-Maxwell-方程组"><a href="#10-mathrm-Maxwell-方程组" class="headerlink" title="10. $\mathrm{Maxwell}$ 方程组"></a>10. $\mathrm{Maxwell}$ 方程组</h3><ol><li>位移电流：$I_D&#x3D;\frac{\partial}{\partial t}\Phi_D&#x3D;\frac{\partial}{\partial t}\iint \vec{D}\cdot \mathrm{d}\vec{S}$</li><li><strong>位移电流没有热效应，磁效应与传导电流相同</strong></li><li>推广安培环路定理：$\oint \vec{H}\cdot \mathrm{d}\vec{l}&#x3D;\sum I_{\text{0内}}+I_D$</li><li>$\mathrm{Maxwell}$ 方程组：电磁场高斯定理、法拉第电磁感应定律、推广安培环路定理</li><li>电磁波波速：$u&#x3D;\frac{1}{\sqrt{\mu\varepsilon}}&#x3D;\frac{c}{n},n&#x3D;\sqrt{\mu_r\varepsilon_r}\approx \sqrt{\varepsilon_r}$</li><li>$\vec{E},\vec{H},\vec{u}$ 右手螺旋，$\sqrt{\varepsilon}E&#x3D;\sqrt{\mu}H$</li><li>能量密度：$w&#x3D;\frac{1}{2}(\varepsilon E^2+\mu H^2)$</li><li>能流密度 $\vec{S}$：单位时间通过单位面积能量</li><li>动量密度 $\vec{g}$：$E&#x3D;pc$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理</tag>
      
      <tag>大二上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第九讲 人工智能初步（下）</title>
    <link href="/43Class/43Class-9/"/>
    <url>/43Class/43Class-9/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第九讲，介绍了大模型的前沿技术：强化学习、多模态和具身智能。</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第八讲 人工智能初步（上）</title>
    <link href="/43Class/43Class-8/"/>
    <url>/43Class/43Class-8/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第八讲，介绍了机器学习和深度学习的基础知识。</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第七讲 从 Huffman 树到信息论</title>
    <link href="/43Class/43Class-7/"/>
    <url>/43Class/43Class-7/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第七讲，介绍了信息论、编码理论和 $\mathrm{Huffman}$ 编码。</p><span id="more"></span><p>笃实 43 班的同学们大家好。</p><p>本学期《肆叁小灶》将预计更新 3-4 期：本期我们将从《数据结构》课中介绍的 $\mathrm{Huffman}$ 树出发，讲解其背后的理论基础——编码理论与信息论；之后，我们将用 2-3 期的篇幅带大家从零开始了解人工智能技术，直至学术前沿。希望同学们能通过本学期的《肆叁小灶》系列推送，对人工智能有一个初步的认识，为下学期的《人工智能基础》课程做好准备。</p><p>废话不多说，让我们直接进入正题。</p><h2 id="一、-mathrm-Huffman-编码"><a href="#一、-mathrm-Huffman-编码" class="headerlink" title="一、$\mathrm{Huffman}$ 编码"></a>一、$\mathrm{Huffman}$ 编码</h2><p>在《数据结构》课上，提到了 $\mathrm{Huffman}$ 树是“最优编码树”，但并没有给出具体的证明过程。事实上，由 $\mathrm{Huffman}$ 树构造而来的 $\mathrm{Huffman}$ 编码不仅是<strong>前缀码</strong>中最优的，也是所有<strong>唯一可译码</strong>中最优的；而在实际应用中，非唯一可译码并没有什么意义（因为它可能导致歧义），因此 $\mathrm{Huffman}$ 编码可以说是所有编码中最优的。</p><blockquote><p>“唯一可译码”和“前缀码”并不等价。例如将符号集 ${A, B, C, D}$ 编码为 ${10, 00, 11, 110}$，这个编码并不是前缀码（因为 $11$ 是 $110$ 的前缀），但它是唯一可译的。为了区分 $C$ 和 $D$，我们只需要等待下一个 $1$ 出现：如果中间的 $0$ 的数量是偶数，我们解码 $11$，否则我们解码 $110$。</p></blockquote><p>也正因此，$\mathrm{Huffman}$ 编码在数据压缩领域有着极其广泛的应用。下面，就让我们一步步来证明 $\mathrm{Huffman}$ 编码的最优性。</p><h3 id="1-1-最优前缀码"><a href="#1-1-最优前缀码" class="headerlink" title="1.1 最优前缀码"></a>1.1 最优前缀码</h3><p>首先，如果将 $01$ 编码视为一个二叉树，那么在前缀码所对应的二叉树中，码字一定对应于这棵树的叶节点。</p><p>这是因为，如果存在码字的对应节点不是叶节点，那么一定存在另一个码字的对应节点是这个节点的后代，也即这两个码字的对应节点在同一条路径上——这意味着前者是后者的前缀，而这与前缀码的定义相矛盾。</p><p>所以，给定一组符号及其频率，如果我们将每个符号与其频率视作一个带权的节点，那么最小化平均码长的问题就转化为：构造一个以上面这些带权节点为叶节点的二叉树，使得所有叶节点的加权路径长度之和最小。</p><p>接下来，我们可以注意到两个最优前缀码所必须的性质：</p><ol><li>根据排序不等式，概率更大的符号应该具有更小的码长，即概率的排序应与码长的排序恰好相反；</li><li>其对应的二叉树不可能存在只有一个子节点的中间节点，否则可以将其子节点直接提升为其父节点的子节点，从而降低总权值。</li></ol><p>上面的两个性质就可以导出一个结论：存在一个最优的前缀码，使得两个最不可能的码字仅在最后一位不同，即两个最不可能的码字是兄弟。这是因为：</p><ol><li>这两个码字必须拥有同样且最大的码长（如果不是最大，则与上面的第一个性质矛盾；如果不相同，则只有一个码字拥有最大的码长，这说明这个码字在树上的父节点只有一个子节点，而这与上面的第二个性质矛盾）；</li><li>如果它们没有相同的父节点，这意味着一定存在第三个拥有相同码长的码字（因为不存在只有一个子节点的中间节点），故可以将这两个码字与第三个码字交换，从而使得它们成为兄弟。</li></ol><p>这也就是说，让这两个最不可能的码字成为兄弟不影响整体的最优性，那我们就不妨让它们成为兄弟。这样一来，我们就可以将它们合并为一个新的符号，其频率为这两个码字的频率之和：这是因为，只要获得了这个新符号的最优前缀码，我们只需要通过在其码字后分别添加 $0$ 和 $1$，就可以获得原来两个码字的最优前缀码。如此，我们就把问题的规模从 $n$ 降低到了 $n-1$。然后，我们就可以通过反复的合并操作，最终将问题简化为只有两个符号的情况，而这时显然只存在唯一且最优的前缀码：$0$ 和 $1$。</p><h3 id="1-2-前缀码与唯一可译码"><a href="#1-2-前缀码与唯一可译码" class="headerlink" title="1.2 前缀码与唯一可译码"></a>1.2 前缀码与唯一可译码</h3><p>前面提到，唯一可译码和前缀码并不等价。但显然，前缀码一定是唯一可译的，而且是“即时可译”的：也就是说，在接收到一个码字流时，我们可以从左到右逐位读取码字，并且一旦读到一个完整的码字，就可以立即将其译码，而不需要等待后续的码字。而非前缀的唯一可译码则可能不具备这个性质，就比如前面提到的例子。</p><p>那么自然会有一个问题：是否有可能存在非前缀的唯一可译码，其平均码长小于所有前缀码的平均码长？如果能够证明其不存在，那么 $\mathrm{Huffman}$ 编码的最优性就可以推广到所有唯一可译码。事实上，这就是信息论中著名的 $\mathrm{McMillan}$ 定理。</p><p>首先，容易证明：存在一个码字长度为 $l_1,l_2,\cdots,l_n$ 的前缀码当且仅当 $\displaystyle \sum_{i&#x3D;1}^n 2^{-l_i}\leq 1$。这是因为，如果给深度为 $l$ 的叶节点分配权值 $2^{-l}$，那么一个真二叉树中所有叶节点的权值之和为 $1$；而前缀码一定对应于一棵二叉树的叶节点，也即一个真二叉树叶节点的子集。我们称这个不等式为 <strong>$\mathrm{Kraft}$ 不等式</strong>。</p><p>接下来，如果我们能够证明所有唯一可译码都满足 $\mathrm{Kraft}$ 不等式，那么就说明对于任意唯一可译码，我们都可以找到一个前缀码，其码字长度与该唯一可译码相同，而这也就意味着该前缀码的平均码长与该唯一可译码相同。</p><p>假设某个随机消息有 $r$ 个可能的值 $u\in U$（这里集合 $U$ 表示消息字母表）。我们为这个随机消息设计一个唯一可译码，它为每个可能的符号 $u\in U$ 分配一个长度为 $l(u)$ 的码字，设 $l(u)$ 的最大值为 $l_{\max}$。接下来我们考虑 $\displaystyle\left(\sum_{u\in U}2^{-l(u)}\right)^v$，其中 $v$ 为正整数。容易发现，这等价于 $\displaystyle \sum_{u_1\in U}\sum_{u_2\in U}\cdots\sum_{u_v\in U}2^{-(l(u_1)+l(u_2)+\cdots+l(u_v))}&#x3D;\sum_{w\in U^v}2^{-l(w)}$，其中 $w$ 表示长度为 $v$ 的消息序列，$l(w)$ 表示该消息序列的码字长度。</p><p>接着，我们把 $U^v$ 中所有码字长度相同的消息序列合在一起。显然长度为 $v$ 的消息序列的码字长度不可能超过 $vl_{\max}$，因此我们可以把上面的求和写成 $\displaystyle \sum_{t&#x3D;1}^{vl_{\max}}w(t)2^{-t}$，其中 $w(t)$ 表示码字长度为 $t$ 的消息序列的数量。又由于我们使用的是唯一可译码，所以消息序列必然也是唯一可译的，这要求码字长度为 $t$ 的消息序列的数量不能超过 $2^t$，否则就会出现码字冲突。因此，我们有 $w(t)\leq 2^t$，从而 $\displaystyle \sum_{t&#x3D;1}^{vl_{\max}}w(t)2^{-t}\leq \sum_{t&#x3D;1}^{vl_{\max}}2^t2^{-t}&#x3D;vl_{\max}$，也即 $\sum_{u\in U}2^{-l(u)}\leq (vl_{\max})^{\frac{1}{v}}$。</p><p>由于上式对任意正整数 $v$ 都成立，我们令 $v\to +\infty$，就得到 $\displaystyle \sum_{u\in U}2^{-l(u)}\leq 1$，而这正是 $\mathrm{Kraft}$ 不等式。这样，我们就完成了 $\mathrm{McMillan}$ 定理的证明，从而证明了 $\mathrm{Huffman}$ 编码在所有唯一可译码中的最优性。</p><h2 id="二、平均码长的理论下界"><a href="#二、平均码长的理论下界" class="headerlink" title="二、平均码长的理论下界"></a>二、平均码长的理论下界</h2><p>想必大家都听说过这样一个轶闻：苏联曾试图研究三进制计算机，因为理论上最高效的进制是 $e$ 进制，但现实中进制只能取整数，因此二进制和三进制就成了妥协。</p><p>那么类似地，在编码领域，$\mathrm{Huffman}$ 编码是否也只是“码长只能取整数”的一种妥协？如果我们允许码长取非整数值，是否能够获得更优的编码？如果是，这种非整数码长编码的平均码长是可以任意小，还是存在某个理论下界？而这就是信息论中的另一个重要结论：大名鼎鼎的<strong>信息熵</strong>。</p><h3 id="2-1-信息量的度量"><a href="#2-1-信息量的度量" class="headerlink" title="2.1 信息量的度量"></a>2.1 信息量的度量</h3><p>首先：什么是信息？让我们看一个例子：</p><p>你观察一个赌徒抛一个公平的硬币，然后告诉你的朋友。通过这样做，你给了你的朋友一定量的信息。接着，你继续观察他掷一个公平的骰子，然后告诉你的朋友。通过这样做，你又给了你的朋友一定量的信息。</p><p>现在的问题是：这两次你给朋友的信息量一样多吗？</p><p>显然，后者包含的信息量要大于前者。这是因为，前者只可能有两种回答：正或反，而后者则有 $6$ 种可能。从中我们可以看出，信息量的大小应该与可能的答案数量 $r$ 正相关。</p><p>让我们继续上面的例子：接下来，你观察赌徒掷骰子三次。同样，你记录下三次的结果并告诉你的朋友。</p><p>显然，这次你给朋友的信息量是前一次的三倍。从中我们可以看出，“信息”在某种程度上应该是可加的。</p><p>但现在我们面临一个新问题：以上面赌徒的例子为例，后者可能的答案数量是前者的 $36$ 倍，但我们希望信息量只是三倍的关系。于是，我们自然会想到，信息量应该与可能的答案数量的<strong>对数</strong>成正比。</p><p>但如果每个答案发生的概率并不相同呢？显然，如果一个事件几乎必然发生，那么它发生时所包含的信息量就应该很小；反之，如果一个事件几乎不可能发生，那么它发生时所包含的信息量就应该很大。</p><p>定量地说，假设有一枚神秘的四面体骰子，其中某一面朝下的概率为 $\frac{1}{2}$，其余三面朝下的概率均为 $\frac{1}{6}$。那么，当你告诉朋友 $\frac{1}{2}$ 面朝下时，所包含的信息量其实就相当于一个公平硬币的投掷结果。</p><p>可见，我们可以通过对概率取<strong>倒数</strong>把非等可能事件转化为等可能事件；接着，根据上面的分析，我们就可以对其取对数，从而得到信息量的度量。也就是说，信息量应该与概率的<strong>负对数</strong>成正比。</p><p>形式化地，我们考虑一个随机变量 $X$，它有 $n$ 个可能的取值 $x_1,x_2,\cdots,x_n$，对应的概率分别为 $p(x_1),p(x_2),\cdots,p(x_n)$。那么，当 $x_i$ 发生时，所包含的信息量可以定义为：$I(x_i)&#x3D;\log\left(\frac{1}{p(x_i)}\right)$。接着，再对所有可能的取值求期望，我们就得到了这个随机变量的信息量的度量：$\displaystyle H(X)&#x3D;\mathbb E[I(X)]&#x3D;\sum_{i&#x3D;1}^n p(x_i)I(x_i)&#x3D;-\sum_{i&#x3D;1}^n p(x_i)\log p(x_i)$，这就被称为<strong>信息熵</strong>。</p><p>对数的底数可以取任意值（不同的底数等价于一个常数因子），在信息论中通常取 $2$，因为这样我们就可以直接使用<strong>比特</strong>来作为信息熵的单位了。</p><h3 id="2-2-信源编码定理"><a href="#2-2-信源编码定理" class="headerlink" title="2.2 信源编码定理"></a>2.2 信源编码定理</h3><p>有了信息熵的概念，平均码长存在理论下界就是显而易见的了：</p><p>我们将原始符号集 $U$ 中的每个符号 $u$ 视作一个随机变量 $X$ 的取值，其概率为 $p(u)$。那么，一单位的 $X$ 所包含的信息量就是 $H(X)$；而一单位的 $01$ 码最多只能携带 $1$ 比特的信息量（当且仅当 $01$ 等概率时，这可以通过简单的计算来验证），因此要传输 $H(X)$ 比特的信息量，至少需要 $H(X)$ 单位的码字长度。</p><p>这就是著名的 <strong>$\mathrm{Shannon}$ 第一定理</strong>，又称<strong>信源编码定理</strong>。它告诉我们，任何编码的平均码长都不能小于信息熵 $H(X)$，取等的一个必要条件是 $01$ 码等概率出现。</p><h2 id="三、通信误差"><a href="#三、通信误差" class="headerlink" title="三、通信误差"></a>三、通信误差</h2><p>然而，在现实中，由于信道噪声的存在，传输过程中往往会出现误码现象。形式化地，假设信源给出的是随机变量 $X$，接收端接收到的是随机变量 $Y$，则转移概率矩阵 $P_{Y|X}(y_j|x_i)$ 并不一定是单位矩阵。</p><h3 id="3-1-条件熵、联合熵与互信息"><a href="#3-1-条件熵、联合熵与互信息" class="headerlink" title="3.1 条件熵、联合熵与互信息"></a>3.1 条件熵、联合熵与互信息</h3><p>在概率论课程中，我们学习过条件分布和条件期望的概念。类似地，在信息论中，我们也可以定义<strong>条件熵</strong>：$\displaystyle H(Y|X&#x3D;x_i)&#x3D;-\sum_j P_{Y|X}(y_j|x_i)\log P_{Y|X}(y_j|x_i)$ 表示在已知 $X&#x3D;x_i$ 的条件下，$Y$ 的不确定性；再对所有可能的 $x_i$ 求期望，我们就得到了条件熵：$\displaystyle H(Y|X)&#x3D;\sum_i P_X(x_i)H(Y|X&#x3D;x_i)&#x3D;-\sum_{i}\sum_{j}P_{X,Y}(x_i,y_j)\log P_{Y|X}(y_j|x_i)$。</p><p>条件熵衡量了信道引入的不确定性。不难发现：在无损信道中转移概率矩阵 $P_{Y|X}(y_j|x_i)$ 是单位矩阵，条件熵 $H(Y|X)&#x3D;0$；而在完全噪声信道中（即接收到的信号与发送的信号独立），$P_{Y|X}(y_j|x_i)&#x3D;P_Y(y_j)$，条件熵 $H(Y|X)&#x3D;H(Y)$。</p><p>将信源本身的不确定性和信道引入的不确定性相加，我们就得到了<strong>联合熵</strong>：$\displaystyle H(X,Y)&#x3D;H(X)+H(Y|X)&#x3D;-\sum_{i}\sum_{j}P_{X,Y}(x_i,y_j)\log P_{X,Y}(x_i,y_j)$。联合熵衡量了信源和信道整个系统的总不确定性。</p><p>我们还可以定义<strong>互信息</strong>：$\displaystyle I(X;Y)&#x3D;H(X)-H(X|Y)&#x3D;\sum_{i}\sum_{j}P_{X,Y}(x_i,y_j)\log\left(\frac{P_{X,Y}(x_i,y_j)}{P_X(x_i)P_Y(y_j)}\right)$。互信息衡量了接收到 $Y$ 后对 $X$ 的不确定性减少了多少。</p><p>互信息有两个极端情况：当信道无损时，接收到 $Y$ 后 $X$ 的不确定性完全消失，因此 $I(X;Y)&#x3D;H(X)$；而当 $X$ 和 $Y$ 独立时，接收到 $Y$ 后对 $X$ 的不确定性没有任何减少，因此 $I(X;Y)&#x3D;0$。</p><p>下面这张图可以帮助大家理解这些概念之间的关系：</p><p><img src="/img/43Class-7/1.png"></p><h3 id="3-2-信道容量与信道编码定理"><a href="#3-2-信道容量与信道编码定理" class="headerlink" title="3.2 信道容量与信道编码定理"></a>3.2 信道容量与信道编码定理</h3><p>互信息 $I(X;Y)$ 依赖于输入分布 $P_X(\cdot)$。如果我们能够选择输入分布，那么我们就可以通过选择不同的输入分布来最大化互信息，从而最大化每次传输所能携带的信息量。这个最大值就被称为<strong>信道容量</strong>：$\displaystyle C&#x3D;\max_{P_X(\cdot)}I(X;Y)$。</p><p>一个输入分布 $P_X(\cdot)$ 能够达到信道容量 $C$ 需要满足的条件称为 <strong>$\mathrm{Karush–Kuhn–Tucker(KKT)}$ 条件</strong>， 其形式为：$I(x;Y)&#x3D;C$ 当且仅当 $P_X(x)&gt;0$；$I(x;Y)\le C$ 当且仅当 $P_X(x)&#x3D;0$。这个条件其实非常直观：如果某个输入符号 $x$ 的平均互信息小于信道容量 $C$，那么我们就不应该使用它（即 $P_X(x)&#x3D;0$），否则就无法达到信道容量。</p><p>在通信中，往往需要经过两道编码过程：<strong>信源编码</strong>和<strong>信道编码</strong>。直观地说，信源编码是用于将原始符号集以尽可能高的效率压缩到 $01$ 码中，而信道编码则是用于将 $01$ 码以尽可能高的可靠性传输到接收端，而这必然要求在传输过程中引入冗余。</p><p><strong>信道传输速度</strong>就是用于衡量信道编码引入的冗余量的，其定义为：$\displaystyle R&#x3D;\frac{\mathrm{avg}(L_1)}{\mathrm{avg}(L_1,L_2)}$，其中 $\mathrm{avg}(L_1)$ 表示原始信息经过信源编码后的平均码长，$\mathrm{avg}(L_1,L_2)$ 表示原始信息经过信源和信道两层编码后的平均码长。</p><p>例如：假设原始信息是等概率的 ${A,B,C}$，我们用 ${0,10,11}$ 对其进行信源编码，那么平均码长为 $\frac{1+2+2}{3}&#x3D;\frac{5}{3}$；接着，我们使用三重重复码（即将每个比特重复三次）再对其进行信道编码，那么平均码长变为 $\frac{3+6+6}{3}&#x3D;5$，因此信道传输速度为 $R&#x3D;\frac{5&#x2F;3}{5}&#x3D;\frac{1}{3}$。</p><p>信道容量和信道传输速度间的关系由著名的 <strong>$\mathrm{Shannon}$ 第二定理</strong>，又称<strong>信道编码定理</strong>给出。它指出：只要信道传输速率 $R\le C$，就存在一种编码方式，使得误码率可以任意小（只要码长足够长）；反之，如果 $R&gt;C$，则任何编码方式的误码率都有一个不为零的下限。</p><p>直观上看，噪声越少的信道，其信道容量 $C$ 越大，因此允许的信道传输速率 $R$ 也就越大（即在信道编码中可以引入更少的冗余来保证传输的可靠性）；反之，噪声越大的信道，其信道容量 $C$ 越小，因此允许的信道传输速率 $R$ 也就越小（即在信道编码中必须引入更多的冗余来保证传输的可靠性）。</p><p>$\mathrm{Shannon}$ 第二定理本身的证明比较复杂，这里就不再赘述了。有兴趣的同学可以参考文末的“扩展阅读”章节，或者直接阅读 $\mathrm{Shannon}$ 的原始论文《A Mathematical Theory of Communication》。这篇论文是整个信息论的奠基之作，其完整性甚至到今天还能作信息论教材使用，再怎么赞美都不为过。</p><h2 id="四、信息论的扩展与应用"><a href="#四、信息论的扩展与应用" class="headerlink" title="四、信息论的扩展与应用"></a>四、信息论的扩展与应用</h2><p>受 $\mathrm{Shannon}$ 信息论的启发，后续的研究者们提出了很多用于度量概率分布间距离的指标。这些指标至今仍在人工智能和概率统计领域有着广泛的应用。</p><h3 id="4-1-分布间距离的度量"><a href="#4-1-分布间距离的度量" class="headerlink" title="4.1 分布间距离的度量"></a>4.1 分布间距离的度量</h3><p>在这些指标中，最著名的莫过于<strong>交叉熵</strong>：$\displaystyle H(P,Q)&#x3D;-\sum_x P(x)\log Q(x)$，它衡量了按照概率分布 $Q$ 的最优编码对真实分布为 $P$ 的信息进行编码的平均码长。在给定 $P$ 的情况下，如果 $Q$ 和 $P$ 越接近，交叉熵越小；如果 $Q$ 和 $P$ 越远，交叉熵就越大。</p><p>容易发现，交叉熵的绝对大小与 $P$ 本身的熵有关。为了消除这个影响，我们可以定义<strong>相对熵</strong>（又称 <strong>$\mathrm{Kullback–Leibler(KL)}$ 散度</strong>）：$\displaystyle KL(P,Q)&#x3D;H(P,Q)-H(P)&#x3D;-\sum_x P(x)\log\left(\frac{Q(x)}{P(x)}\right)$。$\mathrm{KL}$ 散度总是非负的，它衡量了使用 $Q$ 对 $P$ 进行编码时所引入的额外码长。</p><p>然而，$\mathrm{KL}$ 散度并不满足对称性。 <strong>$\mathrm{Jensen-Shannon(JS)}$ 散度</strong>是 $\mathrm{KL}$ 散度的一种改进，其定义为：$JS(P,Q)&#x3D;\frac{1}{2}KL\left(P,\frac{P+Q}{2}\right)+\frac{1}{2}KL\left(Q,\frac{P+Q}{2}\right)$。它解决了 $\mathrm{KL}$ 散度不对称的问题，但这两个散度都存在一个问题：如果两个分布没有重叠或者重叠非常少时，散度值会变得非常大，甚至趋于无穷大，这在实际应用中并不理想。</p><p>为了解决这个问题，研究者们提出了 <strong>$\mathrm{Wasserstein}$ 距离</strong>。它的形式化定义比较复杂，但可以直观地理解为：如果将两个分布看作两个土堆，那么 $\mathrm{Wasserstein}$ 距离就是将一个土堆变成另一个土堆所需搬运的最小工作量。就比如下图所示：</p><p><img src="/img/43Class-7/2.png"></p><p>$\mathrm{Wasserstein}$ 距离相较 $\mathrm{KL}$ 散度和 $\mathrm{JS}$ 散度的优势在于：即使两个分布没有重叠或者重叠非常少，$\mathrm{Wasserstein}$ 距离仍然能反映两个分布的远近。</p><h3 id="4-2-信息论在人工智能中的应用"><a href="#4-2-信息论在人工智能中的应用" class="headerlink" title="4.2 信息论在人工智能中的应用"></a>4.2 信息论在人工智能中的应用</h3><p>前面提到，信息论中的这些分布间距离度量的指标在人工智能领域有着广泛的应用。例如，机器学习中最常用的损失函数之一<strong>交叉熵损失函数</strong>就是基于交叉熵定义的；又例如，今年年初爆火的 $\mathrm{DeepSeek-R1}$ 模型所使用的 $\mathrm{GRPO}$ 算法中就包含了 $\mathrm{KL}$ 散度惩罚项，用于稳定强化学习训练过程。</p><p>此外，在生成式模型中，由于需要衡量生成分布和真实数据分布之间的差异，信息论中的这些指标也被广泛使用。例如：在生成对抗网络（$\mathrm{GAN}$）中，原始的 $\mathrm{GAN}$ 使用 $\mathrm{JS}$ 散度来衡量生成分布和真实数据分布之间的差异；而后续的 $\mathrm{WassersteinGAN}$ 则使用 $\mathrm{Wasserstein}$ 距离来替代 $\mathrm{JS}$ 散度，从而提升了训练的稳定性和生成样本的质量。</p><p>信息熵本身也在人工智能的学术前沿有着一席之地。众所周知，大模型的最终输出是从一个概率分布中采样得到的，而信息熵正是衡量这个概率分布不确定性的一个重要指标。一个质量更高的回答应当具有更高还是更低的信息熵，至今仍然是一个开放性的问题。</p><p>关于人工智能的更多内容，敬请期待本学期后续的《肆叁小灶》系列推送。临近期中，也祝大家复习顺利，考试成功。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li>C. E. Shannon, “A Mathematical Theory of Communication”</li><li>Stefan M. Moser, “A Student’s Guide to Coding and Information Theory”</li><li>邱锡鹏，《神经网络与深度学习》nndl.github.io</li><li>龙明盛，《机器学习》《深度学习》</li></ol>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学(3)：离散数学</title>
    <link href="/CSDIY/CSDIY-3/"/>
    <url>/CSDIY/CSDIY-3/</url>
    
    <content type="html"><![CDATA[<p>大二上学期的自学笔记，由两门离散数学课程组成。</p><span id="more"></span><h2 id="一、信息论"><a href="#一、信息论" class="headerlink" title="一、信息论"></a>一、信息论</h2><h3 id="1-错误检测码"><a href="#1-错误检测码" class="headerlink" title="1. 错误检测码"></a>1. 错误检测码</h3><ol><li>奇偶校验码：在数据后加一位，使得 1 的个数为奇数或偶数（例：$\mathrm{ASCII}$）</li><li>改进：按 $N$ 位划分数据块，添加 $N$ 位校验码</li><li>加权校验码：$wxyz\to 4w+3x+2y+z$，再加一位使得和能被某数整除（例：身份证号）</li><li>$x_4&#x3D;x_1+x_2,x_5&#x3D;x_1+x_3,x_6&#x3D;x_2+x_3$</li></ol><h3 id="2-错误纠正码"><a href="#2-错误纠正码" class="headerlink" title="2. 错误纠正码"></a>2. 错误纠正码</h3><ol><li>线性码：将 $k$ 位映射到 $n$ 位，$x&#x3D;sG$，$G$ 为 $k\times n$ 矩阵</li><li>校验：$Hy^T\neq 0$ 则有错，$H$ 为 $(n-k)\times n$ 矩阵，$HG^T&#x3D;0$</li><li>对偶码：将 $H$ 作为生成矩阵，$G$ 作为校验矩阵</li><li>例：三重重复码、$(7,4)\ \mathrm{Hamming}$ 码 $(p_1&#x3D;x_1+x_2+x_4,p_2&#x3D;x_1+x_3+x_4,p_3&#x3D;x_2+x_3+x_4)$</li></ol><h3 id="3-数据压缩"><a href="#3-数据压缩" class="headerlink" title="3. 数据压缩"></a>3. 数据压缩</h3><ol><li>熵：$H(X)&#x3D;-\sum p(x)\log p(x)$</li><li>香农第一定理：编码平均长度 $\geq H(X)$，取等时必为平均分布</li><li>数据压缩码：$\mathrm{Huffman}$ 码（最优前缀码、最优唯一可译码）</li></ol><h3 id="4-信道编码"><a href="#4-信道编码" class="headerlink" title="4. 信道编码"></a>4. 信道编码</h3><ol><li>定义 $P_{X,Y}(x_i,y_j)$：发出 $x_i$ 且接收 $y_j$ 的概率，$P_{Y|X}(y_j|x_i)$：发出 $x_i$ 时接收 $y_j$ 的条件概率</li><li>熵：$H(X,Y)&#x3D;-\sum P_{X,Y}(x_i,y_j)\log P_{X,Y}(x_i,y_j)$，$H(Y|X)&#x3D;-\sum P_{X,Y}(x_i,y_j)\log P_{Y|X}(y_j|x_i)$</li><li>链式法则：$H(X,Y)&#x3D;H(X)+H(Y|X)$（信道的总熵等于输入的熵加上信道引入的熵）</li><li>互信息：$I(x_i;y_j)&#x3D;\log(\frac{1}{P_{X}(x_i)})-\log(\frac{1}{P_{X|Y}(x_i|y_j)})$（接收到 $y_j$ 后对 $x_i$ 的不确定性减少了多少）</li><li>平均互信息：$I(X;Y)&#x3D;\sum P_{X,Y}(x_i,y_j)I(x_i;y_j)&#x3D;H(X)-H(X|Y)$</li><li>性质：$I(X;Y)&#x3D;H(X)$ 当且仅当无损；$I(X;Y)&#x3D;0$ 当且仅当 $X,Y$ 独立（无信息量）</li><li>信道容量：$\displaystyle C&#x3D;\max_{P_X(\cdot)}I(X;Y)$（对所有可能的输入分布求最大平均互信息）</li><li>香农第二定理：若 $R&lt;C$，则存在编码使得误码率 $\to 0$，只要码长足够长；若 $R&gt;C$，则任何编码误码率均有下限，其中 $R$ 为信道传输速率（用几个比特传输一个符号）</li></ol><h2 id="二、博弈论"><a href="#二、博弈论" class="headerlink" title="二、博弈论"></a>二、博弈论</h2><ol><li>自身的策略要<strong>最大化</strong>对方的策略可能带来的<strong>最小收益</strong></li><li>鞍点：每个参与者的策略在给定其他参与者策略的情况下都是最优的（纯策略纳什均衡）</li><li>混合策略：<strong>最大化</strong>对方选择每一个纯策略所带来的<strong>最小期望收益</strong></li><li>最大最小值定理：零和博弈两个混合策略线性规划互为对偶，最优值相等（对偶定理）</li><li>非常和博弈：纳什均衡存在定理（纯策略或混合策略），但不一定是帕累托最优</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>自学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第六讲 .NET 开发与 C# 基础</title>
    <link href="/43Class/43Class-6/"/>
    <url>/43Class/43Class-6/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第六讲，介绍了 .NET 开发与 C# 基础，来源于三系联合暑培讲义。</p><span id="more"></span><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><h3 id="0-1-先修知识"><a href="#0-1-先修知识" class="headerlink" title="0.1 先修知识"></a>0.1 先修知识</h3><p>我们希望你已经具备以下基础：</p><ul><li>熟悉 C 语言</li><li>了解至少一门面向对象编程语言（如 Java, C++, Python）</li></ul><p>如果你具备以下基础，将更有利于你学习 C# 和 .NET 开发：</p><ul><li>Day 1 Linux 基础</li><li>Day 2 Git &amp; GitHub</li></ul><p>此外，本讲是以下后续讲座的基础：</p><ul><li>Day 4 多线程与异步</li><li>Day 7 WPF 与 Avalonia</li><li>Day 15 Unity 与 WebGL</li></ul><h3 id="0-2-环境搭建"><a href="#0-2-环境搭建" class="headerlink" title="0.2 环境搭建"></a>0.2 环境搭建</h3><p>笔者使用的是 Windows 环境，如果你使用的是 Linux 或 macOS，请参考相关文档进行环境搭建。</p><ul><li>请访问 <a href="https://dotnet.microsoft.com/download">.NET 官网</a> 下载并安装最新版本的 .NET SDK。</li><li>IDE 选择：推荐使用 Visual Studio 或 Visual Studio Code。Visual Studio 提供了更强大的功能和调试支持，而 Visual Studio Code 则更轻量级。</li></ul><p>如果你选择使用 Visual Studio，以下是环境搭建步骤：</p><ul><li>请访问 <a href="https://visualstudio.microsoft.com/">Visual Studio 官网</a> 下载并安装 Visual Studio Community。</li><li>在 Visual Studio Installer 中，选择 “.NET 桌面开发” 工作负载。</li></ul><p>如果你选择使用 Visual Studio Code，以下是环境搭建步骤：</p><ul><li>请访问 <a href="https://code.visualstudio.com/">Visual Studio Code 官网</a> 下载并安装 Visual Studio Code。</li><li>打开 Visual Studio Code，点击左侧扩展图标，搜索并安装 “C#”, “C# Dev Kit” 和 “.NET Install Tool” 扩展。</li></ul><p>在安装完成后，打开终端，输入以下命令来验证安装是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet --version<br></code></pre></td></tr></table></figure><p>如果安装成功，你将看到 .NET SDK 的版本号。</p><h3 id="0-3-C-NET-简介"><a href="#0-3-C-NET-简介" class="headerlink" title="0.3 C# &amp; .NET 简介"></a>0.3 C# &amp; .NET 简介</h3><p>.NET 是一个跨平台的开发框架，由微软开发。它提供了丰富的类库和工具，使得开发者可以更高效地构建应用程序。它支持多种编程语言，其中就包括 C#。C# 是一种现代的、面向对象的编程语言，广泛用于开发桌面应用、Web 应用、移动应用和游戏等。</p><p>在生成一个 .NET 程序时，程序员编写的代码暂时不翻译成本地的机器语言，而是先翻译成一种其他的<br>语言，叫做“微软中间语言（MSIL, Microsoft Intermediate Language）”。在执行该微软中间语言的可执行文件时，将启动对应 .NET 框架的“公共语言运行时（CLR, Common Language Runtime）”，由该 CLR 将 MSIL 编译为机器码执行，称作 JIT 编译（Just-In-Time Compilation）。</p><p>而与之相对应地，我们熟知的 C++ 是直接编译成机器码的，这种方式称为 AOT 编译（Ahead-Of-<br>Time Compilation）：预处理器处理源代码中的预处理指令（如 <code>#include</code>、<code>#define</code> 等）生成<br>预处理后的代码，编译器将预处理后的代码翻译为机器语言生成目标文件（.obj 或 .o 文件）、<br>链接器将目标文件和库文件链接在一起，生成最终的可执行文件（.exe 或 .out 文件）、操作系统加载并执行生成的可执行文件。</p><p>可⻅，CLR 就仿佛一台独立于物理机器的“虚拟机”，MSIL 语言的程序可以在 CLR 上运行。由于这个机制，我们可以得到很多便利，例如可以轻松实现垃圾回收、跨平台等等。</p><h3 id="0-4-创建一个-C-程序"><a href="#0-4-创建一个-C-程序" class="headerlink" title="0.4 创建一个 C# 程序"></a>0.4 创建一个 C# 程序</h3><p>我们介绍两种创建 C# 程序的方式：使用命令行和使用 Visual Studio。</p><h4 id="0-4-1-使用命令行"><a href="#0-4-1-使用命令行" class="headerlink" title="0.4.1 使用命令行"></a>0.4.1 使用命令行</h4><ul><li>打开终端，输入以下命令创建一个新的控制台应用程序：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet new console -n HelloWorld<br></code></pre></td></tr></table></figure><ul><li>进入新创建的目录：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> HelloWorld<br></code></pre></td></tr></table></figure><ul><li>打开 <code>Program.cs</code> 文件，你会看到以下代码：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>运行程序：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dotnet run<br></code></pre></td></tr></table></figure><p>你应该会看到输出 <code>Hello, World!</code>。</p><h4 id="0-4-2-使用-Visual-Studio"><a href="#0-4-2-使用-Visual-Studio" class="headerlink" title="0.4.2 使用 Visual Studio"></a>0.4.2 使用 Visual Studio</h4><ul><li>打开 Visual Studio，选择 “创建新项目”。</li><li>在语言栏中选择 “C#”，然后选择 “控制台应用”，点击 “下一步”。</li><li>输入项目名称（如 <code>HelloWorld</code>），选择保存位置，点击 “下一步”</li><li>勾选”不启用顶级语句”，然后点击 “创建”。</li><li>在 <code>Program.cs</code> 文件中，你会看到以下代码：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">HelloWorld</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>点击工具栏上的 “运行” 按钮（或按 F5 键）来运行程序。</li><li>你应该会在打开的终端中看到输出 <code>Hello, World!</code>。</li></ul><h3 id="0-5-C-程序入口"><a href="#0-5-C-程序入口" class="headerlink" title="0.5 C# 程序入口"></a>0.5 C# 程序入口</h3><p>可以发现，0.4.1 和 0.4.2 中的代码有些不同。使用命令行创建的程序是一个顶级语句（Top-Level Statements）程序，而使用 Visual Studio 创建的程序是一个传统的 C# 程序。</p><p>顶级语句是 C# 9.0 引入的特性，对于初学者来说，这种方式更简洁易懂，但在更复杂的应用程序中，我们仍然需要使用传统的类和方法结构。</p><h4 id="0-5-1-传统结构"><a href="#0-5-1-传统结构" class="headerlink" title="0.5.1 传统结构"></a>0.5.1 传统结构</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">HelloWorld</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是 0.4.2 一节中生成的使用传统结构的代码。第一行 <code>using System</code> 是在包含 <code>System</code> 命名空间，<code>System</code> 是很多 .NET 类库所在的命名空间。包含该命名空间，可以使用该命名空间的内容。其中，<code>Console</code> 是 <code>System</code> 命名空间的一个类，因此该语句应为 <code>System.Console.WriteLine(&quot;Hello World!&quot;)</code>。但由于我们使用了 <code>using System</code>，因此可省去 <code>System</code>。</p><p><code>HelloWorld</code> 是我们自定义的一个命名空间，<code>Program</code> 是一个类，而 <code>Main</code> 是该类的一个静态方法（关于类和静态方法的概念我们将会在后面提到），称为“<code>Main</code> 方法”。一般来说，一个应用程序以 <code>Main</code> 方法作为入口点，且一个程序通习惯上只有一个类定义一个 <code>Main</code> 方法作为程序入口点（如果有多个类具有 <code>Main</code> 方法需要在项目配置中手动指定入口点）。</p><p>一般来说，习惯上 <code>Main</code> 方法都被定义在 <code>Program</code> 类中。</p><h4 id="0-5-2-顶级语句"><a href="#0-5-2-顶级语句" class="headerlink" title="0.5.2 顶级语句"></a>0.5.2 顶级语句</h4><p>在 C# 9.0（.NET 5.0）中，应用程序也可以没有 <code>Main</code> 方法，但是需要有且仅有一个文件具有“顶级语句（Top-level statements）”。所谓顶级语句就是在所有的命名空间定义之前的语句。若程序无 <code>Main</code> 方法，则以顶级语句作为入口点。如下面 0.4.1 一节中生成的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure><p>C# 编译器会自动将这个顶级语句转换为一个隐式的 <code>Main</code> 方法，并输出 <code>Hello, World!</code>。值得一提的是，上面的代码并没有引入 <code>using System</code> 语句，但仍然可以使用 <code>Console</code> 类，这是因为 C# 编译器会自动引入一些常用的命名空间。</p><h3 id="0-6-C-项目结构"><a href="#0-6-C-项目结构" class="headerlink" title="0.6 C# 项目结构"></a>0.6 C# 项目结构</h3><p>一个包含多文件的 C# 项目的目录结构一般如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nix">ProjectName<span class="hljs-symbol">/</span><br>├── ProjectName.csproj  <span class="hljs-comment"># 项目文件，包含项目的配置和依赖信息</span><br>├── Program.cs          <span class="hljs-comment"># 主程序文件，包含程序入口点</span><br>├── Program.sln         <span class="hljs-comment"># 解决方案文件</span><br>├── ModuleName1<span class="hljs-symbol">/</span>        <span class="hljs-comment"># 模块 1</span><br>│   ├── ScriptName1.cs<br>│   └── ScriptName2.cs<br>├── ModuleName2<span class="hljs-symbol">/</span>        <span class="hljs-comment"># 模块 2</span><br>│   ├── ScriptName3.cs<br>│   └── ScriptName4.cs<br>├── Resources<span class="hljs-symbol">/</span>          <span class="hljs-comment"># 静态资源文件夹</span><br>│   ├── Images<span class="hljs-symbol">/</span><br>│   │   ├── image1.png<br>│   │   └── image2.jpg<br>│   └── Data<span class="hljs-symbol">/</span><br>│       ├── data1.json<br>│       └── data2.xml<br>├── bin<span class="hljs-symbol">/</span>                <span class="hljs-comment"># 编译输出目录（自动生成）</span><br>├── obj<span class="hljs-symbol">/</span>                <span class="hljs-comment"># 编译中间文件目录（自动生成）</span><br>├── README.md           <span class="hljs-comment"># 项目说明文档</span><br>└── .gitignore          <span class="hljs-comment"># Git 忽略文件配置</span><br></code></pre></td></tr></table></figure><p>其中，<code>Program.cs</code> 是主程序文件，包含程序的入口点；<code>ModuleName1</code> 和 <code>ModuleName2</code> 是两个模块，分别包含各自的脚本文件；<code>Resources</code> 文件夹用于存放静态资源，如图片和数据文件；<code>bin</code> 和 <code>obj</code> 文件夹是编译过程中自动生成的输出目录和中间文件目录；<code>README.md</code> 是项目说明文档；<code>.gitignore</code> 是 Git 忽略文件配置。</p><p>如需在一个代码文件中引用其他代码文件中的类或方法，可以使用 <code>using</code> 语句引入命名空间。例如，在 <code>Program.cs</code> 中引用 <code>ModuleName1/ScriptName1.cs</code> 中定义的命名空间 <code>Namespace1</code> 下的类 <code>Class1</code>，可以使用以下方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Namespace1;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ProjectName</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 创建 Namespace1.Class1 的实例</span><br>            Class1 obj = <span class="hljs-keyword">new</span> Class1();<br>            obj.SomeMethod(); <span class="hljs-comment">// 调用 Class1 中的方法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，在 C# 中，命名空间的识别是基于命名空间名称而不是文件路径。只要两个文件在同一个项目中，编译器会自动扫描所有 .cs 文件来查找命名空间。</p><h2 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1. 变量与数据类型"></a>1. 变量与数据类型</h2><p>C# 是一种面向对象的强类型语言，变量必须先声明后使用。C# 类型系统的特点是，一切类型均继承自 <code>System.Object</code> 类，即 <code>object</code> 类型是一切类型的基类。C# 的类型分为两种：值类型和引用类型。其中，值类型与 C 语言类似，直接在内存上储存数值；而引用类型则与 Python 类似，变量存储的是对象的引用。</p><h3 id="1-1-值类型"><a href="#1-1-值类型" class="headerlink" title="1.1 值类型"></a>1.1 值类型</h3><p>C# 中的值类型包括：</p><ul><li>基本数据类型：<code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>bool</code> 等。</li><li>枚举类型：使用 <code>enum</code> 关键字定义的枚举类型。</li><li>结构体类型：使用 <code>struct</code> 关键字定义的结构体类型。</li></ul><h4 id="1-1-1-基本数据类型"><a href="#1-1-1-基本数据类型" class="headerlink" title="1.1.1 基本数据类型"></a>1.1.1 基本数据类型</h4><p>基本数据类型中，<code>char</code> 类型与 C 语言中的 <code>char</code> 略有不同：在 C# 中，<code>char</code> 类型是一个 16 位的 Unicode 字符，而在 C 语言中，<code>char</code> 类型是一个 8 位的 ASCII 字符；其余基本数据类型与 C 语言类似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br><span class="hljs-comment">// 注意，C# 中的所有类型都是类，int() 就是 int 类的构造方法（函数）</span><br>age = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 赋值，这两行也可直接写成 int age = 20;</span><br><span class="hljs-built_in">float</span> height;  <span class="hljs-comment">// float height = new float() 的简略写法</span><br><span class="hljs-comment">// C# 会自动回收变量，无需手动 delete</span><br></code></pre></td></tr></table></figure><p>注意，C# 默认可以将低精度类型隐式转换到高精度类型，而将高精度类型转换到低精度类型需要强制类型转换。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">float</span> b = a;  <span class="hljs-comment">// 隐式转换，int 到 float</span><br><span class="hljs-built_in">int</span> c = (<span class="hljs-built_in">int</span>)b;  <span class="hljs-comment">// 强制转换，float 到 int</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2-枚举类型"><a href="#1-1-2-枚举类型" class="headerlink" title="1.1.2 枚举类型"></a>1.1.2 枚举类型</h4><p>枚举类型则用于定义一个新的数据类型，该类型的所有可能值就是其枚举成员。为了后续便于比较和赋值，<code>enum</code> 为每个可能的值分配了一个整数值。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">enum</span> Student  <span class="hljs-comment">// 定义 Student 类型</span><br>&#123;<br>    Alice = <span class="hljs-number">101</span>,<br>    Bob,  <span class="hljs-comment">// 不声明时会自动赋值为前一个枚举值加 1，即 102</span><br>    Charlie = <span class="hljs-number">201</span><br>&#125;<br><br>Student student = Student.Alice;<br><span class="hljs-comment">// Student.Alice 是 Student 类型的三个可能取值之一</span><br><span class="hljs-keyword">if</span> (student == Student.Bob)<br><span class="hljs-comment">// 注意，等式的两边都是 Student 类型而非 int 类型</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Student is Bob&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-3-结构体类型"><a href="#1-1-3-结构体类型" class="headerlink" title="1.1.3 结构体类型"></a>1.1.3 结构体类型</h4><p>C# 中的结构体类型也与 C 语言中的结构体相似，可以包含多个字段。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span></span>)  <span class="hljs-comment">// Point 类的构造方法</span></span><br>    &#123;<br>        X = x;<br>        Y = y;<br>    &#125;<br>&#125;<br><br>Point p1; <span class="hljs-comment">// 即 Point p1 = new Point(0, 0);</span><br>p1.X = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 访问结构体的字段</span><br>Point p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 使用构造方法创建结构体实例</span><br></code></pre></td></tr></table></figure><h4 id="1-1-4-元组类型"><a href="#1-1-4-元组类型" class="headerlink" title="1.1.4 元组类型"></a>1.1.4 元组类型</h4><p>此外，C# 还支持元组类型，提供了简洁的语法来将多个数据元素分组成一个轻型数据结构，与 Python 中的元组和 C++ 中的 <code>std::tuple</code> 类似，可看作一个轻量级的结构体。元组最常用的场景是作为方法的返回值，将多个返回值打包成一个元组返回。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(<span class="hljs-built_in">double</span>, <span class="hljs-built_in">int</span>) person1 = (<span class="hljs-number">1.75</span>, <span class="hljs-number">70</span>);<br><span class="hljs-built_in">double</span> height1 = person1.Item1;  <span class="hljs-comment">// 访问元组的第一个元素</span><br><br>(<span class="hljs-built_in">double</span> Height, <span class="hljs-built_in">int</span> Weight) person2 = (<span class="hljs-number">1.80</span>, <span class="hljs-number">75</span>);<br><span class="hljs-built_in">double</span> height2 = person2.Height;  <span class="hljs-comment">// 访问元组的命名元素</span><br><br><span class="hljs-keyword">var</span> person3 = (Height: <span class="hljs-number">1.65</span>, Weight: <span class="hljs-number">60</span>);  <span class="hljs-comment">// 使用 var 定义元组</span><br><span class="hljs-built_in">double</span> height3 = person3.Height;<br></code></pre></td></tr></table></figure><p>上面使用的 <code>var</code> 关键字是 C# 的类型推断功能，编译器会根据右侧的值自动推断出变量的类型，如 <code>var person3</code> 的类型为 <code>(double, int)</code> 元组。</p><h3 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2 引用类型"></a>1.2 引用类型</h3><p>除了 1.1 一节中介绍的值类型，C# 中的其他类型均为引用类型。常用的引用类型包括字符串 <code>string</code>，类 <code>class</code>，接口 <code>interface</code>，数组 <code>[]</code>，委托 <code>delegate</code> 等。类、接口与委托的概念我们将在后续章节中介绍，这里我们先介绍字符串和数组。</p><h4 id="1-2-1-字符串"><a href="#1-2-1-字符串" class="headerlink" title="1.2.1 字符串"></a>1.2.1 字符串</h4><p>C# 中的字符串 <code>string</code> 与 Python 中的字符串类似，是一个不可变的字符序列。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-comment">// name1 是一个引用，即一个 string 对象的别名，该对象的内容为 &quot;Alice&quot;</span><br><span class="hljs-built_in">string</span> name2 = <span class="hljs-string">&quot;Bob&quot;</span>;  <span class="hljs-comment">// 简化写法</span><br><span class="hljs-built_in">string</span> name3;  <span class="hljs-comment">// 仅定义了一个 string 引用，并未指向任何 string 对象</span><br>name3 = <span class="hljs-string">&quot;Charlie&quot;</span>;<br><span class="hljs-comment">// 现在 name3 指向了一个新的 string 对象，其内容为 &quot;Charlie&quot;</span><br><span class="hljs-built_in">string</span> name4 = name3;  <span class="hljs-comment">// 复制的是引用，而非 &quot;Charlie&quot; 本身</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-数组"><a href="#1-2-2-数组" class="headerlink" title="1.2.2 数组"></a>1.2.2 数组</h4><p>C# 中的数组是一个固定大小的元素集合，元素类型可以是值类型或引用类型，例如由 <code>int</code> 类型组成的数组 <code>int[]</code>，由 <code>string</code> 类型组成的数组 <code>string[]</code> 等。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 定义一个长度为 5 的 int 数组</span><br>arr1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 访问数组元素</span><br><span class="hljs-built_in">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;  <span class="hljs-comment">// 定义并初始化一个 int 数组</span><br><span class="hljs-built_in">int</span>[] arr3 = &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;  <span class="hljs-comment">// 简化写法</span><br><span class="hljs-keyword">var</span> arr4 = <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span> &#125;;<br><span class="hljs-comment">// 数组类型和数组长度都可以由编译器自动推断</span><br><span class="hljs-built_in">int</span> length4 = arr4.Length;  <span class="hljs-comment">// 获取数组长度</span><br></code></pre></td></tr></table></figure><p>C# 中也可以定义多维数组，但与 C 语言不同，C# 的多维数组并非通过嵌套数组实现，而是直接定义为一个多维数组类型。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>[,] matrix1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>];  <span class="hljs-comment">// 定义一个 3x3 的二维数组</span><br>matrix1[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 访问二维数组元素</span><br><span class="hljs-keyword">var</span> matrix2 = <span class="hljs-keyword">new</span>[,] &#123; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;, &#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;, &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125; &#125;;<br><span class="hljs-built_in">int</span> size2 = matrix2.Length;  <span class="hljs-comment">// 获取二维数组的元素总数</span><br><span class="hljs-built_in">int</span> row2 = matrix2.GetLength(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取二维数组的行数</span><br><span class="hljs-built_in">int</span> col2 = matrix2.GetLength(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 获取二维数组的列数</span><br></code></pre></td></tr></table></figure><p>我们可以使用 <code>foreach</code> 语句遍历数组中的元素，但需要注意的是，通过 <code>foreach</code> 无法修改数组中的元素，只能访问其值。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> arr4)<br>&#123;<br>    Console.WriteLine(item);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-NET-数据结构"><a href="#1-3-NET-数据结构" class="headerlink" title="1.3 .NET 数据结构"></a>1.3 .NET 数据结构</h3><p>C# 还提供了许多常用的数据结构，如列表 <code>List&lt;T&gt;</code>、字典 <code>Dictionary&lt;TKey, TValue&gt;</code>、集合 <code>HashSet&lt;T&gt;</code>、队列 <code>Queue&lt;T&gt;</code>、栈 <code>Stack&lt;T&gt;</code> 等，这些数据结构都位于 <code>System.Collections.Generic</code> 命名空间中，本质为泛型类（与 C++ 中的模板类相似），可以存储任意类型的数据，用法与 C++ STL 中的容器以及 Python 的标准数据类型类似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;  <span class="hljs-comment">// 定义一个整数列表</span><br>numbers.Add(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 添加元素</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    Console.WriteLine(number);  <span class="hljs-comment">// 遍历列表元素</span><br>&#125;<br><br>Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; ages = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;<br>&#123;<br>    &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span> &#125;<br>&#125;;  <span class="hljs-comment">// 定义一个字符串到整数的字典</span><br>ages[<span class="hljs-string">&quot;Alice&quot;</span>] = <span class="hljs-number">31</span>;  <span class="hljs-comment">// 修改字典中的值</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> kvp <span class="hljs-keyword">in</span> ages)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;kvp.Key&#125;</span>: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);  <span class="hljs-comment">// 遍历字典键值对</span><br>&#125;<br><br>HashSet&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span> &#125;;  <span class="hljs-comment">// 定义一个字符串集合</span><br>names.Add(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// 添加重复元素不会报错，但不会添加重复的元素</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> names)<br>&#123;<br>    Console.WriteLine(name);  <span class="hljs-comment">// 遍历集合元素</span><br>&#125;<br><br>Queue&lt;<span class="hljs-built_in">string</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 定义一个字符串队列</span><br>queue.Enqueue(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// 入队</span><br>queue.Enqueue(<span class="hljs-string">&quot;Bob&quot;</span>);  <span class="hljs-comment">// 入队</span><br>Console.WriteLine(queue.Dequeue());  <span class="hljs-comment">// 出队，输出 &quot;Alice&quot;</span><br><br>Stack&lt;<span class="hljs-built_in">string</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">string</span>&gt;();  <span class="hljs-comment">// 定义一个字符串栈</span><br>stack.Push(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// 压栈</span><br>stack.Push(<span class="hljs-string">&quot;Bob&quot;</span>);  <span class="hljs-comment">// 压栈</span><br>Console.WriteLine(stack.Pop());  <span class="hljs-comment">// 弹栈，输出 &quot;Bob&quot;</span><br></code></pre></td></tr></table></figure><p>此外，C# 还提供 <code>ArrayList</code> 和 <code>Hashtable</code> 等非泛型集合类型，其元素类型为 <code>object</code>（所有类型的基类，即可以存储任意类型的对象），但不推荐使用，因为它们不提供类型安全检查，容易导致运行时错误，此处不再赘述。</p><h2 id="2-输入与输出"><a href="#2-输入与输出" class="headerlink" title="2. 输入与输出"></a>2. 输入与输出</h2><p>在介绍 C# 的输入输出前，我们先介绍一下 C# 的格式化字符串。</p><h3 id="2-1-格式化字符串"><a href="#2-1-格式化字符串" class="headerlink" title="2.1 格式化字符串"></a>2.1 格式化字符串</h3><p>C# 提供了多种格式化字符串的方式，包括转义字符、逐字文本、字符串内插、原始字符串等。</p><h4 id="2-1-1-转义字符"><a href="#2-1-1-转义字符" class="headerlink" title="2.1.1 转义字符"></a>2.1.1 转义字符</h4><p>使用 <code>\</code> 转义特殊字符，如 <code>\n</code> 表示换行，<code>\\</code> 表示反斜杠，与 C 语言类似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, World!\nThis is a new line.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-1-2-逐字文本"><a href="#2-1-2-逐字文本" class="headerlink" title="2.1.2 逐字文本"></a>2.1.2 逐字文本</h4><p>使用 <code>@</code> 前缀定义逐字文本字符串，逐字文本字符串中的转义字符不会被处理。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> path = <span class="hljs-string">@&quot;C:\Users\Alice\Documents&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-1-3-字符串内插"><a href="#2-1-3-字符串内插" class="headerlink" title="2.1.3 字符串内插"></a>2.1.3 字符串内插</h4><p>使用 <code>$</code> 前缀定义字符串内插，可以在字符串中嵌入变量，与 Python 类似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">string</span> greeting = <span class="hljs-string">$&quot;Hello, my name is <span class="hljs-subst">&#123;name&#125;</span> and I am <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-1-4-原始字符串"><a href="#2-1-4-原始字符串" class="headerlink" title="2.1.4 原始字符串"></a>2.1.4 原始字符串</h4><p>以 <code>&quot;&quot;&quot;</code> 开始并以 <code>&quot;&quot;&quot;</code> 结束，允许多行字符串，若为多行字符串则以单独的一行 <code>&quot;&quot;&quot;</code> 结尾，且字符串的缩进以结尾的 <code>&quot;&quot;&quot;</code> 的起始位置为基准。原始字符串文本不进行任何转义操作，但允许字符串内插（开头的 <code>$</code> 数量代表内插所需要的花括号数）。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">string</span> rawStringWithInterpolation = $<span class="hljs-string">$&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    This is a raw string with interpolation.</span><br><span class="hljs-string">    My name is &#123;&#123;name&#125;&#125; and I am &#123;&#123;age&#125;&#125; years old.</span><br><span class="hljs-string">    &quot;</span><span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-控制台读写"><a href="#2-2-控制台读写" class="headerlink" title="2.2 控制台读写"></a>2.2 控制台读写</h3><h4 id="2-2-1-控制台输入"><a href="#2-2-1-控制台输入" class="headerlink" title="2.2.1 控制台输入"></a>2.2.1 控制台输入</h4><p>C# 提供了两种控制台输入：<code>System.Console.Read</code> 和 <code>System.Console.ReadLine</code>。其中 <code>System.Console.Read</code> 读取一个字符返回（返回值为  <code>int</code>）；而 <code>System.Console.ReadLine</code> 可以读入一行字符串。若要读入一个整数或浮点数，需要手动进行转换。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> line = System.Console.ReadLine();<br><span class="hljs-built_in">int</span> num1 = <span class="hljs-built_in">int</span>.Parse(line);  <span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-built_in">int</span> num2 = Convert.ToInt32(System.Console.ReadLine());<br></code></pre></td></tr></table></figure><h4 id="2-2-2-控制台输出"><a href="#2-2-2-控制台输出" class="headerlink" title="2.2.2 控制台输出"></a>2.2.2 控制台输出</h4><p>控制台输出则常用 <code>System.Console.Write</code> 和 <code>System.Console.WriteLine</code> 实现。其中 <code>System.Console.Write</code> 输出内容后不换行，而 <code>System.Console.WriteLine</code> 输出内容后会自动换行。此外，可以进行格式输出，只需要在字符串中用 {} 括住参数的序号即可，但更常用的是字符串内插。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.Console.Write(<span class="hljs-string">&quot;Hello, World!&quot;</span>);  <span class="hljs-comment">// 输出不换行</span><br>System.Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);  <span class="hljs-comment">// 输出并换行</span><br><span class="hljs-built_in">int</span> num = <span class="hljs-number">42</span>;<br>System.Console.WriteLine(<span class="hljs-string">&quot;The answer is &#123;0&#125;.&quot;</span>, num);  <span class="hljs-comment">// 格式化</span><br>System.Console.WriteLine(<span class="hljs-string">$&quot;The answer is <span class="hljs-subst">&#123;num&#125;</span>.&quot;</span>);  <span class="hljs-comment">// 字符串内插</span><br></code></pre></td></tr></table></figure><h3 id="2-3-NET-流与文件读写"><a href="#2-3-NET-流与文件读写" class="headerlink" title="2.3 .NET 流与文件读写"></a>2.3 .NET 流与文件读写</h3><p>C# 也支持文件的输入输出操作，可以使用 <code>System.IO</code> 命名空间中的类来实现。常用的文件操作类包括 <code>File</code>、<code>StreamReader</code> 和 <code>StreamWriter</code>。</p><h4 id="2-3-1-File-类"><a href="#2-3-1-File-类" class="headerlink" title="2.3.1 File 类"></a>2.3.1 File 类</h4><p>File 类常用于一次性读写文件操作，相较于流操作更为简单。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-comment">// 使用 File 类进行文件操作</span><br>File.WriteAllText(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;Hello, World!&quot;</span>);  <span class="hljs-comment">// 写入文件</span><br><span class="hljs-built_in">string</span> content = File.ReadAllText(<span class="hljs-string">&quot;output.txt&quot;</span>);  <span class="hljs-comment">// 读取文件</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-StreamReader-和-StreamWriter-类"><a href="#2-3-2-StreamReader-和-StreamWriter-类" class="headerlink" title="2.3.2 StreamReader 和 StreamWriter 类"></a>2.3.2 StreamReader 和 StreamWriter 类</h4><p><code>StreamReader</code> 和 <code>StreamWriter</code> 类则用于逐行读写文件，适合处理大文件或需要逐行处理的场景。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (StreamWriter writer = <span class="hljs-keyword">new</span> StreamWriter(<span class="hljs-string">&quot;output.txt&quot;</span>))  <span class="hljs-comment">// 逐行写入</span><br>&#123;<br>    writer.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    writer.WriteLine(<span class="hljs-string">&quot;This is a new line.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(<span class="hljs-string">&quot;output.txt&quot;</span>))  <span class="hljs-comment">// 逐行读取</span><br>&#123;<br>    <span class="hljs-built_in">string</span> line;<br>    <span class="hljs-keyword">while</span> ((line = reader.ReadLine()) != <span class="hljs-literal">null</span>)<br>    &#123;<br>        Console.WriteLine(line);  <span class="hljs-comment">// 逐行输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 <code>using</code> 语句用于确保在使用完流后自动释放资源，避免资源泄漏。</p><h2 id="3-运算与控制"><a href="#3-运算与控制" class="headerlink" title="3. 运算与控制"></a>3. 运算与控制</h2><h3 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 运算符"></a>3.1 运算符</h3><p>C# 除了支持常见的算术运算符、关系运算符和逻辑运算符外，还带有一些特殊的运算符。</p><h4 id="3-1-1-空合并运算符"><a href="#3-1-1-空合并运算符" class="headerlink" title="3.1.1 空合并运算符"></a>3.1.1 空合并运算符</h4><p>用 <code>??</code> 表示，如果左侧为 null，则返回右侧的值。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// int? 表示可空的整数类型，即可以为 null</span><br><span class="hljs-built_in">int</span> b = a ?? <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果 a 为 null，则 b 为 0</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-空条件运算符"><a href="#3-1-2-空条件运算符" class="headerlink" title="3.1.2 空条件运算符"></a>3.1.2 空条件运算符</h4><p>用 <code>?.</code> 表示，如果左侧为 null，则返回 null，否则返回左侧的值。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>? str = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 虽然 string 本身就可以为 null，但使用 string? 可让编译器不再警告</span><br><span class="hljs-built_in">string</span> result = str?.ToUpper() ?? <span class="hljs-string">&quot;Default&quot;</span>;<br><span class="hljs-comment">// 如果 str 为 null，则 result 为 &quot;Default&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3-空合并赋值运算符"><a href="#3-1-3-空合并赋值运算符" class="headerlink" title="3.1.3 空合并赋值运算符"></a>3.1.3 空合并赋值运算符</h4><p>用 <code>??=</code> 表示，如果左侧为 null，则将右侧的值赋给左侧。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;<br>a ??= <span class="hljs-number">10</span>;  <span class="hljs-comment">// 如果 a 为 null，则将 10 赋值给 a</span><br></code></pre></td></tr></table></figure><h4 id="3-1-4-空包容运算符"><a href="#3-1-4-空包容运算符" class="headerlink" title="3.1.4 空包容运算符"></a>3.1.4 空包容运算符</h4><p>用 <code>!</code> 表示，用于指示编译器左侧的值不会为 null，通常用于取消编译器的 null 检查。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>? nullString = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">string</span> result = nullString!.ToUpper();<br><span class="hljs-comment">// 运行时会抛出 NullReferenceException</span><br></code></pre></td></tr></table></figure><p>注意，使用 <code>!</code> 运算符时要格外小心，它只是告诉编译器不要警告，但如果值确实是 <code>null</code>，运行时仍会出错。</p><h3 id="3-2-模式匹配"><a href="#3-2-模式匹配" class="headerlink" title="3.2 模式匹配"></a>3.2 模式匹配</h3><p>模式匹配是一种测试表达式是否具有特定特征的方法，在 C# 中可以通过 <code>switch</code> 语句或 <code>is</code> 关键字实现，与 Python 的 <code>match…case</code> 类似。模式匹配可以用于以下场景：</p><h4 id="3-2-1-Null-检查"><a href="#3-2-1-Null-检查" class="headerlink" title="3.2.1 Null 检查"></a>3.2.1 Null 检查</h4><p>使用 <code>is null</code> 或 <code>is not null</code> 进行空值判断。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Object is null&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Object is not null&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-类型匹配"><a href="#3-2-2-类型匹配" class="headerlink" title="3.2.2 类型匹配"></a>3.2.2 类型匹配</h4><p>在 <code>switch</code> 语句中匹配类型。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">string</span> s:<br>        Console.WriteLine(<span class="hljs-string">$&quot;String: <span class="hljs-subst">&#123;s&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// C# 中每个 case 必须以 break 结束</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment">// 使用 when 子句添加额外条件</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Positive Integer: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Unknown type&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-3-值匹配与比较"><a href="#3-2-3-值匹配与比较" class="headerlink" title="3.2.3 值匹配与比较"></a>3.2.3 值匹配与比较</h4><p>在 <code>switch</code> 语句中匹配或比较特定的值。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">switch</span> (number)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;The answer to life, the universe, and everything&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">100</span>:  <span class="hljs-comment">// and 用于同模式叠加，when 用于额外条件</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Positive number less than 100&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> &lt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Negative number&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-4-属性匹配"><a href="#3-2-4-属性匹配" class="headerlink" title="3.2.4 属性匹配"></a>3.2.4 属性匹配</h4><p>在 <code>switch</code> 语句中匹配对象的属性。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br>Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">switch</span> (person)<br>&#123;<br>    <span class="hljs-keyword">case</span> &#123; Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span> &#125;:<br>        Console.WriteLine(<span class="hljs-string">&quot;Person is Alice, 30 years old&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> &#123; Name: <span class="hljs-string">&quot;Bob&quot;</span> &#125;:<br>        Console.WriteLine(<span class="hljs-string">&quot;Person is Bob&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> &#123; Age: &lt; <span class="hljs-number">18</span> &#125;:<br>        Console.WriteLine(<span class="hljs-string">&quot;Person is a minor&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Unknown person&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-5-元组匹配"><a href="#3-2-5-元组匹配" class="headerlink" title="3.2.5 元组匹配"></a>3.2.5 元组匹配</h4><p>在 <code>switch</code> 语句中匹配元组。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) point = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">switch</span> (point)<br>&#123;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>):<br>        Console.WriteLine(<span class="hljs-string">&quot;Origin&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> (<span class="hljs-keyword">var</span> x, <span class="hljs-number">0</span>):  <span class="hljs-comment">// 捕获元组中的变量</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;On X-axis at <span class="hljs-subst">&#123;x&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> (_, _):  <span class="hljs-comment">// 弃元模式 _ 用于匹配任何元素</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Other point&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-异常处理"><a href="#3-3-异常处理" class="headerlink" title="3.3 异常处理"></a>3.3 异常处理</h3><p>在 C# 中，<code>System.Exception</code> 类是一切异常类的基类，<code>Message</code> 是该类及其派生类共有的属性，用于储存异常信息。C# 中的异常处理使用 <code>try-catch-finally</code> 语句块来捕获和处理异常，与 C++ 类似。</p><h4 id="3-3-1-内置异常类"><a href="#3-3-1-内置异常类" class="headerlink" title="3.3.1 内置异常类"></a>3.3.1 内置异常类</h4><p>C# 提供了许多内置异常类，如 <code>ArgumentNullException</code>（参数为空）、<code>IndexOutOfRangeException</code>（数组越界）等，程序运行过程中若遇到这些异常，系统会自动抛出相应的异常对象，其 <code>Message</code> 属性会自动包含异常信息。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// 可能触发内置异常的代码</span><br>    <span class="hljs-built_in">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br>    arr[<span class="hljs-number">10</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 将自动抛出带有 Message 属性的 IndexOutOfRangeException 异常</span><br>&#125;<br><span class="hljs-keyword">catch</span> (IndexOutOfRangeException ex)  <span class="hljs-comment">// 捕获特定类型的异常</span><br>&#123;<br>    <span class="hljs-comment">// 处理异常</span><br>    Console.WriteLine(<span class="hljs-string">$&quot;Caught an IndexOutOfRangeException: <span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br>    <span class="hljs-comment">// 无论是否发生异常都会执行的代码，常用于进行恢复或清理工作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-调用异常类"><a href="#3-3-2-调用异常类" class="headerlink" title="3.3.2 调用异常类"></a>3.3.2 调用异常类</h4><p>上述内置的异常类在其他地方也可以调用并抛出，但需要自定义其 <code>Message</code> 属性来提供更具体的错误信息。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// 调用内置异常类</span><br>    <span class="hljs-keyword">if</span> (arr.Length == <span class="hljs-number">0</span>)  <span class="hljs-comment">// 本来这个操作并不会抛出空参数异常，但此处我们故意调用并抛出</span><br>    &#123;<br>        <span class="hljs-comment">// 自主调用的内置异常需要自定义 Message 属性并手动抛出</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">&quot;Array cannot be empty&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex)  <span class="hljs-comment">// 捕获所有异常，若无需处理异常也可简略写成 catch</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;Caught an exception: <span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>);<br>    <span class="hljs-keyword">throw</span>;  <span class="hljs-comment">// 重新抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-自定义异常类"><a href="#3-3-3-自定义异常类" class="headerlink" title="3.3.3 自定义异常类"></a>3.3.3 自定义异常类</h4><p>此外，在 C# 中也可以自定义异常类。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomException</span> : <span class="hljs-title">Exception</span>  <span class="hljs-comment">// 继承自 Exception 类</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomException</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 可以在此处添加自定义的异常处理逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// 调用自定义异常类</span><br>    <span class="hljs-keyword">if</span> (arr.Length &lt; <span class="hljs-number">5</span>)<br>    &#123;<br>        <span class="hljs-comment">// 手动抛出自定义异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomException(<span class="hljs-string">&quot;Array length must be at least 5&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (CustomException ex)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;Caught a CustomException: <span class="hljs-subst">&#123;ex.Message&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. 类</h2><h3 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h3><p>类属于引用类型，由 <code>class</code> 关键词定义。一个类可以包含字段、方法等，甚至可以包含类（称为嵌套类）。类还可以分成很多块来定义，甚至放在多个文件里，只需要将每个部分的定义都加上 <code>partial</code> 关键字即可。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> name;  <span class="hljs-comment">// 只读公有字段，只能在构造方法中赋值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age = <span class="hljs-number">18</span>;  <span class="hljs-comment">// 带有默认值的公有字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> IDNumber;  <span class="hljs-comment">// 私有字段</span><br>    <span class="hljs-comment">// 未指定默认值时，值类型默认为 0，引用类型默认为 null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)  <span class="hljs-comment">// 构造方法</span></span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-comment">// this 表示指向本对象自身的引用，用于区分同名的参数和字段</span><br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);  <span class="hljs-comment">// 创建 Person 类的实例</span><br>person1.name = <span class="hljs-string">&quot;Bob&quot;</span>;  <span class="hljs-comment">// 修改公有字段</span><br></code></pre></td></tr></table></figure><p>上面所使用的构造方法与 C++ 中的构造函数类似，不具有返回值，且方法名与类名相同，是在一个对象被构造的时候调用的方法，由 <code>new</code> 表达式传递参数。一个类可以有多个构造方法（称为重载），但每个构造方法的参数列表必须不同。</p><h3 id="4-2-Static-关键字"><a href="#4-2-Static-关键字" class="headerlink" title="4.2 Static 关键字"></a>4.2 Static 关键字</h3><h4 id="4-2-1-静态字段与方法"><a href="#4-2-1-静态字段与方法" class="headerlink" title="4.2.1 静态字段与方法"></a>4.2.1 静态字段与方法</h4><p>类中的字段和方法可以是静态的，使用 <code>static</code> 关键词定义。静态字段和方法属于类本身，而不是类的实例。静态字段在所有实例中共享，静态方法可以直接通过类名调用，与 Python 中的类变量和类方法相似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtils</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14159</span>;  <span class="hljs-comment">// 静态常量字段，定义后不可修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)  <span class="hljs-comment">// 静态方法</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用静态字段和方法</span><br>Console.WriteLine(MathUtils.Pi);  <span class="hljs-comment">// 输出：3.14159</span><br>Console.WriteLine(MathUtils.Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 输出：5</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-运算符重载"><a href="#4-2-2-运算符重载" class="headerlink" title="4.2.2 运算符重载"></a>4.2.2 运算符重载</h4><p>运算符重载是一种特殊的静态方法，在 C# 中其语法与 C++ 类似，使用 <code>operator</code> 关键字定义。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Point</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        X = x;<br>        Y = y;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-keyword">operator</span> +(Point p1, Point p2)  <span class="hljs-comment">// 重载 + 运算符</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(p1.X + p2.X, p1.Y + p2.Y);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>Point p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Point p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Point p3 = p1 + p2;  <span class="hljs-comment">// 使用重载的 + 运算符</span><br></code></pre></td></tr></table></figure><h3 id="4-3-类的方法"><a href="#4-3-类的方法" class="headerlink" title="4.3 类的方法"></a>4.3 类的方法</h3><h4 id="4-3-1-参数传递"><a href="#4-3-1-参数传递" class="headerlink" title="4.3.1 参数传递"></a>4.3.1 参数传递</h4><p>与 C++ 类似，C# 中方法的参数默认采用值传递，即将实参复制一份给形参。对于值类型来说，复制的是值类型的所有数据，对于引用类型来说，复制的是一个引用。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params">Person x, Person y</span>)</span><br>    &#123;<br>        Person tmp = x;<br>        x = y;<br>        y = tmp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SwapAge</span>(<span class="hljs-params">Person x, Person y</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> tmp = x.age;<br>        x.age = y.age;<br>        y.age = tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>Person p = <span class="hljs-keyword">new</span> Person(), q = <span class="hljs-keyword">new</span> Person();<br>p.age = <span class="hljs-number">555</span>; q.age = <span class="hljs-number">666</span>;<br>Utility.Swap(p, q);<br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p.age&#125;</span> <span class="hljs-subst">&#123;q.age&#125;</span>&quot;</span>);  <span class="hljs-comment">// 输出：555 666</span><br>Utility.SwapAge(p, q);<br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p.age&#125;</span> <span class="hljs-subst">&#123;q.age&#125;</span>&quot;</span>);  <span class="hljs-comment">// 输出：666 555</span><br></code></pre></td></tr></table></figure><p>若要实现引用传递，可以使用 <code>ref</code> 关键字。加上关键字 <code>ref</code> 后，值类型的形参和实参指代的是同一个值类型对象，而引用类型的实参和形参指代的是同一个引用，例如上述代码改成：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> Person x, <span class="hljs-keyword">ref</span> Person y</span>)</span><br>&#123;<br>    Person tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>Person p = <span class="hljs-keyword">new</span> Person(), q = <span class="hljs-keyword">new</span> Person();<br>p.age = <span class="hljs-number">555</span>; q.age = <span class="hljs-number">666</span>;<br>Utility.Swap(<span class="hljs-keyword">ref</span> p, <span class="hljs-keyword">ref</span> q);  <span class="hljs-comment">// 调用时也必须加 ref 关键字！</span><br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p.age&#125;</span> <span class="hljs-subst">&#123;q.age&#125;</span>&quot;</span>);  <span class="hljs-comment">// 输出：666 555</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-参数缺省"><a href="#4-3-2-参数缺省" class="headerlink" title="4.3.2 参数缺省"></a>4.3.2 参数缺省</h4><p>C# 中可以为方法的参数设置缺省值，这样在调用方法时可以省略某些参数。调用时，默认会把末尾未赋实参的参数赋以缺省值，但也可以自行指定。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MathTool</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Div</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span> y = <span class="hljs-number">1</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x / y;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>MathTool.Div(<span class="hljs-number">5</span>); <span class="hljs-comment">// x = 5, y = 1</span><br>MathTool.Div(y: <span class="hljs-number">9</span>); <span class="hljs-comment">// x = 1, y = 9</span><br>MathTool.Div(y: <span class="hljs-number">5</span>, x: <span class="hljs-number">4</span>); <span class="hljs-comment">// x = 4, y = 5</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3-Lambda-表达式"><a href="#4-3-3-Lambda-表达式" class="headerlink" title="4.3.3 Lambda 表达式"></a>4.3.3 Lambda 表达式</h4><p>如果方法体只有一行代码，可以使用 Lambda 表达式来简化书写。Lambda 表达式可以看成一个匿名方法，其语法为 <code>(参数列表) =&gt; 表达式</code>，与 Python 中的推导式类似。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(x, y) =&gt; x + y;<br>o =&gt; &#123; o = o + <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> o; &#125;;  <span class="hljs-comment">// 参数只有一个时可省略括号，且可以使用语句块</span><br>() =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);  <span class="hljs-comment">// 无参数时括号不可省略</span><br></code></pre></td></tr></table></figure><h3 id="4-4-继承与多态"><a href="#4-4-继承与多态" class="headerlink" title="4.4 继承与多态"></a>4.4 继承与多态</h3><h4 id="4-4-1-类的继承"><a href="#4-4-1-类的继承" class="headerlink" title="4.4.1 类的继承"></a>4.4.1 类的继承</h4><p>C# 继承的语法与 C++ 类似，但 C# 不支持多继承。在类里可以通过 base 关键字代表它的基类，同样构造方法也需要通过 base 关键字来为它的基类提供构造方法的参数。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-方法重写"><a href="#4-4-2-方法重写" class="headerlink" title="4.4.2 方法重写"></a>4.4.2 方法重写</h4><p>在 C# 中，只有虚方法（使用 <code>virtual</code> 关键字定义，必须定义方法体）和抽象方法（使用 <code>abstract</code> 关键字定义，不能定义方法体）可以被重写，且重写方法时必须使用 <code>override</code> 关键字。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()  <span class="hljs-comment">// 虚方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal speaks&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()  <span class="hljs-comment">// 重写虚方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-抽象类"><a href="#4-4-3-抽象类" class="headerlink" title="4.4.3 抽象类"></a>4.4.3 抽象类</h4><p>抽象类使用 <code>abstract</code> 关键字定义，其不能被实例化，但可以被继承（不允许继承的类使用 <code>sealed</code> 关键字定义）。但与 C++ 不同，C# 中的抽象类可以包含非抽象方法（即有方法体的方法）。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>  <span class="hljs-comment">// 抽象类</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span>;  <span class="hljs-comment">// 抽象方法，没有方法体</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()  <span class="hljs-comment">// 非抽象方法，有方法体</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Displaying shape&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span>  <span class="hljs-comment">// 继承抽象类</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> radius;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()  <span class="hljs-comment">// 实现抽象方法</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-4-接口"><a href="#4-4-4-接口" class="headerlink" title="4.4.4 接口"></a>4.4.4 接口</h4><p>接口（使用 <code>interface</code> 关键字定义，属于引用类型）比抽象类更为严格，其只能包含没有方法体的方法（即抽象方法，但不需要使用 <code>abstract</code> 关键字），且不能包含字段。但一个类可以实现（即继承）多个接口，实现接口中的方法时也无需使用 <code>override</code> 关键字。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawable</span>  <span class="hljs-comment">// 接口</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;  <span class="hljs-comment">// 抽象方法，没有方法体</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span>  <span class="hljs-comment">// 另一个接口</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span>;  <span class="hljs-comment">// 抽象方法，没有方法体</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IDrawable</span>, <span class="hljs-title">IShape</span>  <span class="hljs-comment">// 实现多个接口</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> height;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()  <span class="hljs-comment">// 实现 IDrawable 接口的方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing rectangle&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()  <span class="hljs-comment">// 实现 IShape 接口的方法</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> width * height;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-C-特性"><a href="#5-C-特性" class="headerlink" title="5. C# 特性"></a>5. C# 特性</h2><h3 id="5-1-泛型"><a href="#5-1-泛型" class="headerlink" title="5.1 泛型"></a>5.1 泛型</h3><p>C# 中的泛型与 C++ 的模板类似，允许在类、方法等定义中使用类型参数，只需要在类或方法名后使用尖括号 <code>&lt;&gt;</code> 括住泛型的名称即可。此外，若希望泛型类型参数满足某些条件，可以使用 <code>where</code> 关键字指定类型约束。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt;<br><span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params">T x, T y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.X = x;<br>        <span class="hljs-keyword">this</span>.Y = y;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>Point&lt;<span class="hljs-built_in">int</span>&gt; pt1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>其中，<code>where T : struct</code> 表示 <code>T</code> 必须是一个不可为 <code>null</code> 的值类型，否则会报错。此外，<code>struct</code> 还可换成：</p><ul><li><code>class</code>：不可为 <code>null</code> 的引用类型</li><li><code>class?</code>：引用类型</li><li><code>new()</code>：具有无参构造方法</li><li>一个类名或接口名：<code>T</code> 必须从该类继承或实现了该接口</li><li>……（具体约束根据需求而定）</li></ul><h3 id="5-2-委托"><a href="#5-2-委托" class="headerlink" title="5.2 委托"></a>5.2 委托</h3><p>委托是一种引用类型，作用与 C++ 中的函数指针类似。委托类型的定义格式与方法类似，只是在返回值类型前加上 <code>delegate</code> 关键字。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">BinaryFunctor</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br></code></pre></td></tr></table></figure><p>该段代码定义了一个委托类型，名字叫 <code>BinaryFunctor</code>。该委托可以接收参数为 <code>(int, int)</code>，返回类型为 <code>int</code> 的方法。与其他引用类型一样，我们需要用 <code>new</code> 关键字创建一个委托，并将一个方法赋给这个委托。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> =&gt; a + b;  <span class="hljs-comment">// Add 方法的定义</span><br>BinaryFunctor bf = <span class="hljs-keyword">new</span> BinaryFunctor(Add);<br><br><span class="hljs-comment">// 调用</span><br>Console.WriteLine(bf(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 输出 8</span><br></code></pre></td></tr></table></figure><p>但多数情况下，我们并不需要自定义委托类型，因为 .NET 中已经定义好了一些内置的委托类型：</p><ul><li><code>Action</code>：返回值为 <code>void</code> 类型的委托，泛型参数列表内为参数列表，例如 <code>Action</code> 为无参且返回值为 <code>void</code> 的委托、<code>Action&lt;int&gt;</code> 为参数是 <code>int</code> 且返回值为 <code>void</code> 的委托。</li><li><code>Func</code>：既有参数又有返回值的委托。泛型参数列表中最后一个为返回值类型。例如 <code>Func&lt;int, double&gt;</code> 为参数是 <code>int</code>、返回值是 <code>double</code> 的委托。</li></ul><p>此外，一个委托不仅可以绑定一个方法，还可以绑定多个方法，即多播委托。多播委托可以通过 <code>+=</code> 运算符添加方法，通过 <code>-=</code> 运算符移除方法。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Call1</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;Call1&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Call2</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;Call2&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Call3</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;Call3&quot;</span>);<br><br><span class="hljs-keyword">var</span> caller = <span class="hljs-keyword">new</span> Action(Call1);<br>caller += Call2;<br>caller = caller + Call3;<br>caller.Invoke();  <span class="hljs-comment">// 等价于 caller();</span><br></code></pre></td></tr></table></figure><p>注意，移除方法后多播委托可能存在不绑定任何一个方法的情况，在这种情况下调用委托是非法的。我们可以使用 <code>caller?.Invoke()</code> 先判断委托是否绑定了方法，如果是再调用 <code>Invoke</code> 方法。</p><h2 id="6-C-进阶（选读）"><a href="#6-C-进阶（选读）" class="headerlink" title="6. C# 进阶（选读）"></a>6. C# 进阶（选读）</h2><p>由于篇幅的限制和课时的影响，很多有趣且非常有用的内容我们没有做过多展开，例如：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/reflection-and-attributes/">属性与反射</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/iterators">迭代器</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/">索引器</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/">语言集成查询</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.text.json?view=net-9.0">正则表达式</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/expression-trees/">表达式树</a></li></ul><p>感兴趣的同学可以自行阅读。此外，我们将在下一节学习使用 C# 进行多线程程序与异步程序的编写。接下来请进一步学习“多线程与异步”单元。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学(2)：机器学习</title>
    <link href="/CSDIY/CSDIY-2/"/>
    <url>/CSDIY/CSDIY-2/</url>
    
    <content type="html"><![CDATA[<p>大一下学期的自学笔记，由机器学习、深度学习课程组成。</p><span id="more"></span><h2 id="一、统计学习"><a href="#一、统计学习" class="headerlink" title="一、统计学习"></a>一、统计学习</h2><h3 id="1-回归问题"><a href="#1-回归问题" class="headerlink" title="1. 回归问题"></a>1. 回归问题</h3><ol><li>损失函数：均方误差损失 $\mathrm{MSE}$，$\sum (f(x)-y)^2$</li><li>改进：基函数（获取非线性）、正则项（$\mathrm{L2,L1}$）</li></ol><h3 id="2-二分类问题"><a href="#2-二分类问题" class="headerlink" title="2. 二分类问题"></a>2. 二分类问题</h3><ol><li>连接函数：$\mathrm{Sigmoid}$，$\sigma(f(x))&#x3D;\frac{1}{1+e^{-f(x)}}$</li><li>损失函数：交叉熵，$l(x,y)&#x3D;y\log(\sigma(f(x)))+(1-y)\log(1-\sigma(f(x)))$</li></ol><h3 id="3-多分类问题"><a href="#3-多分类问题" class="headerlink" title="3. 多分类问题"></a>3. 多分类问题</h3><ol><li>连接函数：$\mathrm{Softmax}$，$\sigma_i(f(x))&#x3D;\frac{e^{f_i(x)}}{\sum_j e^{f_j(x)}}$</li><li>损失函数：交叉熵，$l(x,y)&#x3D;-\log(\sigma_y(f(x)))$</li></ol><h3 id="4-学习理论"><a href="#4-学习理论" class="headerlink" title="4. 学习理论"></a>4. 学习理论</h3><ol><li>估计误差 $\mathrm{Estimation}$：训练所得函数与假设空间中最佳函数的距离</li><li>近似误差 $\mathrm{Approximation}$：假设空间中最佳函数与真值函数的距离</li><li>泛化误差：估计误差与近似误差之和</li></ol><h3 id="5-优化方法"><a href="#5-优化方法" class="headerlink" title="5. 优化方法"></a>5. 优化方法</h3><ol><li>一阶方法：梯度下降（随机梯度下降）</li><li>学习率衰减：$\eta_{\min}+\frac{1}{2}(\eta_{\max}-\eta_{\min})(1+\cos(\frac{T_{cur}}{T_{all}}\pi))$</li><li>冲量法：$\Delta_t&#x3D;\beta\Delta_{t-1}+(1-\beta)\nabla J(\theta_t)$</li><li>$\mathrm{Nesterov}$：$\theta_t^\prime&#x3D;\theta_t-\beta\Delta_{t-1},\Delta_t&#x3D;\beta\Delta_{t-1}+(1-\beta)\nabla J(\theta_t^\prime)$</li><li>自适应学习率 $\mathrm{AdaGrad}$：$h&#x3D;\frac{1}{\sqrt{r_t}+\delta}$，$r_t$ 为历史梯度平方和，但容易爆炸</li><li>$\mathrm{RMSProp}$：$r_t&#x3D;\rho r_{t-1}+(1-\rho)\nabla J(\theta_t)^2$，解决爆炸问题，可与冲量法连用</li><li>自适应冲量 $\mathrm{Adam}$：将 $h$ 也作用在冲量项上，但需用分母修正 $r,s$ 偏差，可与 $\mathrm{Nesterov}$ 连用</li><li>二阶方法：$\theta&#x3D;\theta-H^{-1}\nabla J(\theta)$（增量算法可直接算逆）</li></ol><p><img src="/img/CSDIY-24Summer/1.png"></p><h2 id="二、深度学习"><a href="#二、深度学习" class="headerlink" title="二、深度学习"></a>二、深度学习</h2><h3 id="6-多层感知机-mathrm-MLP"><a href="#6-多层感知机-mathrm-MLP" class="headerlink" title="6. 多层感知机 $\mathrm{MLP}$"></a>6. 多层感知机 $\mathrm{MLP}$</h3><ol><li>感知机学习算法：$(x,\pm 1),y&#x3D;\mathrm{sgn}(\theta x)$，错误时 $\theta&#x3D;\theta+xy$，设置阈值并堆叠模拟逻辑或函数运算</li><li>激活函数：$\mathrm{Sigmoid},\mathrm{ReLU},\mathrm{tanh},\mathrm{Softmax},\mathrm{GeLU},\mathrm{LeakyReLU}$</li><li>优化：反向传播（基于残差或计算图）</li><li>训练技巧：$\mathrm{Dropout}$、$\mathrm{ReLU}$ 初始方差改为 $\frac{2}{n}$</li></ol><h3 id="7-卷积神经网络-mathrm-CNN"><a href="#7-卷积神经网络-mathrm-CNN" class="headerlink" title="7. 卷积神经网络 $\mathrm{CNN}$"></a>7. 卷积神经网络 $\mathrm{CNN}$</h3><ol><li>不变性（$fT&#x3D;f$）、等变性（$fT&#x3D;Tf$）</li><li>卷积核参数：$\mathrm{Stride},\mathrm{Padding},\mathrm{Dilation}$</li><li>训练技巧：池化 $\mathrm{Pooling}$、$\mathrm{BatchNormalization}$（改进：$\mathrm{GroupNormalization}$）、数据增广</li><li>标准架构：$1\times 1$ 卷积、$\mathrm{Inception}$（多尺度卷积）、$\mathrm{ResNet}$（残差直连）</li><li>轻量化：剪枝、权重聚类、组卷积（组间可洗牌）、通道分离卷积</li><li>改进：视频 $\mathrm{3D}$ 卷积、$\mathrm{Attention}$（全局距离加权，度量学习）、通道加权、神经架构搜索</li></ol><h3 id="8-循环神经网络-mathrm-RNN"><a href="#8-循环神经网络-mathrm-RNN" class="headerlink" title="8. 循环神经网络 $\mathrm{RNN}$"></a>8. 循环神经网络 $\mathrm{RNN}$</h3><ol><li>$h_t&#x3D;f(h_{t-1},x_t)&#x3D;\mathrm{tanh}(Wh_{t-1}+Ux_t),y_t&#x3D;Vh_t$，可改进为双向、多层</li><li>应用方式：多对一、一对多、多对多</li><li>优化：反向传播，但容易梯度爆炸或消失</li><li>梯度爆炸：分块、梯度裁剪（$\mathrm{Clip}$）</li><li>梯度消失：$\mathrm{LSTM}$（遗忘、写入、读取）</li><li>训练技巧：$\mathrm{Dropout}$ 共享、$\mathrm{Layer Normalization}$（通道间归一）、课程学习（逐步将真值 $y$ 替换为预测）</li><li>$\mathrm{Attention}$：逐层做 $h_t$ 相关性加权</li></ol><h3 id="9-图神经网络-mathrm-GNN"><a href="#9-图神经网络-mathrm-GNN" class="headerlink" title="9. 图神经网络 $\mathrm{GNN}$"></a>9. 图神经网络 $\mathrm{GNN}$</h3><ol><li>节点相似性：$\frac{N(u)\cap N(v)}{N(u)\cup N(v)}$，但无法刻画远距离</li><li>$\mathrm{DeepWalk}$：用随机游走的概率表示节点相似性，损失函数 $\displaystyle \sum_{u\in V}\sum_{v\in N(u)}-\log(\frac{\exp(z_u^Tz_v)}{\sum_{n\in V}\exp(z_u^Tz_n)})$</li><li>改进：$\mathrm{node2vec}$（加权随机游走，平衡 $\mathrm{BFS}$ 和 $\mathrm{DFS}$）、分母随机采样降低复杂度</li><li>图卷积网络 $\mathrm{GCN}$：效仿 $\mathrm{CNN}$ 特征聚合、同层参数共享，$\displaystyle h_v^k&#x3D;\sigma(W_k\sum_{u\in N(v)}\frac{h_u^{k-1}}{|N(v)|}+B_kh_v^{k-1})$</li><li>改进：图注意力网络 $\mathrm{GAT}$（邻居加权）、聚类 $\mathrm{ClusterGCN}$（降低复杂度）</li><li>训练技巧：在部分顶点上训练降低复杂度、将图卷积层改为 $\mathrm{MLP}$ 避免过平滑（小世界原理）、残差连接</li></ol><h3 id="10-mathrm-Transformer"><a href="#10-mathrm-Transformer" class="headerlink" title="10. $\mathrm{Transformer}$"></a>10. $\mathrm{Transformer}$</h3><ol><li>$\mathrm{Attention}$：将 $x$ 转化为 $q,k,v$，$a&#x3D;\mathrm{Softmax}(\frac{q^Tk}{\sqrt{d}})$，$\mathrm{MQA,GQA}$ 头间共享 $k,v$</li><li>$\mathrm{FFN}$：$\mathrm{FFN}(x)&#x3D;\mathrm{GeLU}(W_1x+b_1)W_2+b_2$，$\mathrm{dim}W&#x3D;d^2$ 且参数共享，$\mathrm{MoE}$ 中多个共用</li><li>模仿 $\mathrm{CNN,RNN}$，引入<strong>加权</strong>残差连接、预先 $\mathrm{LayerNormalization}$（归一化或单位化）</li><li>位置编码：$e_i(2j)&#x3D;\sin(\frac{i}{10000^{2j&#x2F;d}}),e_i(2j+1)&#x3D;\cos(\frac{i}{10000^{2j&#x2F;d}})$；或相对位置编码 $\mathrm{ALiBi}$、旋转位置编码 $f(x,m)&#x3D;xe^{im\theta},\theta_i&#x3D;10000^{-2(i-1)&#x2F;d}$</li><li>改进：线性注意力、$\mathrm{MaskAttention}$（遮挡）、$\mathrm{FlashAttention}$（分块）、$\mathrm{RingAttention}$（分布式）</li><li>$\mathrm{GPT}$：$\mathrm{Decoder}$，生成式预训练；$\mathrm{BERT}$：$\mathrm{Encoder}$，填空式预训练；$\mathrm{T5}$：完整版</li></ol><h3 id="11-语言模型"><a href="#11-语言模型" class="headerlink" title="11. 语言模型"></a>11. 语言模型</h3><ol><li>$\mathrm{ScalingLaw}$：参数量 $\gt$ $\mathrm{BatchSize}\gt \mathrm{epoch}$；推理 $\gt$ 训练；扩大单模型 $\mathrm{vs}$ 多模型集成</li><li>微调：全量微调（数据多易负迁移）、$\mathrm{Adapter}$（插适配头，如低秩适应微调 $\mathrm{LoRA}$，$\theta&#x3D;\theta+AB$）、部分微调（如调倒数两三层，数据少易过拟合）</li><li>改进：加入正则项限制微调改变量、重跑预训练任务检查精度变化、多模型微调（根据相关性加权蒸馏）</li><li>$\mathrm{RLHF}$：监督微调 $\to$ 训练奖励模型 $\to$ 强化学习；或 $\mathrm{DPO}$（直接用成对数据微调，可用大模型生成）</li><li>$\mathrm{Prompting}$：$\mathrm{InContextLearning}$，思维链，集成工具，检索增强生成 $\mathrm{RAG}$（文档向量化 $\to$ 与问题计算相似度 $\to$ 写入 $\mathrm{Prompt}$）</li><li>部署：量化（浮点转小整数）、推测解码 $\mathrm{SpeculativeDecoding}$（小模型生成大模型验证）</li><li>视觉：$\mathrm{CLIP}$（弱监督图文对相似度矩阵对角化）、$\mathrm{Flamingo}$（将图 $\mathrm{token}$ 映射到文本空间）、$\mathrm{Q-Former}$（将图转化为 $\mathrm{query}$）</li></ol><h3 id="12-多模态与智能体"><a href="#12-多模态与智能体" class="headerlink" title="12. 多模态与智能体"></a>12. 多模态与智能体</h3><ol><li>底层：$\mathrm{ViT}$（分块 $\mathrm{MLP}$ 后块间注意力）、$\mathrm{SwinTransformer}$（块内注意力，块滑动）</li><li>训练方式：生成式预训练，如 $\mathrm{ImageGPT}$</li><li>$\mathrm{CLIP}$：弱监督图文对，让相似度矩阵对角化</li><li>多模态语言模型：$\mathrm{Flamingo}$（将图转为 $\mathrm{token}$ 嵌入文本）、$\mathrm{Q-Former}$（将图转为 $\mathrm{query}$）、$\mathrm{VQGAN}$（图转为最近码字，再解码计算相似度）</li><li>纯多模态模型：$\mathrm{Fuyu}$（图文同等映射到另一空间）</li><li>$\mathrm{Agent}$：规划（目标分解、自我反思）、记忆（长：历史经验；短：上下文）、工具（外部应用、大模型）、行动（虚拟、具身）、协作（人机、多代理）</li></ol><h3 id="13-迁移学习"><a href="#13-迁移学习" class="headerlink" title="13. 迁移学习"></a>13. 迁移学习</h3><ol><li>多任务学习：共享参数 $+$ 任务头，损失函数加权（或范数归一、任务不确定性、帕累托最优）</li><li>元学习：输入数据集直接输出最优学习器，分为训练任务（支撑集、验证集）、测试任务（训练集、测试集），优化目标为 $n$ 个训练任务的平均损失函数</li><li>生成学习：先编码再解码算相似度，可对编码器做限制（稀疏性、范数、加噪声、加遮挡）</li><li>对比学习：增广两个副本 $\to$ 分别转为特征向量 $\mathrm{query,key}\to$ 计算相似度，优化对比损失函数 $-\sum\log\frac{\exp(k_i^Tq_i&#x2F;\tau)}{\sum\exp(k_j^Tq_i&#x2F;\tau)}$，$\mathrm{SimCLR}$ 引入解码器</li><li>改进：$\mathrm{MemoryBank}$ 存储定量 $\mathrm{key}$ 降低复杂度、$\mathrm{MoCo}$（用 $q$ 编码器的滑动平均更新 $k$ 编码器）、$\mathrm{SimSiam}$（无负例，单边解码，另一边停止梯度）</li><li>领域自适应：$\mathrm{OOD}$，用 $H\Delta H$ 对称差散度衡量分布差异，如领域对抗神经网络 $\mathrm{DANN}$（用 $\mathrm{GAN}$ 将两领域映射到接近的领域，在接近领域上学习）</li></ol><h2 id="三、强化学习"><a href="#三、强化学习" class="headerlink" title="三、强化学习"></a>三、强化学习</h2><h3 id="14-表格式学习（状态、动作都离散）"><a href="#14-表格式学习（状态、动作都离散）" class="headerlink" title="14. 表格式学习（状态、动作都离散）"></a>14. 表格式学习（状态、动作都离散）</h3><ol><li>算法：$\mathrm{SARSA}\to \mathrm{Q-learning}$（将$\mathrm{A^\prime}$ 替换为最优动作）</li><li>改进：资格迹（每步衰减 $\gamma\lambda$，遇到就 $+1$）</li></ol><h3 id="15-价值函数逼近（状态空间连续）"><a href="#15-价值函数逼近（状态空间连续）" class="headerlink" title="15. 价值函数逼近（状态空间连续）"></a>15. 价值函数逼近（状态空间连续）</h3><ol><li>核心思想：用以 $w$ 为参数的模型估计 $Q(S,A)$</li><li>$\mathrm{TD-error}:\delta&#x3D;R+\gamma Q(S^\prime,A^\prime)-Q(S,A)$</li><li>$w&#x3D;w-\alpha \nabla w\cdot\delta$（一步梯度下降）</li><li>改进：$\mathrm{Q-learning}$、资格迹（将 $+1$ 替换为 $\nabla w\cdot Q(S,A))$</li></ol><h3 id="16-策略梯度方法（状态、动作都连续）"><a href="#16-策略梯度方法（状态、动作都连续）" class="headerlink" title="16. 策略梯度方法（状态、动作都连续）"></a>16. 策略梯度方法（状态、动作都连续）</h3><ol><li>核心思想：用一个以 $\theta$ 为参数的模型获得策略</li><li>离散型策略：$\mathrm{Softmax}$，$\pi(a|s,\theta)&#x3D;\frac{e^{J(s,a)}}{\sum e^{J(s,b)}}$</li><li>连续型策略：$\mathrm{Gaussian}$</li><li>策略梯度定理：$\nabla J(\theta)\propto q(s,a)\nabla \log \pi(a|s,\theta)$</li><li>$\mathrm{REINFORCE}$：基于 $\mathrm{Monte Carlo}$ 方法，可引入 $\mathrm{Baseline}$（状态价值函数）减小方差，与价值函数逼近联用</li><li>$\mathrm{Actor-Critic}$：基于时序差分方法，可引入资格迹 $\nabla \log \pi(a|s,\theta)$、$\mathrm{Baseline}$</li><li>改进：近端策略优化 $\mathrm{TRPO,PPO}$，防止更新过大导致策略崩溃（用 $\mathrm{KL}$ 散度衡量新旧策略差异）</li></ol><h3 id="17-现代强化学习"><a href="#17-现代强化学习" class="headerlink" title="17. 现代强化学习"></a>17. 现代强化学习</h3><ol><li>$\mathrm{DDPG}$：确定性策略梯度方法，在连续动作空间中更有效</li><li>$\mathrm{SAC}$：优化策略的同时最大化策略的熵，鼓励随机探索</li><li>基于模型的强化学习：学习环境模型，用模拟数据与真实数据一起训练策略，如 $\mathrm{Dyna-Q}$</li></ol><p><img src="/img/CSDIY-24Summer/2.png"></p><h3 id="4-生成式模型"><a href="#4-生成式模型" class="headerlink" title="4. 生成式模型"></a>4. 生成式模型</h3><h3 id="18-生成对抗网络-mathrm-GAN"><a href="#18-生成对抗网络-mathrm-GAN" class="headerlink" title="18. 生成对抗网络 $\mathrm{GAN}$"></a>18. 生成对抗网络 $\mathrm{GAN}$</h3><ol><li>损失函数：对抗学习，$\displaystyle \min_G\max_D(\log D(x)+\log(1-D(G(z))))$，$D$ 为判别器，$G$ 为生成器（$\mathrm{Jensen-Shannon}$ 散度）</li><li>改进：$\log(1-x)$ 好样本梯度爆炸、坏样本梯度消失，改为优化 $\log(D(G(z)))$；换用 $\mathrm{Wasserstein}$ 距离（将 $D$ 改为满足 $\mathrm{1-Lipschitz}$ 的连续函数）</li><li>生成器实现：$\mathrm{DCGAN}$（逆向 $\mathrm{CNN}$，转置卷积）</li><li>$\mathrm{Benchmark}$：$\mathrm{InceptionScore}$（可识别性分布与生成多样性分布的 $\mathrm{KL}$ 散度）、$\mathrm{FID}$（生成样本与真实样本的高斯分布差异）</li><li>模式崩溃：使用 $\mathrm{GradientPenalty}$ 或系数矩阵谱归一化限制 $\mathrm{Lipschitz}$ 系数</li><li>条件生成：加入重建误差，对标签数据 $(x_i,y_i)$ 优化 $\displaystyle\min_G\max_D(\log D(x_i,y_i)+\log(1-D(G(x_i,z_i)))+|G(x_i,z_i)-y_i|)$</li></ol><h3 id="19-变分自编码器-mathrm-VAE"><a href="#19-变分自编码器-mathrm-VAE" class="headerlink" title="19. 变分自编码器 $\mathrm{VAE}$"></a>19. 变分自编码器 $\mathrm{VAE}$</h3><h3 id="20-扩散模型-mathrm-Diffusion"><a href="#20-扩散模型-mathrm-Diffusion" class="headerlink" title="20. 扩散模型 $\mathrm{Diffusion}$"></a>20. 扩散模型 $\mathrm{Diffusion}$</h3>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>自学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第五讲 数据结构预备知识（下）</title>
    <link href="/43Class/43Class-5/"/>
    <url>/43Class/43Class-5/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第五讲，介绍了数据结构相关的树论知识。</p><span id="more"></span><p>笃实 43 班的同学们大家好。本期推送我们将接着上期的内容，介绍一些树论相关的知识。</p><h2 id="一、树的基本概念"><a href="#一、树的基本概念" class="headerlink" title="一、树的基本概念"></a>一、树的基本概念</h2><p>树在《数据结构》和《离散数学（2）》中的定义略有不同且较为复杂，这里我们分开讨论。</p><p>对于<strong>无向图</strong>，无环的无向图称为<strong>无向森林</strong>，简称<strong>森林</strong>，无向森林中的每个连通分量称为一棵<strong>无向树</strong>，简称<strong>树</strong>。树有两个重要性质：一是树中任意两个顶点之间有且仅有一条路径；二是 $n$ 个顶点的树恰好有 $n-1$ 条边。</p><p><img src="/img/43Class-5/1.png"></p><p>我们可以采用上期介绍的 BFS 来遍历树。任意选中一个顶点作为起点，由于树中任意两个顶点之间有且仅有一条路径，我们可以按照到起点的路径长度从小到大排列每个顶点，从而把树的顶点分为若干层。此时若将每条边加上从上层指向下层的方向，我们就得到了一个<strong>有向根树</strong>，简称<strong>根树</strong>。</p><p><img src="/img/43Class-5/2.png"></p><p>在根树中，我们称一条路径为<strong>链路</strong>。入度为 $0$ 的顶点称为<strong>根节点</strong>，出度为 $0$ 的顶点称为<strong>叶节点</strong>，其余顶点称为<strong>内部节点</strong>；对于一条有向边 $(a,b)$，我们称 $a$ 是 $b$ 的<strong>父节点</strong>，$b$ 是 $a$ 的<strong>子节点</strong>。类似地，我们可以定义<strong>兄弟</strong>、<strong>堂兄弟</strong>、<strong>祖父</strong>、<strong>祖先</strong>、<strong>后代</strong>等概念。</p><p>对于根树中的每个节点，定义其<strong>深度</strong>为从根节点到该节点的路径长度，定义其<strong>高度</strong>为从该节点到其所有后代的最长路径长度。事实上，根树中的一个节点与其所有后代也构成了一棵根树，我们称其为该节点的<strong>子树</strong>。定义根树的高度为其根节点的高度。</p><p><img src="/img/43Class-5/3.png"></p><p>如果一棵根树中每个节点至多有 $k$ 个子节点，则称其为 <strong>$k$ 叉树</strong>；对于二叉树（即 $k&#x3D;2$ 的 $k$ 叉树），我们可以定义除叶节点外每个节点的<strong>左孩子</strong>与<strong>右孩子</strong>，并且可以定义<strong>满二叉树</strong>（除叶节点外每个节点都有两个子节点）、<strong>完全二叉树</strong>（除了最后一层外每层都满且不存在只有右孩子而没有左孩子的节点）、<strong>真二叉树</strong>（不存在只有一个孩子的节点）、<strong>平衡二叉树</strong>（任意节点的左右子树高度差不超过 $1$）等概念。</p><p><img src="/img/43Class-5/4.png"></p><p>更普遍地，对于一个有向无环图，如果不考虑其边的方向时，其也不存在环，我们称其为一个<strong>有向森林</strong>，有向森林中的每个弱连通分量称为一棵<strong>有向树</strong>。若一个有向树有且仅有一个入度为 $0$ 的节点且每个节点的入度不超过 $1$，则其就是前文所说的根树；其他有向树则称为<strong>有向无根树</strong>，简称<strong>无根树</strong>。</p><p><img src="/img/43Class-5/5.png"></p><p>无根树在数据结构中的应用不多，但在树论中极其重要，可以用于求解图中支撑树的数量，以及图的回路和割集。但其证明过程十分冗长，且需要用到大量线性代数和图论的知识，可以说是整个《离散数学（2）》中最复杂的部分。由于篇幅所限，此处就不展开了。感兴趣的同学欢迎选修《离散数学（2）》。</p><h2 id="二、树的表示与遍历"><a href="#二、树的表示与遍历" class="headerlink" title="二、树的表示与遍历"></a>二、树的表示与遍历</h2><p>根树主要有两种表示方法：<strong>父亲-孩子表示法</strong>和<strong>长子-兄弟表示法</strong>。</p><p>在父亲-孩子表示法中，每个节点存储其自身属性（一般指权值与颜色等）、指向其父节点的指针以及指向其所有子节点的指针数组。可以发现，这其实和有向图的邻接表类似。下面是一个例子：</p><p><img src="/img/43Class-5/6.png"></p><p>在长子-兄弟表示法中，每个节点存储其自身属性、指向其长子的指针以及指向其下一兄弟的指针。相较于父亲-孩子表示法，长子-兄弟表示法更节省空间。下面是一个例子：</p><p><img src="/img/43Class-5/7.png"></p><p>利用长子-兄弟表示法，我们可以将任何一棵根树转化为二叉树：只需要把长子看作左孩子，把下一兄弟看作右孩子即可。此外，二叉树也可以转化为多叉树：对二叉树中的每个节点，增加其到其左孩子的右孩子（及后续右孩子）的链路，再删除所有右链路即可。下面是一个例子：</p><p><img src="/img/43Class-5/8.png"></p><p>而对于森林，可以把森林中每棵树的根都看作兄弟，从而也可以转化为二叉树。因此，二叉树虽然是根树和森林的特殊情况，但其表达能力是相同的，且更简洁、计算效率更高。因此，在《数据结构》中，通常只研究二叉树。</p><p>二叉树有其自己的表示方法：<strong>顺序表示法</strong>。对于一个 $n$ 层的二叉树，我们可以先将其补全为完全二叉树，然后将其按照从上到下、从左到右的顺序编号。编完号后，再将补全的节点删除，我们就得到了原二叉树的顺序表示。下面是一个例子：</p><p><img src="/img/43Class-5/9.png"></p><p>但这种方法空间利用率较低，尤其是对于右孩子较多而左孩子较少的二叉树。因此在实际应用中，我们通常还是使用父亲-孩子表示法。</p><p>二叉树的遍历方法主要有三种：<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。前序遍历是先访问根节点，再访问左子树，最后访问右子树；中序遍历是先访问左子树，再访问根节点，最后访问右子树；后序遍历是先访问左子树，再访问右子树，最后访问根节点。事实上，这三种方法都是从上期介绍的 DFS 方法演化而来的。下面是基于父亲-孩子表示法的三种遍历的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123; <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果节点为空，直接返回</span><br>    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问根节点</span><br>    <span class="hljs-keyword">for</span> (Node* child : root-&gt;children) &#123; <span class="hljs-comment">// 遍历所有子节点</span><br>        <span class="hljs-built_in">PreOrder</span>(child); <span class="hljs-comment">// 递归访问子节点</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123; <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果节点为空，直接返回</span><br>    <span class="hljs-keyword">if</span> (!root-&gt;children.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 如果有子节点</span><br>        <span class="hljs-built_in">InOrder</span>(root-&gt;children[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 递归访问第一个子节点</span><br>    &#125;<br>    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问根节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; root-&gt;children.<span class="hljs-built_in">size</span>(); ++i) &#123; <span class="hljs-comment">// 遍历剩余子节点</span><br>        <span class="hljs-built_in">InOrder</span>(root-&gt;children[i]); <span class="hljs-comment">// 递归访问子节点</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123; <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果节点为空，直接返回</span><br>    <span class="hljs-keyword">for</span> (Node* child : root-&gt;children) &#123; <span class="hljs-comment">// 遍历所有子节点</span><br>        <span class="hljs-built_in">PostOrder</span>(child); <span class="hljs-comment">// 递归访问子节点</span><br>    &#125;<br>    cout &lt;&lt; root-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外，还可以仿照上期介绍的 BFS 方法，定义<strong>层序遍历</strong>：从根节点开始，先访问根节点，再访问其所有子节点，再访问其所有孙子节点。下面是基于父亲-孩子表示法的层序遍历的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123; <span class="hljs-comment">// 层序遍历</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果节点为空，直接返回</span><br>    queue&lt;Node*&gt; q; <span class="hljs-comment">// 创建一个队列</span><br>    q.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 将根节点入队</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 当队列不为空时</span><br>        Node* node = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首节点</span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 出队</span><br>        cout &lt;&lt; node-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问当前节点</span><br>        <span class="hljs-keyword">for</span> (Node* child : node-&gt;children) &#123; <span class="hljs-comment">// 遍历所有子节点</span><br>            q.<span class="hljs-built_in">push</span>(child); <span class="hljs-comment">// 将子节点入队</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果觉得看代码有些晦涩，下面是一个具体的例子：</p><p><img src="/img/43Class-5/10.png"></p><h2 id="三、树论算法简介"><a href="#三、树论算法简介" class="headerlink" title="三、树论算法简介"></a>三、树论算法简介</h2><h3 id="1-最优二叉树"><a href="#1-最优二叉树" class="headerlink" title="1. 最优二叉树"></a>1. 最优二叉树</h3><p>将一个完全二叉树的所有叶节点都赋予权重，我们称其为<strong>赋权二叉树</strong>。定义赋权二叉树的<strong>带权路径长度</strong>为其所有叶节点的权值与其深度的乘积之和。在叶节点个数以及它们对应的权值相同的情况下，构造出的所有赋权二叉树中带权路径长度最短的树即称为<strong>最优二叉树</strong>。最优二叉树通常采用 <strong>Huffman 算法</strong>构造。</p><p>Huffman 算法的基本思想是：每次从所有叶节点中选取权值最小的两个叶节点，将它们合并为一个新节点，并将新节点的权值设为这两个叶节点的权值之和，直到只剩下一个节点为止。下面是一个例子：</p><p><img src="/img/43Class-5/11.png"></p><p>最优二叉树的应用非常广泛，尤其是在数据压缩领域。它可以用于构造最优的前缀编码（即 Huffman 编码），使得编码后的数据量最小。Huffman 编码在《数据结构》课程中会详细介绍，此处就不展开了。</p><h3 id="2-最小支撑树"><a href="#2-最小支撑树" class="headerlink" title="2. 最小支撑树"></a>2. 最小支撑树</h3><p>支撑树是指无向图的无环连通支撑子图。最小支撑树就是一个图的所有支撑树中边权和最小的支撑树。最小支撑树有两种常用的算法：<strong>Prim 算法</strong>和 <strong>Kruskal 算法</strong>。</p><p>Prim 算法与上期介绍的 Dijkstra 算法有一些类似：都是从一个顶点开始，逐步扩展到其他顶点。具体地，Prim 算法从一个顶点开始，逐步将与当前支撑树相连的最小边加入支撑树，直到所有顶点都被包含在支撑树中。下面是一个例子：</p><p><img src="/img/43Class-5/12.png"></p><p>下面是基于邻接表的 Prim 算法的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; adj)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = adj.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 图的顶点数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 记录顶点是否被访问</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minEdge</span><span class="hljs-params">(n, INT_MAX)</span></span>; <span class="hljs-comment">// 记录每个顶点到支撑树的最小边权</span><br>    minEdge[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起始顶点到支撑树的边权为 0</span><br>    <span class="hljs-type">int</span> totalWeight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 支撑树的总边权</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 当前选中的顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; (u == <span class="hljs-number">-1</span> || minEdge[j] &lt; minEdge[u])) &#123;<br>                u = j; <span class="hljs-comment">// 找到未访问的最小边权顶点</span><br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记当前顶点为已访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : adj[u]) &#123; <span class="hljs-comment">// 遍历当前顶点的所有邻接顶点</span><br>            <span class="hljs-type">int</span> v = edge.first;<br>            <span class="hljs-type">int</span> weight = edge.second;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; weight &lt; minEdge[v]) &#123;<br>                minEdge[v] = weight; <span class="hljs-comment">// 更新邻接顶点到支撑树的最小边权</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kruskal 算法则更为直观：它从所有边中选取权值最小的边，如果加入该边后不会形成环（即该边的两个顶点不在同一个连通分量中），则将其加入支撑树，并将该边的两个顶点所在的连通分量合并，直到所有顶点都被包含在支撑树中。可见，Kruskal 算法执行过程中需要频繁进行“合并”和“查找”操作，这就需要使用一种叫做<strong>并查集</strong>的数据结构来高效地实现。</p><p>并查集的思想非常简单：我们将每个顶点看作一个独立的集合，初始时每个顶点都是一个单独的集合。每次合并两个集合时，我们只需要将其中一个集合的代表元素指向另一个集合的代表元素即可。查找操作则是沿着代表元素的指针一直向上查找，直到找到根节点为止。下面是并查集基本操作的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parent[x] != x) &#123;<br>        parent[x] = <span class="hljs-built_in">find</span>(parent[x]); <span class="hljs-comment">// 路径压缩</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x]; <span class="hljs-comment">// 返回根节点</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查找 x 的根节点</span><br>    <span class="hljs-type">int</span> rootY = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 查找 y 的根节点</span><br>    <span class="hljs-keyword">if</span> (rootX != rootY) &#123;<br>        parent[rootY] = rootX; <span class="hljs-comment">// 将 y 的根节点指向 x 的根节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于邻接表的 Kruskal 算法的<strong>伪代码</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; edges, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 按边权从小到大排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        parent[i] = i; <span class="hljs-comment">// 每个顶点的父节点指向自己</span><br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; mst; <span class="hljs-comment">// 存储最小支撑树的边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>        <span class="hljs-type">int</span> weight = edge.first; <span class="hljs-comment">// 边权</span><br>        <span class="hljs-type">int</span> u = edge.second.first; <span class="hljs-comment">// 边的起点</span><br>        <span class="hljs-type">int</span> v = edge.second.second; <span class="hljs-comment">// 边的终点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(u) != <span class="hljs-built_in">find</span>(v)) &#123; <span class="hljs-comment">// 如果 u 和 v 不在同一个连通分量中</span><br>            <span class="hljs-built_in">union</span>(u, v); <span class="hljs-comment">// 合并 u 和 v 的连通分量</span><br>            mst.<span class="hljs-built_in">push_back</span>(&#123;u, v&#125;); <span class="hljs-comment">// 将边加入最小支撑树</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、树的应用"><a href="#四、树的应用" class="headerlink" title="四、树的应用"></a>四、树的应用</h2><p>这里给出一道有趣的算法题：</p><blockquote><p>对于一个正权无向简单连通图，定义两点间某条路径的强度为路径上所有边权的最小值，定义两点间的距离为两点间所有路径强度的最大值。</p><p>如两点间的某条路径由 $3$ 条边组成，边权分别为 $2,3,5$，则该路径的强度为 $2$；若该两点间只有两条路径，且另外一条路径的强度是 $4$，则该两点间的距离为 $\max(2,4)&#x3D;4$。</p><p>请设计一个算法，求出该图的一个支撑子图，使其满足以下要求：（1）该支撑子图连通；（2）该支撑子图中两点间的最小距离最大；（3）在满足（1）（2）的条件下，总边数最少。</p><p>以下<strong>伪代码</strong>是该问题的一个可行解，采用了类似 $\mathrm{Kruskal}$ 的思想，请阅读并完成填空：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(n != parent[n]) &#123;<br>        ____________(<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    parent[x]=parent[y];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=edges.num;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=edges.num;j++)<br>            <span class="hljs-keyword">if</span>(____________(<span class="hljs-number">2</span>))<br>                <span class="hljs-built_in">swap</span>(edges[i], edges[j]);<br>    blocks_cnt=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=edges.num;i++)&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(edges[i].start);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(edges[i].end);<br>        <span class="hljs-keyword">if</span>(x != y) &#123;<br>            ____________(<span class="hljs-number">3</span>)<br>            blocks_cnt--;     <br>        &#125;<br>        <span class="hljs-keyword">if</span>(__________(<span class="hljs-number">4</span>))&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d&quot;</span>,__________(<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解法就不在此处直接给出了，感兴趣的同学可以尝试自己完成。这里给出一个提示：可以尝试证明，满足上述三个要求的支撑子图一定是原图的一棵支撑树。</p><p>《数据结构预备知识》系列推送就到此结束了。希望同学们能在本系列推送中有所收获，也祝同学们在接下来小学期的《程序设计实训》课程中一帆风顺。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第四讲 数据结构预备知识（上）</title>
    <link href="/43Class/43Class-4/"/>
    <url>/43Class/43Class-4/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第四讲，介绍了数据结构相关的图论知识。</p><span id="more"></span><p>笃实 43 班的同学们大家好。下学期大部分同学都将修读《数据结构》，但由于笃实书院教学计划将《离散数学（2）》放在了大二下学期，因此大部分同学可能还未接触过图论与树论相关的知识。为了帮助大家更好地学习《数据结构》，我们将介绍一些预备知识。由于篇幅所限，我们将内容分为上下两期，本期主要介绍图论，下期主要介绍树论。</p><h2 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h2><p>图是由顶点和边组成的集合，通常用 $G&#x3D;(V,E)$ 表示，其中 $V$ 是顶点集，$E$ 是边集。图可以是有向的或无向的，<strong>有向图</strong>中的边有方向，而<strong>无向图</strong>中的边没有方向；同时，也可以按边是否带有权值分为<strong>带权图</strong>和<strong>无权图</strong>。在无向图中，我们定义一个顶点的<strong>度数</strong>为与该顶点相连的边的数量。对于有向图，顶点的<strong>入度</strong>是指指向该顶点的边的数量，<strong>出度</strong>是指从该顶点出发的边的数量。</p><p><img src="/img/43Class-4/1.png"></p><p>如果一个<strong>无向图</strong>中既不带有从一个顶点指向其自身的边（即无自环），且任意两个顶点之间至多只有一条边（即无重边），则称之为<strong>简单无向图</strong>。若一个简单无向图中，任意两个顶点之间都有一条边，则称之为<strong>完全图</strong>。</p><p><img src="/img/43Class-4/2.png"></p><p>图的连通性在有向图和无向图上的定义略有不同：在<strong>无向图</strong>中，若两个顶点间存在一条路径，则称这两个顶点是连通的；若图中任意两个顶点都是连通的，则称该图是<strong>无向连通图</strong>。</p><p><img src="/img/43Class-4/3.png"></p><p>在<strong>有向图</strong>中，边存在方向。如果我们先不考虑边的方向（即把有向图看作无向图），此时若两个顶点连通，则称这两个顶点<strong>弱连通</strong>；如果考虑边的方向，此时若两个顶点间只存在从一个顶点到另一个顶点的路径而不存在反向路径，则称这两个顶点<strong>单向连通</strong>；如果两个方向的路径都存在，则称这两个顶点<strong>强连通</strong>。和无向图一样，我们可以定义<strong>有向弱连通图</strong>和<strong>有向强连通图</strong>。</p><p><img src="/img/43Class-4/4.png"></p><p>图是顶点和边的集合，既然集合里有子集的概念，图里自然也有子图的概念。子图是指从原图中选取部分顶点和边构成的图。若子图包含原图的所有顶点，则称之为<strong>支撑子图</strong>。</p><p><img src="/img/43Class-4/5.png"></p><p>在<strong>无向图</strong>中，若某个连通的子图是“极大”的（即不是任何连通子图的真子图），则称之为原图的一个<strong>连通支</strong>或<strong>连通分量</strong>。对于<strong>有向图</strong>，类似地，我们可以定义有向图的<strong>强连通分量</strong>。</p><p><img src="/img/43Class-4/6.png"></p><p>对每个无向图，我们都可以统计其连通支的个数。如果去除原图中的某条边后，图的连通支个数增加了，则称这条边为<strong>割边</strong>；如果去除某个顶点后，图的连通支个数增加了，则称这个顶点为<strong>割点</strong>。没有割点的极大连通子图称为一个<strong>点双连通分量</strong>；没有割边的极大连通子图称为一个<strong>边双连通分量</strong>。</p><p><img src="/img/43Class-4/7.png"></p><h2 id="二、图的表示与遍历"><a href="#二、图的表示与遍历" class="headerlink" title="二、图的表示与遍历"></a>二、图的表示与遍历</h2><p>图的表示方法有很多种，常见的有<strong>邻接矩阵</strong>和<strong>邻接表</strong>。</p><p>邻接矩阵是一个 $n \times n$ 的矩阵，其中 $n$ 是图的顶点数。若顶点 $i$ 和顶点 $j$ 之间存在边，则矩阵中对应位置的值为 $1$（或边的权值），否则为 $0$（或无穷大）。</p><p><img src="/img/43Class-4/8.png"></p><p>邻接表是一个数组，其中每个元素是一个链表或动态数组，表示与该顶点相连的所有顶点。相较于邻接矩阵，邻接表往往更节省空间，且便于访问某个顶点的邻接顶点，在进行图的遍历时更为高效，因此在实际应用中更为常用。</p><p><img src="/img/43Class-4/9.png"></p><p>图的遍历方法主要有两种：深度优先搜索（DFS）和广度优先搜索（BFS）。</p><p>深度优先搜索（DFS）是从一个顶点开始，沿着一条路径尽可能深入，直到无法继续为止，然后回溯到上一个顶点，继续探索其他路径。DFS 可以使用递归或栈来实现，下面是一个简单的基于邻接表的 DFS 遍历<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adj)</span> </span>&#123;<br>    visited[v] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记当前顶点为已访问</span><br>    cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问当前顶点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u : adj[v]) &#123; <span class="hljs-comment">// 遍历当前顶点的所有邻接顶点</span><br>        <span class="hljs-keyword">if</span> (!visited[u]) &#123; <span class="hljs-comment">// 如果邻接顶点未被访问</span><br>            <span class="hljs-built_in">DFS</span>(u, visited, adj); <span class="hljs-comment">// 递归访问邻接顶点</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>广度优先搜索（BFS）是从一个顶点开始，首先访问该顶点，然后访问所有与该顶点直接相连的顶点，再访问这些顶点的邻接顶点，以此类推，直到所有可达顶点都被访问。BFS 通常使用队列来实现，下面是一个简单的基于邻接表的 BFS 遍历<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adj)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 创建一个队列</span><br>    q.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 将起始顶点入队</span><br>    visited[start] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记起始顶点为已访问</span><br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 当队列不为空时</span><br>        <span class="hljs-type">int</span> v = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 获取队首元素</span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 出队</span><br>        cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 访问当前顶点</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u : adj[v]) &#123; <span class="hljs-comment">// 遍历当前顶点的所有邻接顶点</span><br>            <span class="hljs-keyword">if</span> (!visited[u]) &#123; <span class="hljs-comment">// 如果邻接顶点未被访问</span><br>                visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已访问</span><br>                q.<span class="hljs-built_in">push</span>(u); <span class="hljs-comment">// 将邻接顶点入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、图论经典问题"><a href="#三、图论经典问题" class="headerlink" title="三、图论经典问题"></a>三、图论经典问题</h2><p>图论中有许多经典问题，以下是一些常见的图论问题及其简要介绍：</p><h3 id="1-欧拉路径与欧拉回路"><a href="#1-欧拉路径与欧拉回路" class="headerlink" title="1. 欧拉路径与欧拉回路"></a>1. 欧拉路径与欧拉回路</h3><p>欧拉路径是指经过图中<strong>每条边恰好一次</strong>的<strong>路径</strong>；欧拉回路是指经过图中每条边恰好一次的<strong>回路</strong>。带有欧拉回路的图称为<strong>欧拉图</strong>，而带有欧拉路径但不带有欧拉回路的图称为<strong>半欧拉图</strong>。</p><p>一个无向图存在欧拉回路的充要条件是所有顶点的度数都是偶数；存在欧拉路径的充要条件是至多有两个顶点的度数为奇数。一个有向图存在欧拉回路的充要条件是每个顶点的入度等于出度；存在欧拉路径的充要条件是至多有一个顶点的出度比入度多 1，至多有一个顶点的入度比出度多 1。</p><p><img src="/img/43Class-4/10.png"></p><h3 id="2-哈密顿路径与哈密顿回路"><a href="#2-哈密顿路径与哈密顿回路" class="headerlink" title="2. 哈密顿路径与哈密顿回路"></a>2. 哈密顿路径与哈密顿回路</h3><p>哈密顿路径是指经过图中<strong>每个顶点恰好一次</strong>的<strong>路径</strong>；哈密顿回路是指经过图中每个顶点恰好一次的<strong>回路</strong>。带有哈密顿回路的图称为<strong>哈密顿图</strong>，而带有哈密顿路径但不带有哈密顿回路的图称为<strong>半哈密顿图</strong>。</p><p>一个图是否存在哈密顿路径或哈密顿回路是一个 NP 完全问题，没有已知的多项式时间算法可以解决，但是有一些充分或必要条件可以用于判定，此处就不介绍了。但一些特殊的图（如完全图）总是存在哈密顿回路。</p><p><img src="/img/43Class-4/11.png"></p><h3 id="3-旅行商问题（TSP）"><a href="#3-旅行商问题（TSP）" class="headerlink" title="3. 旅行商问题（TSP）"></a>3. 旅行商问题（TSP）</h3><p>旅行商问题描述为：给定一组城市和它们之间的距离，如何选择一条道路使得商人每个城市走一遍后回到起点，且所走路径最短。用图论的语言表述就是：给定一个<strong>带权完全图</strong>，求一条哈密顿回路，使得路径长度最小。</p><p>这是一个经典的 NP 完全问题，通常使用近似算法求解。对于小规模的图，可以采用暴力搜索或分支定界法求得精确解。</p><h3 id="4-中国邮递员问题"><a href="#4-中国邮递员问题" class="headerlink" title="4. 中国邮递员问题"></a>4. 中国邮递员问题</h3><p>中国邮递员问题也是一个 NP 完全问题，描述为：邮递员从邮局出发，走遍辖区内所有的街道至少一次（可以重复），最后回到邮局。要走怎样的路线全程才最短？用图论的语言表述就是：给定一个图，要求找到一个回路，使得每条边都被访问<strong>至少一次</strong>，并且路径长度最小。</p><p>显然，对于一个欧拉图，最优解就是欧拉回路；对于其他图，可以通过添加一些边使其变为欧拉图，然后求解欧拉回路。</p><h3 id="5-二分图匹配问题"><a href="#5-二分图匹配问题" class="headerlink" title="5. 二分图匹配问题"></a>5. 二分图匹配问题</h3><p>如果一个图的顶点集可以被分为两个不相交的子集，使得图中的每条边都连接这两个子集中的顶点，则称该图为<strong>二分图</strong>。一个图是二分图的充要条件是它不包含奇数长度的环（奇圈）。和完全图类似，我们可以定义<strong>完全二分图</strong>，即两个子集中的每个顶点都与另一个子集中的每个顶点相连。</p><p><img src="/img/43Class-4/12.png"></p><p>二分图匹配问题是指在一个二分图中，如何选择一些边，使得这些边所连的每个顶点至多被选中一次，并且所选边的数量最大。如果存在一个匹配，使得每个顶点都被选中，则称该匹配为<strong>完美匹配</strong>。一个二分图 $(V_1,V_2,E)$ 有完美匹配当且仅当 $|V_1|&#x3D;|V_2|$ 且 $V_1$ 中任意 $k$ 个顶点至少与 $V_2$ 中的 $k$ 个顶点相连。</p><p><img src="/img/43Class-4/13.png"></p><h3 id="6-图的平面性问题"><a href="#6-图的平面性问题" class="headerlink" title="6. 图的平面性问题"></a>6. 图的平面性问题</h3><p>图的平面性是指一个图是否可以在平面上绘制而不出现边的交叉。平面图有一些特殊的定义：由平面图的若干边所构成的一个“极小”区域（即区域内不含任何顶点或边）称为一个<strong>面</strong>。平面图有且仅有一个面积无穷的面，称为<strong>外部面</strong>，其他的面称为<strong>内部面</strong>。平面图的顶点、边和面的个数分别用 $V$、$E$ 和 $F$ 表示。平面图还有其<strong>对偶图</strong>：将平面图的每个面作为顶点，每条边作为连接两个面顶点的边。</p><p><img src="/img/43Class-4/14.png"></p><p>平面图有许多有趣的性质，如欧拉公式：$V - E + F &#x3D; p(G)+1$，其中 $p(G)$ 是图的连通支个数。当图连通时，欧拉公式简化为 $V - E + F &#x3D; 2$，可能有同学会注意到，这个公式与多面体的欧拉公式完全相同。事实上，平面图可以看作是多面体的一个投影。</p><p>图的平面性有表述较为简单的充要条件：一个图是可平面的当且仅当它不包含 $K_5$（五个顶点的完全图）或 $K_{3,3}$（两边各三个顶点的完全二分图）作为子图。但其判定算法仍然是 NP 完全的。</p><h3 id="7-图的着色问题"><a href="#7-图的着色问题" class="headerlink" title="7. 图的着色问题"></a>7. 图的着色问题</h3><p>图的着色分为<strong>点着色</strong>、<strong>边着色</strong>和平面图的<strong>面着色</strong>。点着色是指给图的每个顶点分配一个颜色，使得相邻的顶点颜色不同；边着色是指给图的每条边分配一个颜色，使得相邻的边（即与同一个点相连）颜色不同；面着色是指给平面图的每个面分配一个颜色，使得相邻的面（即有公共边界）颜色不同。</p><p><img src="/img/43Class-4/15.png"></p><p>对于点着色问题，如果一个图既不是完全图也不是奇圈，则它的点色数（即最少需要多少种颜色才能使得相邻顶点颜色不同）不超过 $\Delta$，其中 $\Delta$ 是图中度数最大的顶点的度数。</p><p>对于边着色问题，我们可以在每条边上设置一个顶点；如果原图中两条边与同一个顶点相连，则在新图中将这两条边所对应的顶点连起来。这样，我们就将边着色问题转化为了点着色问题。此外，边着色也有自己的特殊结论：对一个<strong>简单图</strong>，其边色数只能是 $\Delta$ 或 $\Delta + 1$。但哪些图的边色数为 $\Delta$，哪些图的边色数为 $\Delta + 1$，至今仍是没有解决的问题。</p><p>对于平面图的面着色问题，则有著名的四色定理：任何平面图的面色数不超过 4。</p><h2 id="四、图论算法简介"><a href="#四、图论算法简介" class="headerlink" title="四、图论算法简介"></a>四、图论算法简介</h2><h3 id="1-最短路径"><a href="#1-最短路径" class="headerlink" title="1. 最短路径"></a>1. 最短路径</h3><p>最短路径问题是图论中一个非常重要的问题，主要有三种常用的算法：Dijkstra 算法、Bellman-Ford 算法和 Floyd-Warshall 算法。</p><p>Dijkstra 算法用于求解<strong>单源</strong>最短路径问题。它的基本思路是按路径长度递增的次序产生最短路径。其正确性证明较为复杂，但计算步骤一看就懂。下面是一个例子：</p><p><img src="/img/43Class-4/16.png"></p><p>下面是 Dijkstra 算法的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 记录顶点是否已访问</span><br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点到自身的距离为 0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// 重复 n-1 次</span><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 找到未访问的最小距离顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; (u == <span class="hljs-number">-1</span> || dist[j] &lt; dist[u])) &#123;<br>                u = j;<br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记顶点 u 为已访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123; <span class="hljs-comment">// 更新邻接顶点的距离</span><br>            <span class="hljs-keyword">if</span> (graph[u][v] != INT_MAX &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + graph[u][v];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dijkstra 算法的时间复杂度为 $O(V^2)$，其中 $V$ 是顶点数。如果使用优先队列优化，时间复杂度还能继续降低。但它只能处理非负权边的图（想想为什么？），在处理带有负权边的图时，我们需要使用 Bellman-Ford 算法。</p><p>Bellman-Ford 算法的基本思路是根据路径长度从 $0$ 到 $|V|-1$，逐步迭代（更新后继节点）得到在当前路径长度范围内起点到各点的最短路，并最终得到起点到各点的最短路。下面是一个例子：</p><p><img src="/img/43Class-4/17.png"></p><p>下面是 Bellman-Ford 算法的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BellmanFord</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    dist[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点到自身的距离为 0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// 重复 n-1 次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; n; ++u) &#123; <span class="hljs-comment">// 遍历所有顶点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123; <span class="hljs-comment">// 遍历所有边</span><br>                <span class="hljs-keyword">if</span> (graph[u][v] != INT_MAX &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;<br>                    dist[v] = dist[u] + graph[u][v]; <span class="hljs-comment">// 松弛操作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Bellman-Ford 算法的时间复杂度为 $O(VE)$，其中 $E$ 是边数。可见 Bellman-Ford 算法的效率较低，尤其是在稠密图中，但它比 Dijkstra 算法更通用。</p><p>如果需要求解<strong>所有顶点对</strong>的最短路径问题，当然可以使用 Dijkstra 算法或 Bellman-Ford 算法对每个顶点进行一次，但我们有一个更简单的算法：Floyd-Warshall 算法。它的基本思路是逐步试着在原直接路径中增加中间节点，若加入中间点后路径变短，则修改之，直到所有节点试探完毕。它可以处理带有负权边的图。下面是 Floyd-Warshall 算法的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FloydWarshall</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    dist = graph; <span class="hljs-comment">// 初始化距离矩阵</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123; <span class="hljs-comment">// 遍历所有中间节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历所有起点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123; <span class="hljs-comment">// 遍历所有终点</span><br>                <span class="hljs-keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp;<br>                    dist[i][j] &gt; dist[i][k] + dist[k][j]) &#123;<br>                    dist[i][j] = dist[i][k] + dist[k][j]; <span class="hljs-comment">// 松弛操作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd-Warshall 算法的时间复杂度为 $O(V^3)$，其中 $V$ 是顶点数。对于非负边权图，其效率与运行 $V$ 次 Dijkstra 算法相当，但其代码实现更简单；对于带有负边权的图，其效率高于运行 $V$ 次 Bellman-Ford 算法。</p><h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2. 拓扑排序"></a>2. 拓扑排序</h3><p>拓扑排序是指对一个<strong>有向无环图</strong>进行排序，使得对于每一条边 $(u, v)$，顶点 $u$ 在排序中出现在顶点 $v$ 之前。拓扑排序的基本思路是：首先找到一个入度为 0 的顶点，将其加入排序结果中；然后将该顶点从图中删除，并更新其他顶点的入度；重复上述过程，直到所有顶点都被处理。下面是一个基于栈的拓扑排序的<strong>伪代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; result)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个顶点的入度</span><br>    <span class="hljs-comment">// 计算每个顶点的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; n; ++u) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            inDegree[v]++;<br>        &#125;<br>    &#125;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s; <span class="hljs-comment">// 使用栈来存储入度为 0 的顶点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = s.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 获取栈顶元素</span><br>        s.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">// 将顶点加入结果</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123; <span class="hljs-comment">// 遍历所有邻接顶点</span><br>            inDegree[v]--; <span class="hljs-comment">// 更新入度</span><br>            <span class="hljs-keyword">if</span> (inDegree[v] == <span class="hljs-number">0</span>) &#123;<br>                s.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">// 如果入度为 0，则将其加入栈中</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓扑排序的一个重要应用是<strong>关键路径问题</strong>。关键路径问题是指：对于一个由若干个任务组成的项目，每个任务有各自的耗时，且任务之间可能存在依赖关系（即某些任务必须在其他任务完成后才能开始），如何安排这些任务的开始时间，使得整个项目的完成时间最短。如果将其建模为一个有向无环图，则整个项目的最短完成时间就是图中<strong>最长的路径长度</strong>。将图进行拓扑排序后，我们可以从起点开始，依次计算每个顶点的最早开始时间，从而得到整个项目的最短完成时间。下面是一个例子，图中 $N$ 是虚拟节点，表示项目的终点。</p><p><img src="/img/43Class-4/18.png"></p><h2 id="五、图的应用"><a href="#五、图的应用" class="headerlink" title="五、图的应用"></a>五、图的应用</h2><p>我们来看一个有趣的问题：</p><blockquote><p>集合 $A&#x3D;\{1,2,3,4,5,6,7,8\}$，定义 $M&#x3D;\{(x,y)|x\in A,y\in A\}$。从 $M$ 中选出一些点排成一列：$(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)$。如果对于任意相邻两个点 $(x_i,y_i),(x_{i+1},y_{i+1})$ 满足以下等式 $\begin{cases} |x_{i+1}-x_i|&#x3D;3\\|y_{i+1}-y_i|&#x3D;4 \end{cases}$ 或 $\begin{cases} |x_{i+1}-x_i|&#x3D;4\\|y_{i+1}-y_i|&#x3D;3 \end{cases}$，那么就称该序列为一条 $k$ 列。证明：$M$ 中所有元素的任意排列都不构成 $k$ 列。</p></blockquote><p>如果我们把 $M$ 看成一个 $8\times 8$ 的棋盘，那么题目条件其实是在说，如果有一匹马可以按 $3\times 4$ 的方式跳，那么不存在一条路径，使得马可以从一个点出发，经过棋盘上的每个格子恰好一次。这其实就是前面所说的<strong>哈密顿路径</strong>问题。</p><p>实际上，这是今年高考数学北京卷的压轴大题！可见，图论的实际应用非常广泛。不仅如此，图论还可以用来解决很多实际问题，如网络流、社交网络分析、地图导航等。</p><p>希望同学们通过本期的内容，能够对图论有一个初步的了解，为后续学习《数据结构》打下基础。下期我们将介绍树论相关的知识，希望大家继续关注肆叁小灶，期待下期内容的发布！</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学(2) 期末真题</title>
    <link href="/Others/LSSXQM/"/>
    <url>/Others/LSSXQM/</url>
    
    <content type="html"><![CDATA[<p>2025春 离散数学(2) 周旻 期末考试回忆版</p><span id="more"></span><h2 id="一、选择题-4pts"><a href="#一、选择题-4pts" class="headerlink" title="一、选择题 (4pts)"></a>一、选择题 (4pts)</h2><ol><li><p>(2pts) 以下关于群的说法中，正确的是：<br> A. 存在无限群，其只有有限个子群<br> B. 存在群 $G$ 是其两个真子群的并<br> C. 所有元素的阶都是有限的群必为有限群<br> D. 存在无限群，其有且仅有两个有限阶元素</p></li><li><p>(2pts) 以下关于置换的说法中，错误的是：<br> A. 轮换 $(i_1 i_2 \cdots i_k)$ 是偶置换当且仅当 $k$ 是偶数<br> B. 置换 $\sigma$ 是偶置换当且仅当 $\tau^{-1}\sigma\tau$ 是偶置换<br> C. 轮换 $(i_1 i_2 \cdots i_k)$ 可表示为 $(i_1 i_2)(i_2 i_3)\cdots(i_{k-1} i_k)$<br> D. 任意两个偶置换的乘积仍然是偶置换</p></li></ol><h2 id="二、填空题-16pts"><a href="#二、填空题-16pts" class="headerlink" title="二、填空题 (16pts)"></a>二、填空题 (16pts)</h2><ol start="3"><li><p>(2pts) 对称群 $S_8$ 中，不相交轮换乘积表示形式为 $(abc)(def)(gh)$ 的元素共有 ____ 个。</p></li><li><p>(2pts) 将置换 $\begin{pmatrix} 1&amp;2&amp;3&amp;4\\4&amp;3&amp;1&amp;2\end{pmatrix}\circ\begin{pmatrix} 1&amp;2&amp;3&amp;4\\3&amp;1&amp;4&amp;2\end{pmatrix}$ 表示成不相交轮换的乘积形式：________。</p></li><li><p>(2pts) 已知一棵树中，有 $1$ 个 $5$ 度顶点，$2$ 个 $4$ 度顶点，$3$ 个 $3$ 度顶点，若干个 $2$ 度顶点，则这棵树有 ____ 个叶子节点。</p></li><li><p>(2pts) 点数为 $8$ 的平面自对偶图的边数为 ____。</p></li><li><p>(4pts) 完全二分图 $K_{r,s}(r\geq s)$ 中，两两不相关的边最多有 ____ 条（两条边相关当且仅当它们有公共顶点）；该二分图是哈密顿图的充要条件是 ________。</p></li><li><p>(4pts) 下图 ____ （是&#x2F;不是）平面图，简述原因：____________。</p></li></ol><p><img src="/img/LSSXQM/1.png"></p><h2 id="三、建模题-32pts"><a href="#三、建模题-32pts" class="headerlink" title="三、建模题 (32pts)"></a>三、建模题 (32pts)</h2><ol start="9"><li>(8pts) 如下图所示，$A$ 从顶点 $v_2$ 出发，$B$ 从顶点 $v_1$ 出发，要求两人遍历完所有边至少一次后到达终点 $v_3$，谁到达更快谁就胜利。假设两人经过同一条边的时间相同，请问谁有必胜策略？</li></ol><p><img src="/img/LSSXQM/2.png"></p><ol start="10"><li><p>(8pts) 有 $5$ 个字符串 $bc,ed,ac,bd,abc$，能够用其中的一个字母代表该字符串并且不产生混淆？</p></li><li><p>(8pts) 有 $6$ 种货物各 $3$ 件，现有 $3$ 辆卡车，分别能装 $5,6,7$ 件货物，但每辆卡车每种货物最多装一件，能否将所有货物装上卡车？</p></li><li><p>(8pts) 利用 $PT$ 图求解下列关键路径问题，并给出每项工序的最晚启动时间。</p></li></ol><p><img src="/img/LSSXQM/3.png"></p><h2 id="四、证明题-38pts"><a href="#四、证明题-38pts" class="headerlink" title="四、证明题 (38pts)"></a>四、证明题 (38pts)</h2><ol start="13"><li>(4pts) 证明：下图中没有包含奇数条边的回路。</li></ol><p><img src="/img/LSSXQM/4.png"></p><ol start="14"><li><p>(6pts) 证明：若平面图中不存在边数 $\le 5$ 的回路，则至少有一个点的度数不超过 $2$。</p></li><li><p>(6pts) $n$ 个人中，设任意两人合在一起能认识其余 $n-2$ 个人，证明：他们可以站成一圈，使相邻者认识。</p></li><li><p>(6pts) 给出边权为正的无向连通图 $G&#x3D;(V,E)$，并定义两点间的距离 $d(v_i,v_j)$ 为两点间最长的初级道路的长度。设 $G$ 中距离最大的两个点为 $s,t$，证明：对于任意 $v\in V$，有 $\displaystyle 2\cdot \max_{u\in V} d(u,v)\ge d(s,t)$。</p></li><li><p>(6pts) 定义映射 $T:A\to B$，其中 $(B,\times)$ 是群，定义映射乘法 $T_1\circ T_2(x)&#x3D;T_1(x)\times T_2(x)$，证明：所有从 $A$ 到 $B$ 的映射关于 $\circ$ 构成群。</p></li><li><p>(6pts) 证明：对称群 $S_3$ 是最小的非交换群。（提示：证明阶数不大于 $5$ 的群都是交换群）</p></li><li><p>(4pts) 证明：有限 $\mathrm{Abel}$ 群 $G$ 中，$\displaystyle \prod_{g\in G} g&#x3D;\prod_{a\in G,a^2&#x3D;e} a$，其中 $e$ 是 $G$ 的幺元。</p></li></ol><h2 id="五、算法题-10pts"><a href="#五、算法题-10pts" class="headerlink" title="五、算法题 (10pts)"></a>五、算法题 (10pts)</h2><p>对于一个正权无向简单连通图，定义两点间某条路径的强度为路径上所有边权的最小值，定义两点间的距离为两点间所有路径强度的最大值。</p><p>如两点间的某条路径由 $3$ 条边组成，边权分别为 $2,3,5$，则该路径的强度为 $2$；若该两点间只有两条路径，且另外一条路径的强度是 $4$，则该两点间的距离为 $\max(2,4)&#x3D;4$。</p><p>请设计一个算法，求出该图的一个支撑子图，使其满足以下要求：（1）该支撑子图连通；（2）该支撑子图中两点间的最小距离最大；（3）在满足（1）（2）的条件下，总边数最少。</p><ol start="20"><li><p>(3pts) 证明：满足上述三个要求的支撑子图一定是原图的一棵支撑树。</p></li><li><p>(5pts) 以下伪代码是该问题的一个可行解，采用了类似 $\mathrm{Kruskal}$ 的思想，请阅读并完成填空：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(n != parent[n]) &#123;<br>        ____________(<span class="hljs-number">21.1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    parent[x]=parent[y];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=edges.num;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=edges.num;j++)<br>            <span class="hljs-keyword">if</span>(____________(<span class="hljs-number">21.2</span>))<br>                <span class="hljs-built_in">swap</span>(edges[i], edges[j]);<br>    blocks_cnt=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=edges.num;i++)&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(edges[i].start);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(edges[i].end);<br>        <span class="hljs-keyword">if</span>(x != y) &#123;<br>            ____________(<span class="hljs-number">21.3</span>)<br>            blocks_cnt--;     <br>        &#125;<br>        <span class="hljs-keyword">if</span>(__________(<span class="hljs-number">21.4</span>))&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d&quot;</span>,__________(<span class="hljs-number">21.5</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="22"><li>(2pts) 简要证明上述算法的正确性。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CheatSheet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分A(2)</title>
    <link href="/25Spring/Calculus-A2/"/>
    <url>/25Spring/Calculus-A2/</url>
    
    <content type="html"><![CDATA[<p>大一下学期微积分A(2)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、多元微分"><a href="#一、多元微分" class="headerlink" title="一、多元微分"></a>一、多元微分</h2><h3 id="1-赋范线性空间"><a href="#1-赋范线性空间" class="headerlink" title="1. 赋范线性空间"></a>1. 赋范线性空间</h3><ol><li>$\mathbb R^n$ 中非空的道路连通的开集称为开区域，<strong>开区域的闭包</strong>称为闭区域</li><li>道路联通的闭集<strong>不一定</strong>是闭区域</li><li>凸区域：$\forall x,y\in\Omega,\lambda x+(1-\lambda)y\in\Omega$</li></ol><h3 id="2-极限与连续"><a href="#2-极限与连续" class="headerlink" title="2. 极限与连续"></a>2. 极限与连续</h3><ol><li>若 $x_0$ 是 $\Omega$ 的孤立点，则 $f$ 在 $x_0$ 处连续</li><li>在<strong>开区域</strong>中定义的初等函数处处连续</li><li>$|f(x)|\le M|g(x)|$，则 $f(x)&#x3D;O(g(x))\Leftrightarrow g(x)&#x3D;\Omega(f(x))$</li><li>$f$ 为连续函数当且仅当开集的原像为开集</li></ol><h3 id="3-导数与微分"><a href="#3-导数与微分" class="headerlink" title="3. 导数与微分"></a>3. 导数与微分</h3><ol><li>不可微时即使偏导函数都存在也不存在梯度</li><li>隐函数定理(1)：$\frac{\partial F}{\partial y}(x_0,y_0)$ 可逆 $\Rightarrow \frac{\partial y}{\partial x}&#x3D;-(\frac{\partial F}{\partial y})^{-1}\frac{\partial F}{\partial x}$</li><li>隐函数定理(2)：$\frac{\partial y}{\partial x_i}&#x3D;-\frac{\frac{\partial F}{\partial x_i}}{\frac{\partial F}{\partial y}}$</li><li>逆映射定理：$J(f)|_{x_0}$ 可逆 $\Rightarrow J(f^{-1})&#x3D;(J(f))^{-1}$</li></ol><h3 id="4-Taylor-公式"><a href="#4-Taylor-公式" class="headerlink" title="4. Taylor 公式"></a>4. Taylor 公式</h3><ol><li>$\displaystyle f(x)&#x3D;\sum_{k&#x3D;0}^{n}\frac{1}{k!}(h_1\frac{\partial}{\partial x_1}+h_2\frac{\partial}{\partial x_2}+\cdots+h_m\frac{\partial}{\partial x_m})^kf(x_0)+o(|x-x_0|^n)$</li><li>$f(x)&#x3D;f(x_0)+J_f(x_0)\cdot(x-x_0)+\frac{1}{2}(x-x_0)^T H_f(x_0)(x-x_0)+o(||x-x_0||^2)$</li></ol><h3 id="5-空间曲线与曲面"><a href="#5-空间曲线与曲面" class="headerlink" title="5. 空间曲线与曲面"></a>5. 空间曲线与曲面</h3><ol><li>详见<a href="https://sqzr2319.github.io/LinearAlgebra-1">线性代数(1)</a></li><li>$z&#x3D;f(x,y)$ 法向量：$(-f^{\prime}x,-f^{\prime}y,1)$</li><li>$F(x,y,z)&#x3D;0$ 法向量：$\nabla F$</li></ol><h3 id="6-无条件极值与条件极值"><a href="#6-无条件极值与条件极值" class="headerlink" title="6. 无条件极值与条件极值"></a>6. 无条件极值与条件极值</h3><ol><li>驻点 $+$ $\mathrm{Hesse}$ 矩阵正定或负定 $\Rightarrow$ 无条件极值（反之不成立）</li><li>拉乘求得的解一定是条件最值但不一定是极值（需验算 $\mathrm{Hesse}$ 矩阵）</li><li>存在函数 $f(x,y)&#x3D;x^2+y^2(1-x)^3$ 使得函数在 $\mathbb R^2$ 上一阶连续可微且存在唯一极值点，但该极值点不是最值点</li></ol><h3 id="7-例题"><a href="#7-例题" class="headerlink" title="7. 例题"></a>7. 例题</h3><ol><li>$(2021)$ 已知函数 $f(x,y)$ 在 $(1,1)$ 处可微，且 $f(1,1)&#x3D;1,f^{\prime}_x(1,1)&#x3D;2,f^{\prime}_y(1,1)&#x3D;3$，设 $g(x)&#x3D;f(x,f(x,x))$，求 $g^{\prime}(1)$</li><li>$(2021)$ 已知 $(axy^3-y^2\cos x)\mathrm{d}x+(1+by\sin x+3x^2y^2)\mathrm{d}y$ 为某一函数 $f(x,y)$ 的全微分，求 $a,b$ 的值及 $f(x,y)$</li><li>$(2023)$ 设函数 $f(x,y)$ 在 $\mathbb R^2$ 上二次连续可微，对 $\forall \theta \in \mathbb R$，令 $g_\theta(t)&#x3D;f(t\cos\theta,t\sin\theta)$，假设 $\frac{\mathrm{d}g_\theta(t)}{\mathrm{d}t}\vert_{t&#x3D;0}&#x3D;0$ 且 $\frac{\mathrm{d}^2g_\theta(t)}{\mathrm{d}t^2}\vert_{t&#x3D;0}\gt 0,\forall \theta \in \mathbb R$，证明函数 $f(x,y)$ 在点 $(0,0)$ 处取得极小值</li><li>$(2023)$ 根据隐函数定理，证明方程组 $\begin{cases}x^3+y^3&#x3D;2z^3\\x+y+z&#x3D;3\end{cases}$ 在点 $(1,1,1)$ 附近确定了两个 $C^{\infty}$ 类隐函数 $y&#x3D;y(x),z&#x3D;z(x)$，并证明隐函数 $z&#x3D;z(x)$ 在 $x&#x3D;1$ 处取得极值</li><li>$(2024)$ 设可微函数 $u(x,y)$ 满足 $u(x,x^2)&#x3D;1$ 且 $\frac{\partial u}{\partial x}(x,x^2)&#x3D;x$，求 $\frac{\partial u}{\partial y}(x,x^2)$</li><li>$(2023)$ 已知椭球面 $\frac{x^2}{8}+\frac{y^2}{4}+\frac{z^2}{2}&#x3D;1$ 与平面 $x+2y+2z&#x3D;0$ 的交线是椭圆，其在 $Oxy$ 平面上的投影曲线 $\Tau$ 也是椭圆，求 $\Tau$ 的四个顶点坐标</li><li>$(3.15)$ 在方程 $(xy+z)\frac{\partial z}{\partial x}+(1-y^2)\frac{\partial z}{\partial y}&#x3D;x+yz$ 中作代换 $u&#x3D;yz-x,v&#x3D;xz-y,w&#x3D;xy-z$，其中视 $w$ 是 $u,v$ 的函数，求代换后的方程</li><li>$(3.26)$ 曲线 $S$ 由方程 $ax+by+cz&#x3D;G(x^2+y^2+z^2)$ 确定，试证明：曲线 $S$ 上任一点的法线与某定直线相交</li><li>$(3.27)$ 求两曲面 $F(x,y,z)&#x3D;0$ 和 $G(x,y,z)&#x3D;0$ 的交线在 $xy$ 平面上的投影曲线的切线方程</li><li>$(4.34)$ 证明：椭球面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}&#x3D;1$ 与平面 $Ax+By+Cz&#x3D;0$ 相交所截的椭圆面积为 $S&#x3D;\pi abc\sqrt{\frac{A^2+B^2+C^2}{A^2a^2+B^2b^2+C^2c^2}}$</li></ol><h3 id="8-证明题"><a href="#8-证明题" class="headerlink" title="8. 证明题"></a>8. 证明题</h3><ol><li>$(2021)$ 已知函数 $f(x,y)$ 对每个变量 $x,y$ 分别连续，且对每个固定的 $x$，函数 $f(x,y)$ 对 $y$ 单调，证明：$f(x,y)$ 作为二元函数是连续函数</li><li>$(2023)$ 对在 $\mathbb R^2$ 上连续可微的函数 $g(x,y)$，假设曲线 $\{(x,y)\in \mathbb R^2|g(x,y)&#x3D;0\}$ 具有无穷大符号 $\infty$ 的形状，问函数 $g(x,y)$ 在 $\mathbb R^2$ 上至少有多少个驻点？并证明你的结论。</li><li>$(2024)$ 设 $D\subset\mathbb R^2$ 是一个非空有界闭区域，$f$ 是 $D$ 上的连续函数，证明：至多只有一个函数 $u(x,y)$ 在 $D$ 上连续，在 $D$ 的内部 $\mathring D$ 为 $C^2$ 类，且满足 $\begin{cases} u^{\prime\prime}_{xx}+u^{\prime\prime}_{yy}&#x3D;e^u,(x,y)\in \mathring D\\u&#x3D;f,(x,y) \in \partial D\end{cases}$</li><li>$(2024)$ 设 $K$ 是 $\mathbb R^k$ 的非空有界闭子集，函数 $f:\mathbb R^m\times K\to \mathbb R$ 连续，记 $\displaystyle g(\mathrm{x})&#x3D;\min_{\mathrm{y}\in K}f(\mathrm{x},\mathrm{y})$，证明：$g:\mathbb R^m\to \mathbb R$ 连续</li><li>$(2.12)$ 设 $\frac{\partial f}{\partial x}(x_0,y_0)$ 存在，$\frac{\partial f}{\partial y}(x,y)$ 连续，证明：$f(x,y)$ 在点 $(x_0,y_0)$ 处可微</li><li>$(3.11)$ 设 $u&#x3D;f(z)$，其中 $z$ 是由方程 $z&#x3D;x+y\varphi(z)$ 所定义的变量为 $x,y$ 的隐函数，求证：$\displaystyle \frac{\partial^n u}{\partial y^n}&#x3D;\frac{\partial^{n-1}}{\partial x^{n-1}}\left((\varphi(z))^n\frac{\partial u}{\partial x}\right)$，其中 $\varphi(z)$ 无穷次可微</li><li>$(4.11)$ $f$ 在 $\mathbb R^2$ 上一阶连续可微，且 $\forall (x,y)\neq (0,0)$，有 $xf^{\prime}_x(x,y)+yf^{\prime}_y(x,y)\gt 0$，证明：原点是 $f$ 的唯一极小值点，且 $\displaystyle \lim_{(x,y)\to (0,0)}\frac{f(x,y)-f(0,0)}{\sqrt{x^2+y^2}}&#x3D;0$</li><li>$(4.13)$ 已知 $D&#x3D;\{(x,y):0\lt x\lt 1,0\lt y\lt 1\},f(x,y)&#x3D;ax^2+bxy+cy^2+dx+ey$，且 $\forall (x,y)\in \partial D$，有 $f(x,y)\le 0$，证明：$\forall (x,y)\in D$，有 $f(x,y)\le 0$</li></ol><h2 id="二、含参积分"><a href="#二、含参积分" class="headerlink" title="二、含参积分"></a>二、含参积分</h2><h3 id="1-含参定积分的性质（参数范围为有限闭区间）"><a href="#1-含参定积分的性质（参数范围为有限闭区间）" class="headerlink" title="1. 含参定积分的性质（参数范围为有限闭区间）"></a>1. 含参定积分的性质（参数范围为<strong>有限闭区间</strong>）</h3><ol><li>连续、可积：$f(x,y)$ 在 $[a,b]\times [\alpha,\beta]$ 上连续</li><li>可微：$f(x,y),f^{\prime}_y(x,y)$ 在 $[a,b]\times [\alpha,\beta]$ 上连续</li><li>可微的计算：$\displaystyle \frac{\mathrm{d}}{\mathrm{d}y}\int_{\alpha(y)}^{\beta(y)} f(x,y)\mathrm{d}x&#x3D;\int_{\alpha(y)}^{\beta(y)} f^{\prime}_y(x,y)\mathrm{d}x+f(\beta(y),y)\cdot\beta^{\prime}(y)-f(\alpha(y),y)\cdot\alpha^{\prime}(y)$</li></ol><h3 id="2-含参广义积分的性质（参数范围为有限闭区间）"><a href="#2-含参广义积分的性质（参数范围为有限闭区间）" class="headerlink" title="2. 含参广义积分的性质（参数范围为有限闭区间）"></a>2. 含参广义积分的性质（参数范围为<strong>有限闭区间</strong>）</h3><ol><li>连续、可积<ol><li>$f(x,y)$ 在 $[a,+\infty)\times [\alpha,\beta]$ 上连续（同定积分）</li><li>$\displaystyle \int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li></ol></li><li>可微<ol><li>$f(x,y),f^{\prime}_y(x,y)$ 在 $[a,+\infty)\times [\alpha,\beta]$ 上连续（同定积分）</li><li>$\displaystyle \int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>逐点收敛</strong></li><li>$\displaystyle \int_a^{+\infty}f^{\prime}_y(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li></ol></li></ol><h3 id="3-二元无穷限累次积分的性质（参数范围为无穷限区间）"><a href="#3-二元无穷限累次积分的性质（参数范围为无穷限区间）" class="headerlink" title="3. 二元无穷限累次积分的性质（参数范围为无穷限区间）"></a>3. 二元无穷限累次积分的性质（参数范围为<strong>无穷限区间</strong>）</h3><ol><li>交换积分次序<ol><li>$f(x,y)$ 在 $[a,+\infty)\times [\alpha,+\infty)$ 上连续（同定积分）</li><li>$\displaystyle \forall \beta\gt \alpha,\int_a^{+\infty}f(x,y)\mathrm{d}x$ 在 $y\in[\alpha,\beta]$ 上<strong>一致收敛</strong></li><li>$\displaystyle \forall b\gt a,\int_\alpha^{+\infty}f(x,y)\mathrm{d}y$ 在 $x\in[a,b]$ 上<strong>一致收敛</strong></li><li>$\displaystyle \int_\alpha^{+\infty}\mathrm{d}y\int_a^{+\infty}\left|f(x,y)\right|\mathrm{d}x$ 和 $\displaystyle \int_a^{+\infty}\mathrm{d}x\int_\alpha^{+\infty}\left|f(x,y)\right|\mathrm{d}y$ 中至少有一个存在</li></ol></li></ol><h3 id="4-含参广义积分判敛"><a href="#4-含参广义积分判敛" class="headerlink" title="4. 含参广义积分判敛"></a>4. 含参广义积分判敛</h3><ol><li>方法<ol><li>定义</li><li>$\mathrm{Cauchy}$</li><li>$\mathrm{Weierstrass}$</li><li>$\mathrm{Dirichlet}$</li><li>$\mathrm{Abel}$</li></ol></li><li>技巧<ol><li>连续延拓</li><li>取任意闭区间 $[a,b]$ 逼近开区间</li></ol></li><li>注意事项<ol><li><strong>技巧2.2只能用于连续不能用于一致收敛</strong></li><li>一致收敛是连续的<strong>充分非必要</strong>条件</li></ol></li></ol><h3 id="5-技巧与例题"><a href="#5-技巧与例题" class="headerlink" title="5. 技巧与例题"></a>5. 技巧与例题</h3><ol><li>微分方程的求解：详见<a href="https://sqzr2319.github.io/Calculus-A1">微积分A(1)</a></li><li>常用积分公式：$\begin{cases}\displaystyle \int e^{ax}\cos bx\mathrm{d}x&#x3D;\frac{e^{ax}}{a^2+b^2}(a\cos bx+b\sin bx)+C\\\displaystyle \int e^{ax}\sin bx\mathrm{d}x&#x3D;\frac{e^{ax}}{a^2+b^2}(a\sin bx-b\cos bx)+C\end{cases}$</li><li>$(2024)$ 设 $\displaystyle I(y)&#x3D;\int_0^{+\infty}e^{-x^2}\sin(2xy)\mathrm{d}x$，证明：$\displaystyle I(y)&#x3D;e^{-y^2}\int_0^y e^{-t^2}\mathrm{d}t$</li><li>$(5.26)$ 试利用积分 $\displaystyle \varphi(x)&#x3D;\int_0^1 \frac{e^{-x^2(1+u^2)}}{1+u^2}\mathrm{d}u$ 计算积分 $\displaystyle I&#x3D;\int_0^{+\infty} e^{-x^2}\mathrm{d}x$</li><li>$(5.4)$ 证明：$\mathrm{Bessel}$ 函数 $\displaystyle I_n(x)&#x3D;\frac{1}{\pi}\int_0^{\pi}\cos(n\varphi-x\sin\varphi)\mathrm{d}\varphi,n\in \mathbb Z$ 满足 $\mathrm{Bessel}$ 方程 $x^2I^{\prime\prime}_n(x)+xI^{\prime}_n(x)+(x^2-n^2)I_n(x)&#x3D;0$</li><li>$(5.17)$ 证明：$\displaystyle \int_0^{+\infty} \frac{\sin x^2y}{x}\mathrm{d}x$ 在 $y\in (0,+\infty)$ 不一致收敛，但连续</li></ol><h2 id="三、重积分与曲线曲面积分"><a href="#三、重积分与曲线曲面积分" class="headerlink" title="三、重积分与曲线曲面积分"></a>三、重积分与曲线曲面积分</h2><h3 id="1-重积分的性质"><a href="#1-重积分的性质" class="headerlink" title="1. 重积分的性质"></a>1. 重积分的性质</h3><ol><li>可积条件：$D$ 为有界闭集，$f$ 为 $D$ 上的有界函数，$f$ 在 $D$ 上的间断点集为零面积集，$\partial D$ 为零面积集</li><li>积分估值：$\displaystyle \left|\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\right|\le \iint_D |f(x,y)|\mathrm{d}x\mathrm{d}y$</li><li>对称性：$D$ 关于 $OX$ 轴对称，若 $f(x,y)$ 关于 $y$ 为奇函数，则 $\displaystyle \iint_D f(x,y)\mathrm{d}x\mathrm{d}y&#x3D;0$；若为偶函数，则 $\displaystyle \iint_D f(x,y)\mathrm{d}x\mathrm{d}y&#x3D;2\iint_{D_1} f(x,y)\mathrm{d}x\mathrm{d}y$，其中 $D_1$ 为 $D$ 关于 $OX$ 轴的上半部分</li><li>轮换不变性：$D$ 关于 $x,y$ 轮换对称，则 $\displaystyle \iint_D f(x,y)\mathrm{d}x\mathrm{d}y&#x3D;\iint_D f(y,x)\mathrm{d}x\mathrm{d}y$</li><li>积分中值定理：$f,g$ 在连通集 $D$ 上连续且$g$ 不变号，则 $\displaystyle \iint_D f(x,y)g(x,y)\mathrm{d}x\mathrm{d}y&#x3D;f(\xi,\eta)\cdot \iint_D g(x,y)\mathrm{d}x\mathrm{d}y$，其中 $(\xi,\eta)$ 为 $D$ 内某点</li></ol><h3 id="2-重积分的计算"><a href="#2-重积分的计算" class="headerlink" title="2. 重积分的计算"></a>2. 重积分的计算</h3><ol><li>极坐标&#x2F;柱坐标：$\displaystyle \iint_D f(x,y)\mathrm{d}x\mathrm{d}y&#x3D;\iint_E f(r\cos \theta,r\sin \theta)r\mathrm{d}r\mathrm{d}\theta$</li><li>变量替换：$\displaystyle \iint_D f(x,y)\mathrm{d}x\mathrm{d}y&#x3D;\iint_E f(x(u,v),y(u,v))\left|\frac{\partial(x,y)}{\partial(u,v)}\right|\mathrm{d}u\mathrm{d}v$</li><li>球坐标：$\displaystyle \iiint_D f(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z&#x3D;\iiint_E f(r\sin\varphi\cos\theta,r\sin\varphi\sin\theta,r\cos\varphi)r^2\sin \varphi \mathrm{d}r\mathrm{d}\theta\mathrm{d}\varphi$</li></ol><h3 id="3-第一型曲线曲面积分的性质"><a href="#3-第一型曲线曲面积分的性质" class="headerlink" title="3. 第一型曲线曲面积分的性质"></a>3. 第一型曲线曲面积分的性质</h3><ol><li>可积条件：$S$ 为光滑曲面，$f(x,y,z)$ 在 $S$ 上连续</li><li>积分估值：$\displaystyle \left|\iint_S f(x,y,z)\mathrm{d}S\right|\le \iint_S |f(x,y,z)|\mathrm{d}S$</li><li>轮换不变性：$S$ 关于 $x,y$ 轮换对称，则 $\displaystyle \iint_S f(x,y,z)\mathrm{d}S&#x3D;\iint_S f(y,x,z)\mathrm{d}S$</li><li>对称性：$S$ 关于 $xy$ 平面对称，$f(x,y,z)$ 关于 $z$ 为奇函数，则 $\displaystyle \iint_S f(x,y,z)\mathrm{d}S&#x3D;0$</li></ol><h3 id="4-第一型曲线曲面积分的计算"><a href="#4-第一型曲线曲面积分的计算" class="headerlink" title="4. 第一型曲线曲面积分的计算"></a>4. 第一型曲线曲面积分的计算</h3><ol><li>曲面参数形式：$\displaystyle \iint_S f(x,y,z)\mathrm{d}S&#x3D;\iint_D f(x(u,v),y(u,v),z(u,v))||r^\prime u\times r^\prime v||\mathrm{d}u\mathrm{d}v$</li><li>曲面函数形式：$\displaystyle \iint_S f(x,y,z)\mathrm{d}S&#x3D;\iint_D f(x,y,z(x,y))\sqrt{1+z^{\prime}_x(x,y)^2+z^{\prime}_y(x,y)^2}\mathrm{d}x\mathrm{d}y$</li><li>曲线参数形式：$\displaystyle \int_L f(x,y,z)\mathrm{d}l&#x3D;\int_a^b f(x(t),y(t),z(t))\sqrt{x^\prime(t)^2+y^\prime(t)^2+z^\prime(t)^2}\mathrm{d}t$</li></ol><h3 id="5-第二型曲线曲面积分的性质"><a href="#5-第二型曲线曲面积分的性质" class="headerlink" title="5. 第二型曲线曲面积分的性质"></a>5. 第二型曲线曲面积分的性质</h3><ol><li>可积条件：$S$ 为有向光滑曲面，向量场 $\vec{v}(x,y,z)$ 在 $S$ 上连续</li><li>$\displaystyle \iint_{S^-} \vec{v}\cdot \mathrm{d}\vec{S}&#x3D;-\iint_S \vec{v}\cdot \mathrm{d}\vec{S}$</li></ol><h3 id="6-第二型曲线曲面积分的计算"><a href="#6-第二型曲线曲面积分的计算" class="headerlink" title="6. 第二型曲线曲面积分的计算"></a>6. 第二型曲线曲面积分的计算</h3><ol><li>曲面参数形式：$\displaystyle \iint_S \vec{v}\cdot \mathrm{d}\vec{S}&#x3D;\pm\iint_D(PA+QB+RC)\mathrm{d}u\mathrm{d}v$，$(A,B,C)$ 与正单位法向量同向时取正号</li><li>曲面函数形式：$\displaystyle \iint_S \vec{v}\cdot \mathrm{d}\vec{S}&#x3D;\pm\iint_D(-Pf^{\prime}_x(x,y)-Qf^{\prime}_y(x,y)+R)\mathrm{d}x\mathrm{d}y$，$(-f^{\prime}_x(x,y),-f^{\prime}_y(x,y),1)$ 与正单位法向量同向时取正号</li><li><strong>推论</strong>：$\displaystyle \iint_S R\mathrm{d}x\wedge \mathrm{d}y&#x3D;\pm \iint_D R\mathrm{d}x\mathrm{d}y$，$OZ$ 与正单位法向量同向时取正号</li><li><strong>推论</strong>：球面法向量 $&#x3D;r\sin \varphi\cdot (x,y,z)^T$</li><li>曲线参数形式：$\displaystyle \int_L \vec{v}\cdot \mathrm{d}\vec{l}&#x3D;\int_a^b(Px^\prime(t)+Qy^\prime(t)+Rz^\prime(t))\mathrm{d}t$，$a,b$ 对应曲线起点、终点</li></ol><h3 id="7-常用积分公式：详见微积分A-1"><a href="#7-常用积分公式：详见微积分A-1" class="headerlink" title="7. 常用积分公式：详见微积分A(1)"></a>7. 常用积分公式：详见<a href="https://sqzr2319.github.io/Calculus-A1">微积分A(1)</a></h3><ol><li>$\displaystyle \int_0^{\frac{\pi}{2}}\sin^{2n}\theta\mathrm{d}\theta&#x3D;\int_0^{\frac{\pi}{2}}\cos^{2n}\theta\mathrm{d}\theta&#x3D;\frac{(2n-1)!!}{(2n)!!}\cdot \frac{\pi}{2}$</li><li>$\displaystyle \int_0^{\frac{\pi}{2}}\sin^{2n-1}\theta\mathrm{d}\theta&#x3D;\int_0^{\frac{\pi}{2}}\cos^{2n-1}\theta\mathrm{d}\theta&#x3D;\frac{(2n-2)!!}{(2n-1)!!}$</li><li>$\displaystyle \int\frac{\mathrm{d}x}{\sqrt{x^2\pm a^2}}&#x3D;\ln\left|x+\sqrt{x^2\pm a^2}\right|+C$</li><li>$\displaystyle \int \sqrt{a^2-x^2}\mathrm{d}x&#x3D;\frac{x}{2}\sqrt{a^2-x^2}+\frac{a^2}{2}\arcsin\frac{x}{a}+C$</li><li>$\displaystyle \int \sqrt{x^2\pm a^2}\mathrm{d}x&#x3D;\frac{x}{2}\sqrt{x^2\pm a^2}\pm\frac{a^2}{2}\ln\left|x+\sqrt{x^2\pm a^2}\right|+C$</li><li>$\displaystyle \int\frac{\mathrm{d}x}{(a^2+x^2)^2}&#x3D;\frac{1}{2a^2}\left(\frac{x}{a^2+x^2}+\frac{1}{a}\arctan\frac{x}{a}\right)+C$</li></ol><h3 id="8-三大公式"><a href="#8-三大公式" class="headerlink" title="8. 三大公式"></a>8. 三大公式</h3><ol><li>$\mathrm{Green}$ 公式：有界闭区域 $D$，$\partial D$ 逐段光滑，且沿 $\partial D$ 的正向前进时，$D$ 在 $\partial D$ 的左侧，$\vec{v}$ 在 $D$ 上连续可微，则 $\begin{cases}\displaystyle \oint_{\partial D} \vec{v}\cdot \vec{\tau}\mathrm{d}l&#x3D;\iint_D \nabla \times \vec{v}\mathrm{d}x\mathrm{d}y\\\displaystyle \oint_{\partial D} \vec{v}\cdot \vec{n}\mathrm{d}S&#x3D;\iint_D \nabla \cdot \vec{v}\mathrm{d}x\mathrm{d}y\end{cases}$</li><li>$\mathrm{Gauss}$ 公式：有界闭区域 $D$，$D$ 的外边界曲面 $\partial D$ 逐片光滑，$\vec{v}$ 在 $D$ 上连续可微，则 $\displaystyle \oiint_{\partial D} \vec{v}\cdot \vec{n}\mathrm{d}S&#x3D;\iiint_D \nabla \cdot \vec{v}\mathrm{d}x\mathrm{d}y\mathrm{d}z$</li><li>$\mathrm{Stokes}$ 公式：有向曲面 $S$ 逐片光滑，$\partial S$ 逐段光滑，站在 $S$ 的正面，沿 $\partial S$ 的正向前进时，$S$ 在 $\partial S$ 的左侧，$\vec{v}$ 在 $S$ 上连续可微，则 $\displaystyle \oint_{\partial S} \vec{v}\cdot \vec{\tau} \mathrm{d}l&#x3D;\iint_S (\nabla \times \vec{v})\cdot \vec{n}\mathrm{d}S$</li><li>常见应用方式<ol><li>将围绕奇点的复杂闭曲线转化为简单闭曲线</li><li>将无旋场中的复杂曲线转化为简单曲线</li><li>与常规方法联用证明等式</li></ol></li></ol><h3 id="9-场论"><a href="#9-场论" class="headerlink" title="9. 场论"></a>9. 场论</h3><ol><li>定义<ol><li>保守场：积分与路径无关</li><li>单连通：任意简单闭曲线的内部都包含在区域中（可连续收缩变形为一点）</li><li>面连通：任意封闭曲面的内部都包含在区域中</li><li>线连通：任一简单闭曲线均有区域中的曲面以其为边界</li><li>线连通与面连通既不充分也不必要</li></ol></li><li>连续的保守场 $\Leftrightarrow$ 有势场</li><li>连续可微的保守场 $\Rightarrow$ 无旋场</li><li>单连通&#x2F;线连通区域上的连续可微保守场 $\Leftrightarrow$ 无旋场</li><li>场论视角下的恰当方程：详见<a href="https://sqzr2319.github.io/Calculus-A1">微积分A(1)</a></li></ol><h3 id="10-证明题"><a href="#10-证明题" class="headerlink" title="10. 证明题"></a>10. 证明题</h3><ol><li>$(§3.2)$ 设 $f(x)\in C[0,1],f\gt 0,f$ 递减，证明：$\displaystyle \frac{\int_0^1 xf^2(x)\mathrm{d}x}{\int_0^1 xf(x)\mathrm{d}x}\le \frac{\int_0^1 f^2(x)\mathrm{d}x}{\int_0^1 f(x)\mathrm{d}x}$</li><li>$(§3.2)$ 设 $D&#x3D;\{(x,y)|0\le x,y\le 1\},z&#x3D;f(x,y)\in C^2(D)$，若 $\begin{cases}\left|\dfrac{\partial^2 f(x,y)}{\partial x\partial y}\right|\le 4,\forall (x,y)\in D\\f(x,y)&#x3D;f^{\prime}_x(x,y)&#x3D;0,\forall (x,y)\in \partial D\end{cases}$，证明：$\displaystyle \left|\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\right|\le 1$</li><li>$(§3.3)$ 证明：若 $f$ 连续，则 $\displaystyle \iint_{|x|,|y|\le \frac{a}{2}} f(x-y)\mathrm{d}x\mathrm{d}y&#x3D;\int_{-a}^a f(t)(a-|t|)\mathrm{d}t$</li><li>$(6.27)$ 证明：$\displaystyle \iint_{[0,1]^2} (xy)^{xy} \mathrm{d}x\mathrm{d}y&#x3D;\int_0^1 t^t dt$</li><li>$(6.30)$ 设 $f\in C[0,\pi],0\lt f(x,y)\le M$，证明：$\displaystyle 0\lt I&#x3D;\left(\int_0^\pi f(x)\mathrm{d}x\right)^2-\left(\int_0^\pi f(x)\cos x\mathrm{d}x\right)^2-\left(\int_0^\pi f(x)\sin x\mathrm{d}x\right)^2\le M^2(\pi^2-4)$</li><li>$(6.32)$ 设 $p(x)$ 在 $[a,b]$ 上非负可积，$f(x),g(x)$ 在 $[a,b]$ 上递增，证明：$\displaystyle \int_a^b p(x)f(x)\mathrm{d}x\cdot \int_a^b p(x)g(x)\mathrm{d}x\le \int_a^b p(x)\mathrm{d}x\cdot \int_a^b p(x)f(x)g(x)\mathrm{d}x$</li><li>$(6.35)$ 设 $D&#x3D;\{(x,y)|x^2+y^2\le 1\}$，函数 $f(x,y)$ 在 $D$ 上有二阶连续偏导数，在 $\partial D$ 上 $f(x,y)&#x3D;0$，证明：$\displaystyle \iint_D f(x,y)\left(\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2}\right)\mathrm{d}x\mathrm{d}y\le 0$</li><li>$(6.36)$ 设 $D&#x3D;\{(x,y)|0\le x,y\le 1\},f(x,y)\in C^4(D),\left|\dfrac{\partial^4 f(x,y)}{\partial x^2\partial y^2}\right|\le M,\forall (x,y)\in D,f(x,y)&#x3D;0,\forall (x,y)\in \partial D$，证明：<ol><li>令 $g(x,y)&#x3D;xy(1-x)(1-y)$，则 $\displaystyle \iint_D \frac{\partial^4 f(x,y)}{\partial x^2\partial y^2}g(x,y)\mathrm{d}x\mathrm{d}y&#x3D;\iint_D \frac{\partial^4 g(x,y)}{\partial x^2\partial y^2}f(x,y)\mathrm{d}x\mathrm{d}y$</li><li>$\displaystyle \left|\iint_D f(x,y)\mathrm{d}x\mathrm{d}y\right|\le \frac{M}{144}$</li></ol></li><li>$(§4.1)$ 设 $f(x)\in C[0,1]$，证明：<ol><li>$\displaystyle \int_0^{\frac{\pi}{2}} \mathrm{d}\theta\int_0^{\frac{\pi}{2}} \sin\varphi f(\sin\varphi\sin\theta)\mathrm{d}\varphi&#x3D;\frac{\pi}{2}\int_0^{\frac{\pi}{2}}\sin\varphi f(\cos\varphi)\mathrm{d}\varphi$</li><li>计算 $\displaystyle I&#x3D;\iint_{0\le \varphi,\theta\le \frac{\pi}{2}} \sin\varphi e^{\sin\varphi\sin\theta}\mathrm{d}\varphi\mathrm{d}\theta$</li></ol></li><li>$(§4.1)(\mathrm{Poisson})$ 设 $S&#x3D;\{(x,y,z)|x^2+y^2+z^2&#x3D;1\}$，证明：$\displaystyle \oiint_S f(ax+by+cz)\mathrm{d}S&#x3D;2\pi\int_{-1}^1 f(\sqrt{a^2+b^2+c^2}t)\mathrm{d}t$</li><li>$(§4.4)$ 设 $\Omega$ 为平面区域，$u(x,y)\in C^2(\Omega)$，证明：$u^{\prime\prime}_{xx}+u^{\prime\prime}_{yy}&#x3D;0$ 的充要条件是对 $\Omega$ 内的任意区域 $D$，有 $\displaystyle \oint_{\partial D} \frac{\partial u}{\partial \vec{n}}\mathrm{d}l&#x3D;0$</li><li>$(§4.4)$ 设 $f(x,y)\in C^2(\mathbb R),f^{\prime\prime}_{xx}+f^{\prime\prime}_{yy}&#x3D;e^{-(x^2+y^2)}$，证明：<ol><li>$\displaystyle \oint_{L_r} \frac{\partial f}{\partial \vec{n}}\mathrm{d}l&#x3D;\pi (1-e^{-r^2}),L_r:x^2+y^2&#x3D;r^2$，逆时针</li><li>$\displaystyle \iint_{x^2+y^2\le 1} (xf^{\prime}_x(x,y)+yf^{\prime}_y(x,y))\mathrm{d}x\mathrm{d}y&#x3D;\frac{\pi}{2e}$</li></ol></li><li>$(8.22)$ 设 $P(x,y),Q(x,y)$ 是从 $A$ 到 $B$ 的光滑曲线 $AB$ 上的连续函数，$AB$ 的长度为 $l$，证明：<ol><li>$\displaystyle \left|\int_{AB} P\mathrm{d}x+Q\mathrm{d}y\right|\le lM$，其中 $\displaystyle M&#x3D;\max_{(x,y)\in AB}\sqrt{P^2(x,y)+Q^2(x,y)}$</li><li>设 $L:x^2+y^2&#x3D;R^2$，逆时针方向，$\displaystyle I_R&#x3D;\int_L \frac{y\mathrm{d}x-x\mathrm{d}y}{(x^2+xy+y^2)^2}$，则 $\displaystyle \lim_{R\to +\infty} I_R&#x3D;0$</li></ol></li><li>$(9.8)$ 设 $P(x,y),Q(x,y)$ 在全平面上有连续偏导数，而且对任意点 $(x_0,y_0)$ 为中心，以任意正数 $r$ 为半径的上半圆 $C:x&#x3D;x_0+r\cos \theta,y&#x3D;y_0+r\sin \theta(0\le \theta\le \pi)$，都有 $\displaystyle \int_C P\mathrm{d}x+Q\mathrm{d}y&#x3D;0$，证明：$P(x,y)&#x3D;0,\dfrac{\partial Q}{\partial y}&#x3D;0$</li><li>$(9.16)$ 设 $\vec{v}&#x3D;(P(x,y,z),Q(x,y,z),R(x,y,z))^T\in C^1(\mathbb{R}^3)$，且 $\begin{cases}\nabla \cdot \vec{v}(x,y,z)&#x3D;0,\forall (x,y,z)\in \Omega\\\vec{v}(x,y,z)&#x3D;(1,1,1)^T,\forall (x,y,z)\in \partial \Omega\end{cases}$，其中 $\Omega$ 是 $\mathbb R^3$ 中以原点为球心的单位球，证明：$\displaystyle \iiint_\Omega (P+Q+R)\mathrm{d}x\mathrm{d}y\mathrm{d}z&#x3D;4\pi$</li></ol><h2 id="四、级数"><a href="#四、级数" class="headerlink" title="四、级数"></a>四、级数</h2><h3 id="1-常数项级数"><a href="#1-常数项级数" class="headerlink" title="1. 常数项级数"></a>1. 常数项级数</h3><ol><li>常数项级数的性质<ol><li>$\mathrm{Cauchy}$ 收敛原理：$\displaystyle \forall \varepsilon\gt 0,\exists N\in \mathbb N,\forall m,n\ge N,\left|\sum_{k&#x3D;m}^n a_k\right|\lt \varepsilon$</li><li>收敛的级数必有 $\displaystyle \lim_{n\to +\infty} a_n&#x3D;0$</li></ol></li><li>非负项级数<ol><li>收敛充要条件：部分和数列有上界</li><li>$\mathrm{Cauchy}$ 积分判别法：设 $f(x)$ 在 $[1,+\infty)$ 上单调下降且非负，则 $\displaystyle \sum_{n&#x3D;1}^{\infty} f(n)$ 与 $\displaystyle \int_1^{+\infty}f(x)\mathrm{d}x$ 同敛散</li><li>比较判别法</li><li>$\mathrm{Cauchy}$ 根式判别法：$q\lt 1$ 收敛，$q\gt 1$ 发散</li><li>比值判别法</li><li>$\mathrm{D’Alembert}$ 判别法：$q\lt 1$ 收敛，$q\gt 1$ 发散</li><li>$\mathrm{Raabe}$ 判别法：$n\left(\frac{a_n}{a_{n+1}}-1\right)\to r$，则 $r\gt 1$ 收敛，$r\lt 1$ 发散</li><li>$\mathrm{Gauss}$ 判别法：$\frac{a_n}{a_{n+1}}&#x3D;\lambda+\frac{\mu}{n}+\frac{\nu}{n\ln n}+o\left(\frac{1}{n\ln n}\right),\nu\gt 1$ 收敛，$\nu\lt 1$ 发散</li></ol></li><li>任意项级数<ol><li>比较判别法对任意项级数不成立，如级数 $\frac{(-1)^n}{n+(-1)^n}$ 收敛，但级数 $\frac{(-1)^n}{\sqrt{n}+(-1)^n}$ 发散</li><li>交错项级数的 $\mathrm{Leibnitz}$ 判别法：单调递减趋于零</li><li>$\mathrm{Dirichlet}$ 判别法：$a_n$ 单调递减趋于零，$b_n$ 部分和有界</li><li>$\mathrm{Abel}$ 判别法：$a_n$ 单调有界，$b_n$ 部分和收敛</li><li>$\displaystyle \sum_{k&#x3D;1}^n \cos k&#x3D;\frac{\sin(n+\frac{1}{2})-\sin\frac{1}{2}}{2\sin\frac{1}{2}}$，从而级数 $\frac{\cos n}{n}$ 收敛</li><li>若使用结合律后每个括号内同正负，则原级数收敛</li><li>绝对收敛的数列有交换律，条件收敛没有交换律</li><li>$\mathrm{Cauchy}$ 乘积：$\displaystyle \sum_{n&#x3D;1}^{\infty} (a_1b_n+\cdots+a_nb_1)$ 为级数 $a_n,b_n$ 的 $\mathrm{Cauchy}$ 乘积，若级数 $a_n,b_n$ 收敛，则其 $\mathrm{Cauchy}$ 乘积收敛到其乘积</li></ol></li><li>例题<ol><li>级数 $a_n^2,b_n^2$ 收敛，证明：级数 $(a_n+b_n)^2$ 收敛，级数 $\frac{a_n}{n}$ 绝对收敛</li><li>$(10.13)$ 设 $a_n\gt 0$，证明：无论级数 $a_n$ 是否收敛，级数 $\frac{a_n}{S_n^p}$ 对任意 $p\gt 1$ 收敛</li><li>$(10.21)$ 已知级数 $u_n$ 收敛，则以下级数中收敛的有：级数 $(-1)^n\frac{u_n}{n}$，级数 $u_n^2$，级数 $u_n-u_{2n}$，级数 $u_n+u_{n+1}$</li></ol></li></ol><h3 id="2-函数项级数"><a href="#2-函数项级数" class="headerlink" title="2. 函数项级数"></a>2. 函数项级数</h3><ol><li>一致收敛的判定<ol><li>$\mathrm{Cauchy}$ 准则：级数 $u_n(x)$ 一致收敛当且仅当 $\displaystyle \forall \varepsilon\gt 0,\exists N\in \mathbb N,\forall m,n\ge N,\left|\left|\sum_{k&#x3D;m}^n a_k(x)\right|\right|_{\infty}\lt \varepsilon$</li><li>$\mathrm{Weierstrass}$ 判别法：$||u_n(x)||_\infty\le M_n$</li><li>$\mathrm{Dirichlet}$ 判别法：$\forall x_0,u_n(x_0)$ 单调且 $u_n(x)$ 一致趋于零，$v_n(x)$ 部分和一致有界</li><li>$\mathrm{Abel}$ 判别法：$\forall x_0,u_n(x_0)$ 单调且 $u_n(x)$ 一致有界，级数 $v_n(x)$ 一致收敛</li></ol></li><li>一致收敛的性质<ol><li>$u_n(x)$ 连续，级数 $u_n(x)$ 一致收敛，则可逐项取极限</li><li>$u_n(x)$ 连续，级数 $u_n(x)$ 一致收敛，则可逐项积分</li><li>$u_n(x)$ 导函数连续，级数 $u_n^\prime(x)$ 一致收敛，且存在 $x_0$ 使得级数 $u_n(x_0)$ 收敛，则级数 $u_n(x)$ 一致收敛，且可逐项求导</li></ol></li><li>幂级数<ol><li>幂级数在收敛半径内点点绝对收敛，收敛半径外点点发散，在收敛域上内闭一致绝对收敛</li><li>若在 $x_0$ 处条件收敛，则收敛半径等于 $x_0$</li><li>若 $\displaystyle \lim_{n\to \infty} \sqrt[n]{|a_n|}&#x3D;q$，则 $\rho&#x3D;\frac{1}{q}$</li><li>若 $\displaystyle \lim_{n\to \infty} \frac{|a_{n+1}|}{|a_{n}|}&#x3D;q$，则 $\rho&#x3D;\frac{1}{q}$</li><li>逐项积分、逐项求导不改变收敛半径，但可能改变收敛域</li><li>若导函数列在 $x_0$ 的邻域内一致有界，则 $f$ 在 $x_0$ 的邻域内可展开成 $\mathrm{Taylor}$ 级数</li></ol></li><li>$\mathrm{Fourier}$ 级数<ol><li>$\displaystyle f(x)&#x3D;\frac{a_0}{2}+\sum_{n&#x3D;1}^{+\infty}\left(a_n\cos \frac{n\pi x}{l}+b_n\sin \frac{n\pi x}{l}\right)$，其中 $\displaystyle a_n&#x3D;\frac{1}{l}\int_{-l}^{l}f(x)\cos \frac{n\pi x}{l}\mathrm{d}x,b_n&#x3D;\frac{1}{l}\int_{-l}^{l}f(x)\sin \frac{n\pi x}{l}\mathrm{d}x$</li><li>分段可微的函数其 $\mathrm{Fourier}$ 级数收敛到左右极限的平均值</li><li>分段单调有界的函数其 $\mathrm{Fourier}$ 级数收敛到左右极限的平均值</li><li>$\mathrm{Parseval}$ 等式：$\displaystyle \frac{a_0^2}{2}+\sum_{n&#x3D;1}^{\infty}\left(a_n^2+b_n^2\right)&#x3D;\frac{1}{l}\int_{-l}^{l}f^2(x)\mathrm{d}x$</li><li>绝对可积的函数其 $\mathrm{Fourier}$ 级数逐项可积，且级数 $\frac{b_n}{n}$ 收敛</li><li>导函数绝对可积的函数其 $\mathrm{Fourier}$ 级数逐项可微</li></ol></li><li>例题<ol><li>$(11.17)$ 求 $\frac{x\sin\alpha}{1-2x\cos\alpha+x^2}$ 的幂级数展开式</li><li>$(11.24)$ 设 $\displaystyle \lim_{n\to \infty}a_n&#x3D;a,f(x)&#x3D;\sum_{n&#x3D;1}^\infty a_nx^n$，证明：<ol><li>$\displaystyle \lim_{x\to 1^-}(1-x)f(x)&#x3D;a$</li><li>$\displaystyle \lim_{x\to 1^-}(1-x)\int_0^x \frac{f(t)}{1-t}\mathrm{d}t&#x3D;a$</li></ol></li><li>$(11.33)$ 验证函数 $\displaystyle y(x)&#x3D;\sum_{n&#x3D;0}^{\infty} \frac{x^{3n}}{(3n)!}$ 满足微分方程 $y^{\prime\prime}+y^\prime+y&#x3D;e^x$，并求其和函数</li><li>$(11.36)$ 设幂级数 $a_nx^n$ 的收敛半径大于零，$a_1\neq 0$，且在原点的一个邻域内 $\displaystyle \left|\sum_{n&#x3D;1}^{\infty}a_nx^n\right|\ge|a_1||x|-2x^2$，证明：$|a_2|\le 2$</li><li>$(12.27)$ 证明：存在收敛的三角级数，其不是任何函数的 $\mathrm{Fourier}$ 级数</li><li>证明：级数 $\frac{\sin nx}{\ln n}$，级数 $\frac{\sin nx}{\ln\ln n}$ 不是任何绝对可积函数的 $\mathrm{Fourier}$ 级数</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数(2)</title>
    <link href="/25Spring/LinearAlgebra-2/"/>
    <url>/25Spring/LinearAlgebra-2/</url>
    
    <content type="html"><![CDATA[<p>大一下学期线性代数(2)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、复数"><a href="#一、复数" class="headerlink" title="一、复数"></a>一、复数</h2><ol><li>矩阵形式：$T(a+bi)&#x3D;\begin{pmatrix} a &amp; -b \\ b &amp; a \end{pmatrix}$，$T$ 保持加法和乘法</li><li>复数的幂：整数幂唯一，有理数 $\frac{p}{q}$ 次幂有$p$个，无理数次幂无穷多</li></ol><h2 id="二、多项式"><a href="#二、多项式" class="headerlink" title="二、多项式"></a>二、多项式</h2><ol><li>综合除法：$f(x)&#x3D;x^3-4x^2-5x+2$，求 $f(-3)$ 或求 $f(x)$ 除以 $x+3$ 的余式<br>$$\begin{bmatrix} -3 &amp; 1 &amp; -4 &amp; -5 &amp; 2 \\ &amp;  &amp; -3 &amp; 21 &amp; -48 \\ \hline &amp; 1 &amp; -7 &amp; 16 &amp; -46 \end{bmatrix}$$</li><li>将 $f(x)$ 分解成 $x-a$ 的方幂和：$f(x)&#x3D;(x-a)g_0(x)+r_0(x)&#x3D;(x-a)((x-a)g_1(x)+r_1(x))+r_0(x)$</li><li>$\mathrm{Lagrange}$ 插值<ol><li>$n&#x3D;1$ 时：$f(x)&#x3D;f(x_0)\frac{(x-x_1)}{(x_0-x_1)}+f(x_1)\frac{(x-x_0)}{(x_1-x_0)}$</li><li>$L_i(x)&#x3D;\frac{(x-a_0)\cdots(x-a_{i-1})(x-a_{i+1})\cdots(x-a_n)}{(a_i-a_0)\cdots(a_i-a_{i-1})(a_i-a_{i+1})\cdots(a_i-a_n)}$,$L(x)&#x3D;\sum_{i&#x3D;0}^n f(a_i)L_i(x)$</li></ol></li><li>$\mathrm{Bezout}$ 等式：$(f(x),g(x))&#x3D;f(x)u(x)+g(x)v(x)$<ol><li>$f(x)&#x3D;p(x)g(x)+r(x),g(x)&#x3D;q(x)r(x)+s(x),r(x)&#x3D;t(x)s(x)\Rightarrow s(x)&#x3D;g(x)-q(x)r(x)&#x3D;g(x)-q(x)(f(x)-p(x)g(x))$</li><li>$f(x)u(x)+g(x)v(x)&#x3D;h(x)$ 不能推出 $h(x)$ 是最大公因式</li><li>$f(x)u(x)+g(x)v(x)&#x3D;1\Leftrightarrow f(x)$ 和 $g(x)$ 互质</li></ol></li><li>有理根定理：$f(x)&#x3D;a_nx^n+\cdots+a_0$，$\frac{p}{q}$ 是 $f(x)$ 的有理根  $\Rightarrow p|a_0,q|a_n$</li><li>三次方程 $ax^3+bx^2+cx+d&#x3D;0$ 的根的性质<ol><li>$\mathrm{Vieta}$ 定理：$x_1+x_2+x_3&#x3D;-\frac{b}{a},x_1x_2+x_2x_3+x_3x_1&#x3D;\frac{c}{a},x_1x_2x_3&#x3D;-\frac{d}{a}$</li><li>$x^3+px+q&#x3D;0$ 的判别式：$\Delta&#x3D;-4p^3-27q^2$，$\Delta&gt;0$ 有三个不相等的实根，$\Delta&#x3D;0$ 有两个相等的实根，$\Delta&lt;0$ 有一个实根和两个共轭复根</li></ol></li></ol><h2 id="三、Jordan-标准形"><a href="#三、Jordan-标准形" class="headerlink" title="三、Jordan 标准形"></a>三、Jordan 标准形</h2><ol><li>$\mathrm{Ker}T,\mathrm{Im}T,\mathrm{Ker}(T-aI)^k,\mathrm{Im}(T-aI)^k$ 是 $T-$ 不变子空间</li><li>极小多项式<ol><li>唯一且相似矩阵的极小多项式相同</li><li>分块对角矩阵的极小多项式为分块对角矩阵的极小多项式的最小公倍式</li><li>设 $|\lambda I_n-A|&#x3D;(\lambda -\lambda_1)^{n_1}(\lambda -\lambda_2)^{n_2}\cdots(\lambda -\lambda_s)^{n_s}$，则 $m_A(x)&#x3D;(x-\lambda_1)^{m_1}(x-\lambda_2)^{m_2}\cdots(x-\lambda_s)^{m_s}$，其中 $m_i$ 是使 $G_{\lambda_i}(A)$ 的维数最大的最小整数</li><li>推论：可对角化等价于极小多项式无重根</li><li>推论：若存在向量 $v$ 使得 $v,T(v),T^2(v),\cdots,T^{k}(v)$ 线性无关，则 $T$ 的极小多项式次数大于 $k$</li></ol></li><li>循环子空间<ol><li>幂零变换 $\Leftrightarrow$ 只有零特征值</li><li>极大循环子空间 $\Leftrightarrow v\notin \mathrm{Im} T$</li><li>循环子空间直和分解定理<ol><li>循环子空间个数 $&#x3D;\mathrm{dim} \mathrm{Ker} T&#x3D;$ 零特征值的几何重数</li><li>循环子空间最大维数 $&#x3D;$ 幂零次数 $&#x3D;$ 极小多项式次数</li><li>阶数为 $d$ 的 $\mathrm{Jordan}$ 块个数 $&#x3D;r(A^{d-1})+r(A^{d+1})-2r(A^d)$</li></ol></li></ol></li></ol><h2 id="四、矩阵函数"><a href="#四、矩阵函数" class="headerlink" title="四、矩阵函数"></a>四、矩阵函数</h2><ol><li>函数矩阵的逆 $&#x3D;\frac{1}{\det A(x)}\mathrm{adj} A(x)$</li><li>$m$ 个 $n$ 维函数向量线性无关 $\Leftrightarrow$ $m$ 阶 $\mathrm{Gram}$ 矩阵满秩 $(g_{ij}&#x3D;\int_a^b a_i^T(x)a_j(x)\mathrm{d}x)$</li><li>$m$ 个 $n$ 维函数向量线性无关 $\Leftrightarrow$ $\mathrm{Wronsky}$ 矩阵 $W(x)&#x3D;\left(A(x),A’(x),\cdots,A^{(m-1)}(x)\right)_{m\times mn}$ 在某点满行秩</li><li>矩阵级数绝对收敛 $\Leftrightarrow \sum_{k&#x3D;1}^{\infty} ||A^k||_{\infty}$ 收敛</li><li>$f(A)&#x3D;Pf(J)P^{-1},f(J_{\lambda_0,m})&#x3D;\mathrm{diag}(f(\lambda_0),f^{\prime}(\lambda_0),\frac{1}{2!}f^{\prime\prime}(\lambda_0),\cdots)$</li><li>$|\lambda I_n-f(A)|&#x3D;(\lambda-f(\mu_1))^{n_1}(\lambda-f(\mu_2))^{n_2}\cdots(\lambda-f(\mu_s))^{n_s}$</li><li>待定系数法：$r(z)&#x3D;a_0+a_1z+a_2z^2+\cdots+a_{n-1}z^{n-1}+a_{m-1}z^{m-1},m&#x3D;\sum m_i,r(\sigma_i)&#x3D;f(\sigma_i),f(A)&#x3D;r(A)$</li><li>$e^{J_{\lambda,m}t}&#x3D;e^{(\lambda t)I+N}&#x3D;e^{\lambda t}(I+N+\frac{1}{2!}N^2+\cdots+\frac{1}{(m-1)!}N^{m-1})$</li><li>$\frac{\mathrm{d}X}{\mathrm{d}t}&#x3D;AX$ 的解：$x(t)&#x3D;Pe^{Jt}\vec{c}$；$x(0)&#x3D;\alpha\Rightarrow \vec{c}&#x3D;P^{-1}\alpha$</li></ol><h2 id="五、酉空间"><a href="#五、酉空间" class="headerlink" title="五、酉空间"></a>五、酉空间</h2><ol><li>内积：共轭对称性、线性性、正定性</li><li>$\mathrm{Frobenius}$ 内积：$\mathrm{tr}(AB^H)$</li><li>若 $\vec{u_1},\vec{u_2},\cdots,\vec{u_n}$ 标准正交，则 $v&#x3D;\sum_{i&#x3D;1}^n (v,\vec{u_i})\vec{u_i}$ （投影向量）</li><li>$\mathrm{C}^n&#x3D;C(A)\oplus N(A^H)$</li><li>$T,T^*$ 在一组标准正交基下的矩阵是 $A,A^H$</li><li>若 $W$ 是 $T-$ 不变子空间，则 $W^\perp$ 是 $T^*-$ 不变子空间</li><li>若 $\lambda$ 是 $T$ 的特征值，则 $\overline{\lambda}$ 是 $T^*$ 的特征值</li><li>保积变换是线性同构（单：$\mathrm{Ker}T&#x3D;\{0\}$，满：$\mathrm{Im}T&#x3D;V$）</li><li>第一&#x2F;第二类正交变换：$\det&#x3D;1$，$\det&#x3D;-1$</li><li>正规变换性质<ol><li>$T\alpha&#x3D;\lambda\alpha\Rightarrow T^*\alpha&#x3D;\overline{\lambda}\alpha$</li><li>在不同特征值下的特征向量正交</li><li>当且仅当可正交对角化</li></ol></li><li>推广 $\mathrm{Schur}$ 定理：酉上三角化（借助 $UR$ 分解）</li><li>$\mathrm{Hermite}$ 阵的特征值是实数</li><li>正规阵的极分解：$A&#x3D;Re^{iM}$，$R&#x3D;U\mathrm{diag}(r_1,r_2,\cdots,r_n)U^H$ 为半正定 $\mathrm{Hermite}$ 阵，$M&#x3D;U\mathrm{diag}(\theta_1,\theta_2,\cdots,\theta_n)U^H$ 是 $\mathrm{Hermite}$ 阵，$RM&#x3D;MR$</li><li>$A$ 列满秩 $\Rightarrow$ $A^HA$ 是正定 $\mathrm{Hermite}$ 阵；行满秩 $\Rightarrow$ $AA^H$ 是正定 $\mathrm{Hermite}$ 阵</li></ol><h2 id="六、双线性型"><a href="#六、双线性型" class="headerlink" title="六、双线性型"></a>六、双线性型</h2><ol><li>$\mathrm{Riesz}$ 表示定理：内积空间中存在唯一的 $\vec{u}&#x3D;\sum_{i&#x3D;1}^n \overline{f(\vec{e_i})}\vec{e_i}\in V$，使得 $f(\vec{v})&#x3D;(\vec{v},\vec{u}),\forall \vec{v}\in V$，$\vec{e_i}$ 是一组标准正交基</li><li>对偶基：$f_i(\vec{e_j})&#x3D;\delta_{ij}$，称其为 $\vec{e_i}$ 的对偶基</li><li>若两组基满足 $\beta&#x3D;\alpha P$，则其对偶基满足 $\beta^*&#x3D;\alpha^*P^{-T}$</li><li>$V$ 与 $V^{\star\star}$ 同构，故 $V$ 与 $V^*$ 互为对偶空间，且 $\beta^{\star\star}&#x3D;\alpha^{\star\star}P$</li><li>对偶线性映射：$\langle f,T(v)\rangle&#x3D;\langle T^*(f),v\rangle$，若 $T$ 在基 $\alpha$ 下的矩阵是 $A$，则 $T^*$ 在基 $\alpha^*$ 下的矩阵是 $A^T$</li><li>双线性型的表示矩阵：$g_{ij}&#x3D;g(\vec{v_i},\vec{v_j})$，不同基下有 $G^\prime&#x3D;P^TG P$，在一组基下表示矩阵可逆的双线性型称为非退化双线性型</li><li>非退化对称型可化简为相合标准形，非退化反对称型可化简为 $\mathrm{diag}\begin{pmatrix}0&amp;1\\-1&amp;0\end{pmatrix}$，故有非退化反对称型的线性空间只能是偶数维</li><li>广义内积空间：$(V,g)$，$g$ 为非退化对称型时称为正交空间，$g$ 为非退化反对称型时称为辛空间</li></ol><h2 id="七、技巧与例题"><a href="#七、技巧与例题" class="headerlink" title="七、技巧与例题"></a>七、技巧与例题</h2><ol><li>常用证明技巧<ol><li>存在 $f(A)&#x3D;B$ 的充要条件是存在 $\mathrm{Jordan}$ 标准形 $J$ 使得 $f(J)$ 的 $\mathrm{Jordan}$ 标准形与 $B$ 的 $\mathrm{Jordan}$ 标准形相同</li><li>循环矩阵可被 $\mathrm{Fourier}$ 矩阵对角化，其特征值为 $\omega^k$ 的线性组合</li><li>$AB$ 的特征值和 $BA$ 的特征值相同</li><li>若 $RN&#x3D;NR,\forall N\in M_n(\mathbb{C})$，则 $R$ 是纯量矩阵（即 $R&#x3D;cI_n$）</li></ol></li><li>设 $V$ 是复数域上的 $n$ 维线性空间，$\sigma,\tau$ 是 $V$ 的线性变换，且 $\sigma\tau&#x3D;\tau\sigma$，证明：<ol><li>如果 $\lambda_0$ 是 $\sigma$ 的特征值，那么 $\lambda_0$ 的特征子空间 $V_{\lambda_0}$ 是 $\tau$ 的不变子空间</li><li>$\sigma,\tau$ 至少有一个公共的特征向量</li></ol></li><li>设 $A,B$ 分别是 $m,n$ 阶矩阵，求证：矩阵方程 $AX&#x3D;XB$ 只有零解的充要条件是 $A,B$ 无公共特征值</li><li>设 $V$ 是 $n$ 维内积空间，$T$ 是 $V$ 上的线性变换，证明：$ImT^*&#x3D;(KerT)^\perp$</li><li>设 $A,B$ 是 $m\times n$ 实矩阵，求证：$A^TA&#x3D;B^TB$ 的充要条件是存在 $m$ 阶正交矩阵 $Q$，使得 $A&#x3D;QB$</li><li>设 $Q$ 为 $n$ 阶正交矩阵，$1$ 不是 $Q$ 的特征值，设 $P&#x3D;I-2\alpha\alpha^T$，其中 $\alpha$ 是 $n$ 维实列向量且 $\alpha^T\alpha&#x3D;1$，证明：$1$ 是 $PQ$ 的特征值</li><li>设 $A,B$ 为正规矩阵，且 $AB&#x3D;BA$，证明：存在酉阵 $U$ 使得 $U^{-1}AU$ 和 $U^{-1}BU$ 同时为对角阵</li><li>设 $T$ 是 $n$ 维酉空间 $V$ 上的线性变换，求证：$T$ 是正规变换的充要条件是对 $V$ 中任意的向量 $\alpha$，都有 $||T\alpha||&#x3D;||T^*\alpha||$</li><li>证明：$n$ 阶 $\mathrm{Hermite}$ 阵正定的充要条件是它的 $n$ 个顺序主子式全大于零</li><li>设 $V$ 是 $n$ 维 $\mathrm{Euclid}$ 空间，$T:V\to V$ 是可逆线性变换，证明：<ol><li>$T$ 是 $V$ 上的一个全等变换（保角、保长度）当且仅当 $T$ 是 $V$ 的正交变换</li><li>$T$ 是 $V$ 的一个相似变换（保角）当且仅当 $\exists c\gt 0,\forall \vec{\alpha},\vec{\beta}\in V$，有 $(T(\vec{\alpha}),T(\vec{\beta}))&#x3D;c(\vec{\alpha},\vec{\beta})$</li><li>$T$ 是 $V$ 的一个相似变换当且仅当 $T&#x3D;cT_0$，其中 $c\gt 0$，$T_0$ 是一个正交变换</li></ol></li><li>设 $V&#x3D;M_n(\mathbb{R})$，对于任意 $A,B\in V$，定义：$(A,B)&#x3D;\mathrm{tr}(AB^T)$，设 $P,Q$ 是 $V$ 中可逆矩阵，令 $T:V\to V$ 满足 $T(M)&#x3D;PMQ$，对于任意 $M\in V$，证明：$T$ 是一个正交变换 $\Leftrightarrow \exists c\neq 0,P^TP&#x3D;cI_n,Q^TQ&#x3D;\frac{1}{c}I_n$</li><li>设 $A,B$ 是实方阵，证明 $A,B$ 在 $\mathbb{C}$ 上相似当且仅当 $A,B$ 在 $\mathbb{R}$ 上相似</li><li>设 $T$ 是复 $n$ 维空间 $V$ 上的线性变换，$T$ 在 $V$ 的一组基下矩阵是 $A&#x3D;\begin{bmatrix}0^T &amp; -a_0\\I_{n-1} &amp; \vec{\alpha}\end{bmatrix}$，其中 $\alpha&#x3D;(-a_1,-a_2,\cdots,-a_{n-1})^T$。<ol><li>求 $T$ 的特征多项式 $f_T(\lambda)$ 和极小多项式 $m_T(\lambda)$</li><li>$T$ 是否可对角化？</li></ol></li><li>设 $A,B\in M_n(\mathbb{C})$，且 $\mathrm{rank}(AB-BA)&#x3D;1$，证明：$(AB-BA)^2&#x3D;0_{n\times n}$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学(2)</title>
    <link href="/25Spring/DiscreteMath-2/"/>
    <url>/25Spring/DiscreteMath-2/</url>
    
    <content type="html"><![CDATA[<p>大一下学期离散数学(2)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、图论"><a href="#一、图论" class="headerlink" title="一、图论"></a>一、图论</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ol><li>空图：$|E|&#x3D;0$</li><li>平凡图：$|V|&#x3D;1$</li><li>不加说明时，图指无向图</li><li>无向图<ol><li>多重图：有重边、无自环</li><li>伪图：有重边、有自环</li><li>简单图<ol start="4"><li>$k$-正则图：每个顶点的度数都为$k$</li><li>补图</li></ol></li><li>二分图</li><li>连通支：极大连通子图；连通支个数 $p(G)$</li><li>点割集、边割集、点断集、边断集<ol><li>割集：删除真子集不增加连通支数目</li><li>断集：只在连通图上有定义</li></ol></li><li>点连通度 $k(G)$：点断集的最小值</li><li>边连通度 $\lambda(G)$：边断集的最小值</li><li>块（点双连通分量）：极大的无割点联通子图</li></ol></li><li>有向图<ol><li>外邻集：直接后继</li><li>内邻集：直接前驱</li><li>度数$&#x3D;$入度$+$出度（不带负号）</li></ol></li><li>最大度：$\Delta(G)$；最小度：$\delta(G)$</li><li>导出子图：节点集或边集</li><li>图同构：对节点重新编号<ol><li>必要条件：顶点数、边数、度数列相同；存在同构的导出子图</li><li>图同胚：插入或消去 $2$ 度顶点后同构</li></ol></li><li>图的对称差：顶点取并，边取对称差</li><li>道路与回路 <ol><li>有重复边、有重复点：通路&#x2F;道路&#x2F;回路</li><li>无重复边、有重复点：简单通路&#x2F;简单回路</li><li>无重复边、无重复点：初级通路&#x2F;路径&#x2F;初级回路&#x2F;圈</li></ol></li><li>有向联通<ol><li>可达；互相可达</li><li>弱联通：不考虑方向时联通</li><li>单向联通：任意两点存在一个可达方向</li><li>强联通：任意两点互相可达</li></ol></li><li>距离 $d(u,v)$：短程线长度</li><li>弦：回路中不属于回路的边</li><li>欧拉回路：每条边恰好经过一次</li><li>哈密顿回路：每个顶点恰好经过一次</li><li>旅行商问题：完全图中最短的哈密顿回路</li><li>中国邮路：每条边至少经过一次的最短回路</li><li>最优二叉树：带权路径长度之和最小</li><li>可平面图；平面图（一个嵌入）；非平面图</li><li>$\mathrm{Jordan}$ 曲线：连续的，自身不相交的，起点和终点相重合的曲线</li><li>面&#x2F;域：平面图中不含节点及边的区域；面的次数 $\deg(R)$</li><li>极大平面图：$n\ge 3$ 的简单平面图，任意不相邻节点间加边都会破坏可平面性</li><li>极小非平面图：删除任意边后变成平面图（一定为简单图，$K_5,K_{3,3}$）</li><li>自对偶图：如轮图 $W_n$</li><li>色数：最少颜色数目；点色数 $\gamma(G)$；边色数 $\gamma^\prime(G)$；面色数 $\gamma^{\prime\prime}(G)$</li><li>极大匹配；最大匹配；交互道路；可增广道路；完全匹配；完美匹配；覆盖</li></ol><h3 id="2-道路与回路"><a href="#2-道路与回路" class="headerlink" title="2. 道路与回路"></a>2. 道路与回路</h3><ol><li>握手定理</li><li>割点的性质<ol><li>存在与 $v$ 不同的两个顶点 $u$ 和 $w$，使得任一条 $u$ 到 $w$ 的道路 $P_{uw}$ 都经过 $v$</li><li>图 $V-v$ 可以划分为两个顶点集 $U$ 和 $W$，使得对任意顶点 $u\in U$ 和 $w\in W$，顶点 $v$ 都在每条道路 $P_{uw}$ 上</li></ol></li><li>割边（桥）的性质<ol><li>边 $e$ 不属于 $G$ 的任何圈</li><li>存在 $G$ 的顶点 $u$ 和 $w$，使 $e$ 属于 $u$ 和 $w$ 的任何一条道路 $P_{uw}$</li><li>图 $G-e$ 可以划分为两个顶点集 $U$ 和 $W$，使得对任意顶点 $u\in U$ 和 $w\in W$，道路 $P_{uw}$ 都经过 $e$</li></ol></li><li>去掉点割集后连通分支数 $\ge 2$，去掉边割集后连通分支数 $&#x3D;2$（去掉一条边最多让连通分支数 $+1$）</li><li>连通图中，$k(G)\le \lambda(G)\le \delta(G)$</li><li>块的性质<ol><li>$G$ 的任何两个顶点同属某一初级回路</li><li>$G$ 的任何一个顶点和任何一条边同属某个初级回路</li><li>$G$ 的任何两条边同属某个初级回路</li><li>给定两个点 $u,v$ 和一条边 $e$，存在一条包含 $e$ 的初级道路 $P_{uv}$</li><li>对 $G$ 的任意三个不同的顶点，存在一条包含它们的初级道路</li><li>对 $G$ 的任意三个不同的顶点，存在一条只包含其中两点而不含第三点的道路</li></ol></li><li>连通图的 $k$ 笔画<ol><li>无向图：$2k$ 个奇点（均为偶点则为欧拉图）</li><li>有向图：出度入度不平衡数（均平衡则为欧拉图）</li></ol></li><li>哈密顿图判定<ol><li>证伪<ol><li>带有 $1$ 度顶点的图没有哈密顿回路</li><li>$2$ 度顶点的两条边属于任何哈密顿回路</li><li>有割点的图不是哈密顿图</li><li>二分哈密顿图中 $|V_1|&#x3D;|V_2|$</li></ol></li><li>充分条件<ol><li>$\mathrm{H}$ 回路：简单图中任意两点 $d(u)+d(v)\ge n$</li><li>$\mathrm{H}$ 道路：简单图中任意两点 $d(u)+d(v)\ge n-1$</li></ol></li><li>必要条件<ol><li>$\mathrm{H}$ 回路：$p(G-S)\le |S|$，$S$ 为任意顶点集（能排成一个圈）</li><li>$\mathrm{H}$ 道路：$p(G-S)\le |S|+1$，$S$ 为任意顶点集</li></ol></li><li>充要条件<ol><li>简单图中 $u,v$ 不相邻且 $d(u)+d(v)\ge n$，则 $G$ 有 $\mathrm{H}$ 回路等价于 $G+(u,v)$ 有 $\mathrm{H}$ 回路</li><li>简单图有 $\mathrm{H}$ 回路等价于其闭合图有 $\mathrm{H}$ 回路</li></ol></li></ol></li><li>中国邮路<ol><li>充要条件<ol><li>每条边最多重复一次</li><li>$G$ 的任意一个回路上，重复边的长度之和不超过该回路长度的一半</li></ol></li><li>欧拉图：欧拉回路</li><li>半欧拉图：欧拉道路 $+$ 奇点间最短路</li><li>非欧拉图：重复某些边后的欧拉回路<ol><li>奇偶点图上作业法：补全奇点 $\to $ 检查回路 $\to $ 翻转回路</li><li>最小权匹配法：奇点集全源最短路 $\to $ 最小权匹配 $\to $ 重复边</li></ol></li><li>有向图<ol><li>添加超发超收点 $v_s,v_t$</li><li>求 $d(v_s)$ 条过以 $v_s, v_t$ 为两端点的形如 $(v_s, v_i), (v_j, v_t)$，每边一次且仅一次的总和最小的 $P_{st}$ 道路，记下 $G$ 中各边在这些道路里的重复次</li></ol></li></ol></li></ol><h3 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h3><ol><li>树的性质<ol><li>任意两个顶点之间存在唯一的路径</li><li>无回路，且 $m&#x3D;n-1$</li><li>连通，且 $m&#x3D;n-1$</li><li>连通，且任何边均为割边</li><li>没有回路，但在任何两个不同的顶点之间加一条新边，在所得图中得到唯一一个含新边的回路</li></ol></li><li>基本关联矩阵的性质（有向连通图）<ol><li>关联矩阵&#x2F;基本关联矩阵的秩为 $n-1$</li><li>关联矩阵&#x2F;基本关联矩阵中回路所对应的各列线性相关</li><li>基本关联矩阵中行列式非零的 $n-1$ 阶子阵对应支撑树</li><li>关联矩阵任意子阵的行列式为 $0$ 或 $\pm 1$</li></ol></li><li>支撑树的计数<ol><li>有向图：$\det(B_kB_k^T)$</li><li>无向图：任意加方向变成有向图</li><li>含边：总数 $-$ 不含（去边）或缩点</li><li>根树：$\det(\vec{B_k}B_k^T),\vec{B_k}$ 为 $B_k$ 中将 $1$ 变成 $0$</li></ol></li><li>基本回路矩阵的性质（有向连通图）<ol><li>基本回路：余树边所对应的回路，方向与余树边相同</li><li>基本回路矩阵调换顺序后变成 $[I,C_{f_{12}}]$，$I$ 对应余树</li><li>关联矩阵与完全回路矩阵的边对应时，$BC_e^T&#x3D;0$</li><li>基本回路矩阵&#x2F;完全回路矩阵的秩为 $m-n+1$</li><li>回路矩阵：由任意 $m-n+1$ 条线性无关的回路所组成的矩阵<ol><li>同样满足 $BC^T&#x3D;0$</li><li>可由基本回路矩阵做可逆变换得到</li></ol></li><li>回路矩阵中行列式非零的 $m-n+1$ 阶子阵对应余树</li><li>若基本关联矩阵和基本回路矩阵的边次序相同，则 $C_{f_{12}}&#x3D;-B_{11}^TB_{12}^{-T}$</li></ol></li><li>基本割集矩阵的性质（有向连通图）<ol><li>基本割集：树边所对应的割集，方向与树边相同</li><li>基本割集矩阵调换顺序后变成 $[S_{f_{11}},I]$，$I$ 对应树</li><li>完全回路矩阵与完全割集矩阵的边对应时，$S_eC_e^T&#x3D;0$</li><li>基本割集矩阵&#x2F;完全割集矩阵的秩为 $n-1$</li><li>割集矩阵：由任意 $n-1$ 个线性无关的割集所组成的矩阵<ol><li>同样满足 $SC^T&#x3D;0$</li><li>可由基本割集矩阵做可逆变换得到</li></ol></li><li>割集矩阵中行列式非零的 $n-1$ 阶子阵对应树</li><li>若基本割集矩阵与基本回路矩阵的边次序相同，则 $S_{f_{11}}&#x3D;-C_{f_{12}}^T&#x3D;B_{12}^{-1}B_{11}$</li></ol></li></ol><h3 id="4-平面、对偶与染色"><a href="#4-平面、对偶与染色" class="headerlink" title="4. 平面、对偶与染色"></a>4. 平面、对偶与染色</h3><ol><li>$\mathrm{Jordan}$ 曲线定理：连接 $\mathrm{int}J$ 的点和 $\mathrm{ext}J$ 的点的任何连线必在某点和 $J$ 相交<ol><li>推论：$K_5$ 是非平面图</li></ol></li><li>不是割边的边必为某两个域的公共边界（割边 $\deg$ 数两次）</li><li>测地变换<ol><li>可平面等价于可球面</li><li>可将任何一个内部域改换为外部域</li></ol></li><li>平面图的判定定理<ol><li>平面图的任何子图都是平面图</li><li>$K_n(n\le 4),K_{1,n}(n\ge 1),K_{2,n}(n\ge 2)$ 是平面图</li><li>$K_n(n\ge 5),K_{3,n}(n\ge 3)$ 是非平面图</li><li>重边和自环不影响可平面性</li><li>$\mathrm{Kuratowski}$ 定理：图 $G$ 是平面图当且仅当：<ol><li>$G$ 中不含与 $K_5,K_{3,3}$ 同胚的子图</li><li>$G$ 中不含可边收缩到 $K_5,K_{3,3}$ 的子图</li></ol></li></ol></li><li>平面图与点数、边数、面数<ol><li>$\sum \deg(R_i)&#x3D;2m$</li><li>$\mathrm{Euler}$ 定理：$n-m+r&#x3D;p(G)+1$</li><li>简单连通平面图中，若每个域边界数至少为 $t$，则 $m\le (n-2)\frac{t}{t-2}$</li><li>简单连通平面图为极大平面图 $\Leftrightarrow \forall R_i,\deg(R_i)&#x3D;3 \Rightarrow 3r&#x3D;2m$</li><li>极大平面图 $m&#x3D;3n-6,r&#x3D;2n-4$</li><li>简单连通平面图 $m\le 3n-6,r\le 2n-4$</li><li>简单连通平面图中 $\delta \le 5$</li></ol></li><li>平面图的判定算法<ol><li>检测每个连通支，移去连通支中的割点，检测每个块</li><li>移去自环，消去 $2$ 度顶点，移去重边，直到无法继续进行</li><li>若 $m\lt 9$ 或 $n\lt 5$，则是平面图</li><li>若 $m\gt 3n-6$，则是非平面图</li></ol></li><li>对偶图的性质<ol><li>有且仅有平面图有对偶图，且对偶图唯一</li><li>同构的两个图，对偶图不一定同构</li><li>对偶图是连通图</li><li>对偶图是平面图</li><li>对偶图中的割集对应原图中的圈</li></ol></li><li>特例图的点色数<ol><li>奇圈：$3$；偶圈：$2$</li><li>奇阶轮图：$4$；偶阶轮图：$3$</li><li>$\gamma(G)&#x3D;2 \Leftrightarrow G$ 是二分图 $\Leftrightarrow G$ 无奇圈</li><li>树：$2$</li><li>平面连通图 $G$ 的域可 $2$ 着色当且仅当 $G$ 是欧拉图</li></ol></li><li>点色数的估计与确定<ol><li>对于任意不含自环的图，有 $\gamma(G)\le \Delta(G)+1$</li><li>若连通图 $G$ 不是完全图，也不是奇圈，则 $\gamma(G)\le \Delta(G)$</li><li>$\mathrm{Welch-Powell}$ 近似算法：按度数从大到小排列，逐个染色</li><li>记 $\mathring{G_{ij}},\overline{G_{ij}}$ 分别为 收缩和连接 $i,j$ 后的图，则 $\gamma(G)&#x3D;\min\{\gamma(\mathring{G_{ij}}),\gamma(\overline{G_{ij}})\}$</li></ol></li><li>点色数多项式<ol><li>$f(G,t)$：最多用 $t$ 种颜色染色 $\Rightarrow t\lt \gamma(G),f(G,t)&#x3D;0$</li><li>记 $m_i$ 为正好用 $t$ 种颜色染色，则 $m_i$ 只有在 $\gamma(G)\le i\le \min\{t,n\}$ 时才不为零，$\displaystyle f(G,t)&#x3D;\sum_{i&#x3D;1}^n m_iC(t,i)$</li><li>$f(K_n,t)&#x3D;t(t-1)(t-2)\cdots(t-n+1)$</li><li>$f(T_n,t)&#x3D;t(t-1)^{n-1}$</li><li>$f(G,t)&#x3D;f(\overline{G_{ij}},t)+f(\mathring{G_{ij}},t)$</li></ol></li><li>边着色<ol><li>转化为点着色：每个边上取一个点；两条边若关联于同一个点则连一条边</li><li>$\mathrm{Vizing}$ 定理：简单图中 $\Delta(G)\le \gamma^\prime(G)\le \Delta(G)+1$</li><li>特例边色数<ol><li>偶圈：$2$；奇圈：$3$</li><li>轮图 $W_n$：$n-1$</li><li>奇完全图 $K_n$：$n$；偶完全图：$n-1$</li></ol></li></ol></li><li>面着色<ol><li>等价于对偶图的点着色</li><li>六色定理、五色定理、四色定理</li><li>若任意 $3-$ 正则平面图可面 $4$ 着色，则四色猜想成立</li><li>哈密顿平面图可面 $4$ 着色</li><li>$\mathrm{Tait}$ 猜想：任意 $3-$ 正则平面图都是哈密顿图（不成立）</li></ol></li></ol><h3 id="5-匹配与网络流"><a href="#5-匹配与网络流" class="headerlink" title="5. 匹配与网络流"></a>5. 匹配与网络流</h3><ol><li>可增广道路一定包含奇数条边，且其中不属于原匹配的边多一条</li><li>$M$ 为 $G$ 的最大匹配，当且仅当 $G$ 中不含关于 $M$ 的可增广道路</li><li>$\mathrm{Hall}$ 定理（相异性条件）：二分图中存在 $V_1$ 到 $V_2$ 的完全匹配当且仅当 $V_1$ 中任意 $k$ 个顶点至少与 $V_2$ 中的 $k$ 个顶点相邻</li><li>$k$ 条件：若 $V_1$ 中的每个顶点度数都不少于 $k$，$V_2$ 中的每个顶点度数都不大于 $k$，则 $G$ 中存在 $V_1$ 到 $V_2$ 的完全匹配</li><li>二分图中从 $X$ 到 $Y$ 的最大匹配数是 $|X|-\delta (G)$，其中 $A$ 为 $X$ 中任意个数节点的子集，$\displaystyle \delta (G)&#x3D;\max_{A\subseteq X} \delta (A),\delta (A)&#x3D;|A|-|N(A)|$，$N(A)$ 为 $A$ 的邻接点集</li><li>$\mathrm{König}$ 定理：二分图中最大匹配数等于最小覆盖数</li><li>网络流图中，其最大流量等于其最小割切的容量</li></ol><h3 id="6-证明与建模"><a href="#6-证明与建模" class="headerlink" title="6. 证明与建模"></a>6. 证明与建模</h3><ol><li>道路与回路<ol><li>证明：非空简单图中一定存在度相同的顶点</li><li>证明：对于任意 $(n+1)^2$ 项的递增的自然数列，要么存在 $n+3$ 项的子列，使任一项能整除此子列中它后面的每一项；要么存在 $n+1$ 项的子列，使此子列中任一项不能整除此子列中它后面的任何一项</li><li>证明：无向图中若所有点度数 $\ge 2$，则存在回路</li><li>证明：若连通图的最长道路不唯一，则它们必定相交</li><li>证明：简单图中若每个顶点度数 $\ge 3$，则存在带弦的回路</li><li>证明：$6$ 个人中或者有 $3$ 个人互相认识，或者有 $3$ 个人互相不认识</li><li>证明：$9$ 个人中若非至少有 $4$ 个人互相认识，则至少有 $3$ 个人互相不认识</li><li>证明：在有 $k$ 个连通支的简单图中，$m\le \frac{1}{2}(n-k+1)(n-k)$</li><li>证明：简单图中，若 $n\ge 4,m\ge 2n-3$，则含有带弦的回路</li><li>证明：简单连通图中，$k(G)\le \lceil \frac{2m}{n} \rceil$</li><li>证明：在不含 $K_3$ 的简单图中，<ol><li>$\sum d^2(v_i)\le mn$（技巧：所有顶点的邻居的度数之和为 $\sum d^2(v_i)$）</li><li>$(\mathrm{Mantel})$ $m\le \frac{1}{4}n^2$</li></ol></li><li>设 $G$ 是有 $n$ 个顶点的简单图，其最小度 $\delta(G)\ge \frac{n+q}{2}$，证明 $G$ 中存在包含任意 $q$ 条互补相邻边的哈密顿回路</li><li>对任意 $n\ge 3$，在 $K_n$ 中有多少个无公共边的哈密顿回路？</li></ol></li><li>树<ol><li>定义树的中心为以其为端点的最长初级道路长度最小的顶点，证明：任意一棵树至多有两个中心，且当有两个中心时，这两个中心相邻</li><li>证明：对于一棵 $2n$ 个顶点的树 $T$，有完美匹配当且仅当对于任意顶点 $u$，从 $T$ 中删去 $u$ 得到的导出子图 $T-u$ 的若干个连通分支中，恰有一个连通分支的点数为奇数</li><li>设 $G$ 是无向图，对任意顶点 $v\in V(G)$，$G-v$ 仍是连通图，而且 $G$ 的基本割集矩阵 $S_f$ 的每一行都有偶数个 $1$ 元素，证明 $G$ 中有欧拉回路</li></ol></li><li>平面、对偶与染色<ol><li>证明：无法将五边形分割成有限个三角形且无奇点</li><li>证明：顶点数 $n\lt 12$ 的平面图的点和域都是 $4-$ 可着色的</li><li>设简单平面图 $G$ 的顶点数 $n\ge 4$，证明 $G$ 中至少有 $4$ 个顶点的度不大于 $5$</li><li>设 $G$ 是每个面都是三角形的平面图，现用 $3$ 种颜色对它的所有顶点任意着色，证明：顶点上恰好得到了这 $3$ 种颜色的面的数目是偶数个</li><li>证明：边数 $\lt 30$ 的简单平面图可以点 $4-$ 可着色</li><li>设 $G$ 是有 $n$ 个顶点的 $k-$ 正则图，证明：$G$ 的点色数 $\le \frac{n}{n-k}$</li><li>证明：若简单平面图中 $r\lt 12$，且每个点度数 $\ge 3$，则至少有一个域的边界数 $\lt 5$</li></ol></li><li>建模题<ol><li>穿行房间问题（对偶图）</li><li>计算机编码盘设计（欧拉图）</li><li>打鸟、放机器人（二分图匹配）</li><li>工作任务分配、逃生路线（网络流）</li></ol></li></ol><h3 id="7-图论算法"><a href="#7-图论算法" class="headerlink" title="7. 图论算法"></a>7. 图论算法</h3><ol><li>图的代数表示<ol><li>邻接矩阵</li><li>权矩阵</li><li>关联矩阵</li><li>边列表</li><li>正向表：节点从 $0$ 开始编号；$[A_i,A_{i+1})$；$A$ 长度 $n+1$</li><li>邻接表</li><li>十字链表</li></ol></li><li>连通性<ol><li>全源：$\mathrm{Warshall}$ 算法</li><li>单源：$\mathrm{BFS,DFS}$</li></ol></li><li>构造欧拉图<ol><li>找回路 $\to $ 余图找新回路 $\to $ 以公共点为起末连接</li></ol></li><li>旅行商问题<ol><li>分支定界：按边权从小到大排序 $(O(n!))$</li><li>近似算法：插点法 $(O(n^2))$</li><li>近似解&#x2F;最优解 $\lt 2$</li></ol></li><li>最短路<ol><li>单源正边权：$\mathrm{Dijkstra}$ 算法 $(O(n^2))$</li><li>单源负边权：$\mathrm{Bellman-Ford}$ 算法 $(O(nm))$</li><li>单源 $1$ 边权：$\mathrm{BFS}$ $(O(m))$</li><li>全源：$\mathrm{Floyd}$ 算法 $(O(n^3))$</li><li>$\mathrm{Bellman-Ford}$ 负环不终止，$\mathrm{Floyd}$ 不正确</li></ol></li><li>关键路径<ol><li>$\mathrm{PT}$ 图拓扑排序</li><li>最大允许延误时间：反向求最晚启动时间，再相减</li></ol></li><li>支撑树的生成：避圈法</li><li>最小支撑树<ol><li>$\mathrm{Prim}$ 算法 $(O(n^2)\to O(m\log n))$</li><li>$\mathrm{Kruskal}$ 算法 $(O(m+p\log m),p\in (n,m))$</li><li>判断是否形成回路：并查集<ol><li>优化 1：路径压缩</li><li>优化 2：小并入大&#x2F;低并入高</li></ol></li><li>稠密图用 $\mathrm{Prim}$，稀疏图用 $\mathrm{Kruskal}$</li></ol></li><li>最优二叉树<ol><li>$\mathrm{Huffman}$ 算法：按权值从小到大排序，两两合并</li><li>应用：编码<ol><li>前缀码：若字符串集合中两两互不为前缀</li><li>二元前缀码：只出现 $0,1$ 的前缀码</li><li>最佳前缀码：由最优二叉树产生的二元前缀码</li><li>最佳前缀码不唯一（左右可互换）</li></ol></li></ol></li><li>二分图匹配<ol><li>最大匹配：匈牙利算法 $(O(mn))$</li><li>最佳匹配：网络流</li></ol></li><li>网络流<ol><li>最大流：$\mathrm{Ford-Fulkerson}$ 算法</li></ol></li></ol><h2 id="二、群论"><a href="#二、群论" class="headerlink" title="二、群论"></a>二、群论</h2><h3 id="1-代数系统"><a href="#1-代数系统" class="headerlink" title="1. 代数系统"></a>1. 代数系统</h3><ol><li>基本定义<ol><li>代数系统：非空集合、运算满足映射条件且封闭</li><li>同类型代数系统：都是 $k_i$ 元运算</li><li>同构映射：双射且 $f(a\circ b)&#x3D;f(a)*f(b)$</li><li>同态映射：可以不是双射（单射：单一同态；满射：满同态，$X\cong Y$，$Y$ 是 $X$ 的同态像）</li><li>子代数系统：非空子集、封闭</li></ol></li><li>基本定理<ol><li>若左右单位元同时存在，则两者相等且为唯一单位元</li><li>有结合律时若左右逆元同时存在，则两者相等且为唯一逆元</li><li>同态映射的像构成子代数系统</li><li>满同态保交换律、结合律、单位元、逆元</li></ol></li></ol><h3 id="2-群的基本概念"><a href="#2-群的基本概念" class="headerlink" title="2. 群的基本概念"></a>2. 群的基本概念</h3><ol><li>基本定义<ol><li>半群：非空集合、二元运算、封闭、结合律</li><li>幺群（含幺半群）：半群、单位元</li><li>交换幺群：幺群、交换律</li><li>循环幺群：存在生成元（一定是交换幺群）</li><li>子半群：非空子集、封闭</li><li>子幺群：非空子集、封闭、单位元在子集内</li><li>群：幺群、逆元</li><li>交换群（阿贝尔群）：群、交换律</li><li>$\mathrm{Klein}$ 四元群：$\{e,a,b,c\},a^2&#x3D;e,ab&#x3D;c$</li><li>平凡群：只含单位元的群</li><li>元素的阶：$O\langle a\rangle$</li><li>子群：非空子集、封闭、单位元和逆元在子集内</li></ol></li><li>群的判定定理<ol><li>有限半群上的运算若满足消去律，则为群（无限半群不一定，如正整数乘法）</li><li>若半群有左单位元和左逆元，则为群</li><li>半群中若对任意两个元素 $a,b$，$ax&#x3D;b,ya&#x3D;b$ 有解，则为群</li><li>非空子集是子群<strong>等价于</strong> $ab^{-1}\in H$</li></ol></li><li>元素的阶<ol><li>小于等于群的阶</li><li>与其逆元的阶相等</li><li>推论：对有限阶元素 $a,b$，$O\langle b^{-1}ab\rangle&#x3D;O\langle a\rangle, O\langle ab\rangle&#x3D;O\langle ba\rangle$</li><li>存在所有元素的阶都有限的无限群（如自然数幂集上的对称差）</li></ol></li><li>子群的性质<ol><li>两个子群的交集仍然是子群</li><li>$\{a^k\}$ 是子群</li><li>$HH&#x3D;H$ 不能推出 $H$ 是子群：取 $G&#x3D;\{\mathbb{Q}-\{0\},*\}$，$H$ 为全体奇数（没有逆元）</li><li>不存在群是其两个真子群的并</li><li>存在群是其三个真子群的并：取 $G&#x3D;K_4,H_1&#x3D;\{e,a\},H_2&#x3D;\{e,b\},H_3&#x3D;\{e,c\}$</li><li>不存在只有有限个子群的无限群：分有无无限阶元素讨论</li></ol></li></ol><h3 id="3-特殊的群"><a href="#3-特殊的群" class="headerlink" title="3. 特殊的群"></a>3. 特殊的群</h3><ol><li>循环群<ol><li>无限阶循环群只有生成元 $a,a^{-1}$，有限阶循环群有 $\varphi(O(a))$ 个生成元（$\varphi$：小于 $n$ 且与 $n$ 互素）</li><li>无限阶循环群的子群仍是无限阶循环群</li><li>$n$ 阶循环群的子群生成元阶数是 $n$ 的因子，且每个因子都只对应一个子群</li><li>无限阶循环群与 $(\mathbb{Z},+)$ 同构，$n$ 阶循环群与 $(\mathbb{Z}_n,+)$ 同构</li></ol></li><li>变换群与置换群<ol><li>非空集合上的映射称为一个变换，有限集合上的一一变换称为 $n$ 元置换</li><li>非空集合 $A$ 的所有一一变换关于变换的乘法所构成的群叫做 $A$ 的一一变换群，记作 $E(A)$，$E(A)$ 的子群叫做变换群</li><li>$S(n)$：$n!$ 个 $n$ 元置换的集合，$S(n)$ 关于置换乘法的群叫做 $n$ 次对称群，其子群叫做置换群</li><li>不相交的轮换满足交换律</li><li>任何 $n$ 元置换都可以唯一地表示为不相交的轮换的乘积</li><li>任何一个轮换都可表示成对换的乘积，且不唯一</li><li>置换的逆序数与其对换表示中对换个数的奇偶性相同（奇置换、偶置换）</li><li>偶置换关于置换乘法构成的群叫做交错群，记作 $A(n)$</li><li>$\mathrm{Cayley}$ 定理：任意群与一个变换群同构（$n$ 阶有限群与 $S(n)$ 的一个子群同构）</li><li>轮换计算技巧：首尾相接</li></ol></li></ol><h3 id="4-群的分解"><a href="#4-群的分解" class="headerlink" title="4. 群的分解"></a>4. 群的分解</h3><ol><li>陪集的性质<ol><li>设 $H$ 是 $G$ 的子群，则 $a\in H\Leftrightarrow aH&#x3D;H$</li><li>$\forall x\in aH,xH&#x3D;aH$，并称 $a$ 是 $aH$ 的陪集代表</li><li>$aH&#x3D;bH\Leftrightarrow a\in bH$ 或 $b\in aH\Leftrightarrow b^{-1}a\in H$ 或 $a^{-1}b\in H$</li><li>若非 $aH&#x3D;bH$，则 $aH\cap bH&#x3D;\emptyset$</li></ol></li><li>群的陪集分解<ol><li>群 $G$ 关于其子群 $H$ 的左陪集的个数称为 $H$ 在 $G$ 中的指数，记作 $[G:H]$</li><li>$\mathrm{Lagrange}$ 定理：$|G|&#x3D;[G:H]|H|$（子群的阶是群的阶的因子）</li><li>推论：$n$ 阶群中任意元素的阶都是 $n$ 的因子（素数阶的群是循环群）</li><li>推论：设 $A,B$ 是 $G$ 的有限子群，则 $|AB||A\cap B|&#x3D;|A||B|$</li></ol></li><li>正规子群与商群<ol><li>定义：$\forall a\in G,aH&#x3D;Ha$，记作 $H\triangleleft G$</li><li>判定定理：$H\triangleleft G\Leftrightarrow \forall g\in G,h\in H,ghg^{-1}\in H$</li><li>若 $A,B$ 是正规子群，则 $AB,A\cap B$ 也是正规子群</li><li>若 $A$ 是正规子群，$B$ 是子群，则 $A\cap B$ 是 $B$ 的正规子群，$AB$ 是 $G$ 的子群</li><li>设 $H$ 是正规子群，$G&#x2F;H$ 表示 $H$ 的所有陪集构成的集合，则 $G&#x2F;H$ 关于陪集乘法构成群，称为 $G$ 关于 $H$ 的商群</li><li>商群性质：$aHbH&#x3D;abH$</li></ol></li></ol><h3 id="5-环与域"><a href="#5-环与域" class="headerlink" title="5. 环与域"></a>5. 环与域</h3><ol><li>环<ol><li>定义：$(R,+,\cdot),$(R,+)$ 是交换群，$(R,\cdot)$ 是半群，乘法分配律</li><li>加法群、零元、负元；乘法半群（单位元）</li><li>$ab&#x3D;0,a\neq 0,b\neq 0$，称 $a$ 为左零因子，$b$ 为右零因子</li><li>零因子：既左又右（注意：零元不是零因子）</li><li>乘法消去律成立当且仅当没有左右零因子</li><li>有单位环：乘法半群有单位元</li><li>交换环：乘法半群满足交换律</li><li>整环：没有零因子的交换环</li><li>除环：每个非零元都有乘法逆元</li></ol></li><li>理想<ol><li>定义：对子加法群 $(D,+)$，左理想：$\forall a\in R,aD\subseteq D$，右理想：$Da\subseteq D$</li><li>理想：既左又右；平凡理想（$R,\{0\}$）；真理想；单环（没有真理想的环）</li><li>主理想：可交换环，$(a)&#x3D;Ra$ 称为由 $a$ 生成的主理想，$aR&#x3D;Ra$</li></ol></li><li>域<ol><li>定义：可交换的除环</li><li>充要条件：有乘法单位元的交换单环</li></ol></li></ol><h3 id="6-例题"><a href="#6-例题" class="headerlink" title="6. 例题"></a>6. 例题</h3><ol><li>证明：$6$ 阶群一定存在一个 $3$ 阶子群</li><li>设 $G$ 是群，$H_1,H_2$ 是 $G$ 的子群，证明：$H_1H_2$ 是 $G$ 的子群当且仅当 $H_1H_2&#x3D;H_2H_1$</li><li>证明：有限半群中一定存在 $x^2\in S$，满足 $x^2&#x3D;x$，但无限半群中不一定</li><li>设 $G$ 是群，$x,y\in G$，称所有形如 $xyx^{-1}y^{-1}$ 的元素为换位子，群 $G$ 的所有换位子构成的子群称为 $G$ 的换位子群 $G^{\prime}$，证明：<ol><li>$G^{\prime}$ 是 $G$ 的正规子群</li><li>$G&#x2F;G^{\prime}$ 是交换群</li></ol></li><li>$(2024)$ 证明：有限 $\mathrm{Abel}$ 群 $G$ 中，$\displaystyle \prod_{g\in G} g&#x3D;\prod_{a\in G,a^2&#x3D;e} a$，其中 $e$ 是 $G$ 的单位元</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理B(1)</title>
    <link href="/25Spring/Physics-B1/"/>
    <url>/25Spring/Physics-B1/</url>
    
    <content type="html"><![CDATA[<p>大一下学期大学物理B(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、力学"><a href="#一、力学" class="headerlink" title="一、力学"></a>一、力学</h2><h3 id="1-牛顿运动定律"><a href="#1-牛顿运动定律" class="headerlink" title="1. 牛顿运动定律"></a>1. 牛顿运动定律</h3><ol><li>$v&#x3D;w\times r$</li><li>$[F]&#x3D;MLT^{-2}$</li><li>物体间相对静止 $\Rightarrow$ $a,v$ 相同</li><li>微分方程技巧：两边同乘 $ds$</li><li>科里奥利力：$F&#x3D;2mv\times \omega$</li><li>傅科摆周期：$T&#x3D;\frac{24h}{\sin \phi}$</li></ol><h3 id="2-动量"><a href="#2-动量" class="headerlink" title="2. 动量"></a>2. 动量</h3><ol><li>动量定理、动量守恒定律仅适用于惯性系（若要在非惯性系，应考虑惯性力）</li><li>动量若在某一惯性系下守恒，则在任意惯性系下守恒</li><li>系统内力不影响系统总动量</li><li>质心系是零动量参考系</li></ol><h3 id="3-角动量"><a href="#3-角动量" class="headerlink" title="3. 角动量"></a>3. 角动量</h3><ol><li>角动量：$L&#x3D;r\times p$</li><li>角动量定理：$\frac{dL}{dt}&#x3D;M&#x3D;r\times F,\int Mdt&#x3D;L_2-L_1$</li><li>角动量守恒：平衡或有心力</li><li>角动量定理、角动量守恒仅适用于惯性系</li><li>系统内力矩不影响系统总角动量</li><li>质点系对原点的角动量$&#x3D;$质心对原点的角动量$+$质点系对质心的角动量</li><li>角动量定理在质心系中适用</li></ol><h3 id="4-功"><a href="#4-功" class="headerlink" title="4. 功"></a>4. 功</h3><ol><li>功的数值取决于参考系的选取</li><li>内力能改变系统的总动能</li><li>动能定理、功能原理仅适用于惯性系</li><li>柯尼希定理：质点系总动能$&#x3D;$质心动能$+$质点系相对质心的动能</li><li>一对力的功$&#x3D;$其中一个质点受的力沿着它相对于另一个质点移动的路径所做的功（与参考系的选取无关）</li><li>推论：静摩擦力的功为零、正压力的功为零、滑动摩擦力的功为负</li><li>机械能守恒定律仅适用于惯性系，且在一个惯性系中机械能守恒并不代表在其他惯性系中机械能守恒</li><li>功能原理、机械能守恒定律在质心系中适用</li><li>伯努利原理：$P+\frac{1}{2}\rho v^2+\rho gh&#x3D;\mathrm{const}$</li></ol><h3 id="5-刚体转动"><a href="#5-刚体转动" class="headerlink" title="5. 刚体转动"></a>5. 刚体转动</h3><ol><li>一般选取质心或瞬心为基点</li><li>$a&#x3D;\alpha \times r+\omega \times v$（旋转加速度$+$向轴加速度）</li><li>定轴转动定律：$M&#x3D;J\alpha,J&#x3D;\sum m_ir_i^2$</li><li>常用转动惯量<ol><li>细圆环或圆筒：$J&#x3D;mR^2$</li><li>均匀圆盘或圆柱：$J&#x3D;\frac{1}{2}mR^2$</li><li>均匀细杆绕一端转动：$J&#x3D;\frac{1}{3}mL^2$</li><li>均匀细杆绕中点转动：$J&#x3D;\frac{1}{12}mL^2$</li><li>球的转动惯量：$J&#x3D;\frac{2}{5}mR^2$</li></ol></li><li>平行轴定理：$J&#x3D;J_{\mathrm{cm}}+md^2$</li><li>对薄平板的正交轴定理：$J_z&#x3D;J_x+J_y$</li><li>推论：薄圆盘一条直径轴转动：$J&#x3D;\frac{1}{4}mR^2$</li><li>力矩的功：$W&#x3D;\int M\mathrm{d}\theta$</li><li>定轴转动动能：$E_k&#x3D;\frac{1}{2}J\omega^2$</li><li>定轴转动角动量定理：$\frac{\mathrm{d}L}{\mathrm{d}t}&#x3D;\frac{\mathrm{d}(J\omega)}{\mathrm{d}t}&#x3D;M$</li><li>定轴转动角动量守恒：$M&#x3D;0,L&#x3D;J\omega&#x3D;\mathrm{const}$</li></ol><h3 id="6-振动"><a href="#6-振动" class="headerlink" title="6. 振动"></a>6. 振动</h3><ol><li>简谐运动的判据<ol><li>运动学方程、弹性力</li><li>动力学方程：$\frac{\mathrm{d}^2x}{\mathrm{d}t^2}&#x3D;-\omega^2x$</li><li>能量特点：守恒 $+ E_p&#x3D;\frac{1}{2}kx^2$</li></ol></li><li>简谐运动的特征量<ol><li>$A&#x3D;\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}$</li><li>$\tan\varphi&#x3D;-\frac{v_0}{\omega x_0}$</li></ol></li><li>简谐运动的合成<ol><li>同直线同频率同振幅，初相依次差常量：$A&#x3D;a\dfrac{\sin\frac{n\delta}{2}}{\sin\frac{\delta}{2}},\varphi&#x3D;\frac{n-1}{2}\delta+\varphi_0$</li><li>同直线不同频率：拍（一拍是半个）</li><li>相互垂直同频率：$\frac{x^2}{A_1^2}+\frac{y^2}{A_2^2}-\frac{2xy}{A_1A_2}\cos(\varphi_2-\varphi_1)&#x3D;\sin^2(\varphi_2-\varphi_1)$（旋转矢量&#x2F;相量图作图）</li><li>$y$ 相位领先则为右旋（顺时针），$x$ 相位领先则为左旋（逆时针）</li><li>相互垂直不同频率：有简单整数比时为稳定封闭曲线（李萨如图）</li></ol></li><li>阻尼振动<ol><li>运动方程：$ma&#x3D;-kx-\gamma v$</li><li>阻尼系数：$\beta&#x3D;\frac{\gamma}{2m}$</li><li>弱阻尼（$\beta\lt\omega$）：$x&#x3D;A_0e^{-\beta t}\cos(\omega t+\varphi_0),\omega&#x3D;\sqrt{\omega_0^2-\beta^2}$</li><li>鸣响时间：能量减少到起始的 $\frac{1}{e}$ 倍所需的时间</li><li>品质因数：鸣响时间内振动次数的 $2\pi $倍</li><li>过阻尼（$\beta\gt\omega$）：非周期振动</li><li>临界阻尼（$\beta&#x3D;\omega$）：刚能做非周期振动，回到平衡位置的时间最短</li></ol></li><li>受迫振动<ol><li>运动方程：$ma&#x3D;-kx-\gamma v+H\cos(\omega t)$</li><li>稳定振动解：$x&#x3D;A\cos(\omega t+\varphi),A&#x3D;\frac{H}{m\sqrt{(\omega^2-\omega_0^2)^2+4\beta^2\omega^2}},\tan\varphi&#x3D;\frac{2\beta\omega}{\omega^2-\omega_0^2}$</li></ol></li></ol><h3 id="7-波动"><a href="#7-波动" class="headerlink" title="7. 波动"></a>7. 波动</h3><ol><li>波动方程：$\frac{\partial^2y}{\partial x^2}&#x3D;\frac{1}{u^2}\frac{\partial^2y}{\partial t^2}$</li><li>形变<ol><li>线变：$\frac{F}{S}&#x3D;E\frac{\Delta l}{l_0}$，$E$：杨氏弹性模量</li><li>切变：$\frac{F}{S}&#x3D;G\frac{\Delta d}{D}$，$G$：切变弹性模量</li><li>体变：$\Delta P&#x3D;-K\frac{\Delta V}{V}$，$K$：体变弹性模量</li><li>切变弹性模量 $\lt$ 杨氏弹性模量</li></ol></li><li>波速<ol><li>弹性绳上的横波：$u&#x3D;\sqrt{\frac{F}{\rho_l}}$，$\rho_l$：线密度</li><li>固体中的纵波：$u&#x3D;\sqrt{\frac{E}{\rho}}$</li><li>固体中的横波：$u&#x3D;\sqrt{\frac{G}{\rho}}$</li><li>液体中的纵波：$u&#x3D;\sqrt{\frac{K}{\rho_0}}$，$\rho_0$：无纵波时的流体密度</li></ol></li><li>能量<ol><li>能量密度 $w&#x3D;w_k+w_p&#x3D;\frac{1}{2}\rho u^2+\frac{1}{2}E\left(\frac{\partial y}{\partial x}\right)^2$</li><li>$w_k&#x3D;w_p,\overline{w}&#x3D;\frac{1}{2}\rho \omega^2A^2$，$w$ 的圆频率为 $2\omega$</li><li>强度&#x2F;平均能流密度：$I&#x3D;\overline{S}&#x3D;\overline{w}u&#x3D;\frac{1}{2}\rho u\omega^2A^2$</li><li>媒质特性阻抗：$z&#x3D;\rho u$，$z$ 大的为波密</li></ol></li><li>折射率可以 $\lt 1$（玻璃，X光）</li><li>波的叠加原理 $\Leftrightarrow$ 波动方程的线性（振幅强度过大时形变与弹力不再呈线性，叠加原理失效）</li><li>相干条件：频率相同、振动方向相同、相位差恒定</li><li>由 $y_1&#x3D;A\cos(\omega t-kx)$ 和 $y_2&#x3D;A\cos(\omega t+kx)$ 叠加的驻波：$A_x&#x3D;|2A\cos(kx)|$</li><li>驻波不传播能量，能量被封闭在波包内</li><li>波的反射<ol><li>半波损失：波疏 $\to$ 波密反射</li><li>振幅关系：$A_1^\prime&#x3D;\left|\frac{z_1-z_2}{z_1+z_2}\right|A_1$，$A_2&#x3D;\frac{2z_1}{z_1+z_2}A_1$</li><li>反射比 $R$，透射比 $T$：能量，$R+T&#x3D;1$</li></ol></li><li>声波<ol><li>声压：有声波时的压强 $-$ 无声波时的压强</li><li>声压振幅 $P_m&#x3D;\rho_0u\omega A$</li><li>基准声强：$10^{-12}\mathrm{W&#x2F;m^2}$，痛阈：$120\mathrm{dB}$</li></ol></li><li>多普勒效应<ol><li>$S$ 和 $R$ 相互靠近时 $v_S,v_R$ 取正，风速与声速同向取正</li><li>多普勒频移：$\nu_S-\nu_R$</li><li>机械波：$\nu_R&#x3D;\frac{u+v_R+v_w}{u-v_S+v_w}\nu_S$</li><li>运动不在二者连线上时取连线上的分量</li><li>电磁波：$\nu_R&#x3D;\frac{\sqrt{c^2-v^2}}{c-|v|\cos\theta} \nu_S$</li></ol></li><li>相速度：$u&#x3D;\frac{\omega_1+\omega_2}{k_1+k_2}$，群速度：$u_g&#x3D;\frac{\omega_1-\omega_2}{k_1-k_2}$</li></ol><h2 id="二、相对论"><a href="#二、相对论" class="headerlink" title="二、相对论"></a>二、相对论</h2><h3 id="1-同时性的相对性"><a href="#1-同时性的相对性" class="headerlink" title="1. 同时性的相对性"></a>1. 同时性的相对性</h3><ol><li>沿着两个惯性系相对运动方向发生的两个事件若在甲惯性系中观察是同时发生的，则在乙惯性系中观察就不是同时发生的，而是在甲惯性系运动的后方的那个事件先发生。</li></ol><h3 id="2-运动学"><a href="#2-运动学" class="headerlink" title="2. 运动学"></a>2. 运动学</h3><ol><li>$\displaystyle \gamma&#x3D;\frac{1}{\sqrt{1-\frac{u^2}{c^2}}},\beta&#x3D;\frac{u}{c}$</li><li>$\displaystyle x^{\prime}&#x3D;\gamma(x-ut),\displaystyle t^{\prime}&#x3D;\gamma\left(t-\frac{\beta}{c}x\right)$</li><li>$\displaystyle v^{\prime}_x&#x3D;\frac{v_x-u}{1-\frac{uv_x}{c^2}},v^{\prime}_y&#x3D;\frac{v_y}{\gamma(1-\frac{uv_x}{c^2})}$</li><li>时空间隔恒等式：$c^2t^2-x^2-y^2-z^2&#x3D;\mathrm{const}.$</li></ol><h3 id="3-动力学"><a href="#3-动力学" class="headerlink" title="3. 动力学"></a>3. 动力学</h3><ol><li>保持 $F&#x3D;\frac{dp}{dt}$，$p&#x3D;mv$ 不变</li><li>$m&#x3D;m_0\gamma$</li><li>$F_n&#x3D;ma_n&#x3D;\gamma m_0a_n,F_t&#x3D;\gamma^3 m_0a_t$</li><li>保持动能定理 $dE_k&#x3D;Fd_r$ 不变</li><li>$E_k&#x3D;mc^2-m_0c^2&#x3D;m_0c^2(\gamma-1)$</li><li>孤立系统内部进行一个过程时，总能量不变，动能与静止能量之间可以相互转化</li><li>$E^2&#x3D;E_0^2+p^2c^2$</li><li>$\frac{E^2}{c^2}-p^2$ 是不变量</li><li>在 $\mathrm{Lorentz}$ 变换中，将 $x,t$ 用 $p_x,\frac{E}{c^2}$ 替换，即得动量和能量变换</li></ol><h3 id="4-光子"><a href="#4-光子" class="headerlink" title="4. 光子"></a>4. 光子</h3><ol><li>$m_0&#x3D;0$</li><li>$E&#x3D;pc$</li><li>$p&#x3D;mc&#x3D;\frac{h\nu}{c}$</li><li>$m&#x3D;\frac{E}{c^2}&#x3D;\frac{h\nu}{c^2}$</li></ol><h2 id="三、热学"><a href="#三、热学" class="headerlink" title="三、热学"></a>三、热学</h2><h3 id="1-温度与分子动理论"><a href="#1-温度与分子动理论" class="headerlink" title="1. 温度与分子动理论"></a>1. 温度与分子动理论</h3><ol><li>基本定义<ol><li>热力学系统：大量微观粒子 $+$ 体积有限</li><li>孤立系统 $\to$ 绝热系统 $\to$ 封闭系统 $\to$ 开放系统</li><li>平衡态：系统内部无宏观的粒子和能量流动，宏观性质不变（$\neq$ 稳定态）</li><li>平衡条件：力学平衡 $+$ 热平衡 $+$ 相平衡 $+$ 化学平衡</li><li>物态参量：描写平衡态的宏观物理量；物态方程：态参量间的函数关系</li></ol></li><li>基本定律<ol><li>热力学第零定律：两个系统与第三个系统处于热平衡，则它们之间也处于热平衡</li><li>热力学第三定律：热力学零度是达不到的</li><li>饱和蒸汽压 $&#x3D;$ 外压时液体沸腾</li></ol></li><li>宏观公式<ol><li>理想气体温标：水的三相点 $t_3&#x3D;0.01\degree C$；华氏温标 $t_F&#x3D;(32+1.8t_C)$</li><li>理想气体状态方程：$P&#x3D;nkT$，$n$：分子数密度</li><li>普适气体常量 $R&#x3D;8.31\mathrm{J&#x2F;(mol\cdot K)}$；玻尔兹曼常数 $k&#x3D;\frac{R}{N_A}&#x3D;1.38\times 10^{-23}\mathrm{J&#x2F;K}$</li><li>恒温气压公式：$P&#x3D;P_0e^{-\frac{Mgh}{RT}}$，$P_0$：地面气压</li><li>范氏方程：$(P+\frac{m^2}{M^2}\frac{a}{V^2})(V-\frac{m}{M}b)&#x3D;\frac{m}{M}RT$，$a,b$：分子力、分子体积修正常数，可测</li></ol></li><li>微观公式<ol><li>平均碰撞频率：$\overline{z}&#x3D;\sqrt{2}\pi d^2\overline{v}n$</li><li>平均自由程（相邻两次碰撞间的平均路程）：超过容器线度时视为 $\overline{\lambda}&#x3D;l$，真空</li><li>自由度 $i&#x3D;t+r+v&#x3D;3N$，双原子分子 $r&#x3D;2$，多原子分子 $r&#x3D;3$</li><li>能量均分定理：分子能量中每具有一个平方项，就对应一个 $\frac{1}{2}kT$ 的平均能量</li><li>分子平均能量 $&#x3D;(t+r+2v)\frac{1}{2}kT$（振动动能 $+$ 势能）；振动一般被冻结，低温下转动被冻结</li><li>速率分布函数：$f(v)&#x3D;\frac{\mathrm{d}N_v}{N\mathrm{d}v},\int_0^\infty f(v)\mathrm{d}v&#x3D;1$</li><li>无外场作用时：$f(v)&#x3D;4\pi{(\frac{m}{2\pi kT})}^{\frac{3}{2}}e^{-\frac{mv^2}{2kT}}v^2$</li><li>最概然速率 $v_p$，平均速率 $\overline{v}$，均方根速率 $\sqrt{\overline{v^2}}$：$\sqrt{2},\sqrt{\frac{8}{\pi}},\sqrt{3}\times\sqrt{\frac{kT}{m}}$，分别描述速率分布、运动快慢或碰撞、平动动能</li><li>小区间内分子数比例：$\frac{\Delta N}{N}&#x3D;\frac{4}{\sqrt{\pi}}e^{-u^2}u^2\Delta u,\Delta u&#x3D;\frac{\Delta v}{v_p}$</li><li>速度分布函数：$g(v)&#x3D;{(\frac{m}{2\pi kT})}^{\frac{1}{2}}e^{-\frac{mv^2}{2kT}},F(\vec{v})&#x3D;g(v_x)g(v_y)g(v_z)$</li><li>分子碰壁数 $\Gamma&#x3D;\frac{1}{4}n\overline{v}$（分子越轻速度越大，漏的越快）</li><li>玻尔兹曼分布律：$\mathrm{d}N&#x3D;Ce^{-\frac{\epsilon}{kT}}\mathrm{d}x\mathrm{d}y\mathrm{d}z\mathrm{d}v_x\mathrm{d}v_y\mathrm{d}v_z$，$e^{-\frac{\epsilon}{kT}}$：玻尔兹曼因子</li></ol></li><li>输运过程<ol><li>定体热容 $C_V&#x3D;\frac{\mathrm{d}Q}{\mathrm{d}T}&#x3D;\frac{\mathrm{d}E}{\mathrm{d}T}$，定体比热 $c_V&#x3D;\frac{C_V}{Nm}$，$m$：分子质量</li><li>$\kappa&#x3D;\frac{1}{3}c_Vnm\overline{v}\overline{\lambda}$，与 $\sqrt{T}$ 成正比，与 $P$ 无关（$P$ 太小时 $\overline{\lambda}$ 退化为容器线度，与 $P$ 成正比）</li><li>傅里叶定律（热传导方程）：$\mathrm{d}Q&#x3D;-\kappa(\frac{\mathrm{d}T}{\mathrm{d}x})_{x_0}\mathrm{d}S\mathrm{d}t$</li><li>粘滞系数 $\eta&#x3D;\frac{1}{3}nm\overline{v}\overline{\lambda}$</li><li>内摩擦：$\mathrm{d}f&#x3D;-\eta(\frac{\mathrm{d}v}{\mathrm{d}x})_{x_0}\mathrm{d}S$，$f$：黏力</li><li>扩散系数 $D&#x3D;\frac{1}{3}\overline{v}\overline{\lambda}$</li><li>扩散：$\mathrm{d}M&#x3D;-D(\frac{\mathrm{d}\rho}{\mathrm{d}x})_{x_0}\mathrm{d}S\mathrm{d}t$，$M$：扩散量</li></ol></li><li>数量级的概念<ol><li>分子数密度：$3\times 10^{25}\mathrm{m}^{-3}$</li><li>分子直径：$10^{-10}\mathrm{m}$</li><li>热运动平均速度：$10^2\mathrm{m&#x2F;s}$</li><li>平均碰撞次数：$10^{9}\mathrm{s}^{-1}$</li><li>平均自由程：$10^{-8}\mathrm{m}$</li></ol></li></ol><h3 id="2-热力学第一定律"><a href="#2-热力学第一定律" class="headerlink" title="2. 热力学第一定律"></a>2. 热力学第一定律</h3><ol><li>准静态过程：每一状态都无限接近于平衡态，过程时间远大于弛豫时间（如 $\tau_p&#x3D;\frac{L}{\overline{v}}$）</li><li>热力学第一定律：$Q&#x3D;\Delta E+A$，$A\gt 0$：系统对外做功，$Q\gt 0$：系统吸热，适用于<strong>任何</strong>过程</li><li>热容<ol><li>定体摩尔热容：$C_{V,m}&#x3D;\frac{1}{\nu}\left(\frac{\mathrm{d}Q}{\mathrm{d}T}\right)_V$，$\nu$：物质的量</li><li>理想气体的定体摩尔热容：$C_{V,m}&#x3D;\frac{i}{2}R$，$i$：分子自由度</li><li>定压摩尔热容：$C_{P,m}&#x3D;\frac{1}{\nu}\left(\frac{\mathrm{d}Q}{\mathrm{d}T}\right)_P$</li><li>理想气体的定压摩尔热容：$C_{P,m}&#x3D;C_{V,m}+R$</li><li>理想气体泊松比（比热比）：$\gamma&#x3D;\frac{C_{P,m}}{C_{V,m}}&#x3D;\frac{i+2}{i}$</li></ol></li><li>过程<ol><li>绝热过程：被绝热材料包围或进行的较快而来不及热交换</li><li>理想气体准静态绝热过程：$PV^\gamma&#x3D;\mathrm{const}$，$TV^{\gamma-1}&#x3D;\mathrm{const}$，$\frac{P^{\gamma-1}}{T^\gamma}&#x3D;\mathrm{const}$</li><li>理想气体多方过程：热容为常数，$PV^n&#x3D;\mathrm{const}$，$C_m&#x3D;C_{V,m}\left(\frac{\gamma-n}{1-n}\right)$</li></ol></li><li>循环与热机<ol><li>热机效率 $\eta&#x3D;\frac{A}{Q_1}&#x3D;1-\frac{|Q_2|}{Q_1}$</li><li>卡诺循环：只和两个恒温热库传递热量并对外做功的准静态无摩擦循环（两个等温 $+$ 两个绝热，顺时针）</li><li>闭合条件：$\frac{V_2}{V_1}&#x3D;\frac{V_3}{V_4}\Rightarrow \frac{Q_1}{Q_2}&#x3D;\frac{T_1}{T_2}$</li><li>致冷系数：$w&#x3D;\frac{Q_2}{A}$</li></ol></li></ol><h3 id="3-热力学第二定律"><a href="#3-热力学第二定律" class="headerlink" title="3. 热力学第二定律"></a>3. 热力学第二定律</h3><ol><li>热力学第二定律的表述<ol><li>克劳修斯表述：热量不能<strong>自动的</strong>从低温物体传向高温物体 <strong>（制冷机不是自发过程）</strong></li><li>开尔文表述：其<strong>唯一效果</strong>为热全部转变为功的过程是不可能的 <strong>（等温膨胀伴随了体积变化）</strong></li><li>一切自发的宏观过程都是不可逆的</li><li>不可逆过程反向进行时系统和外界不能完全恢复原状 <strong>（不是不能反向进行）</strong></li></ol></li><li>玻尔兹曼熵公式：$S&#x3D;k\ln\Omega$，$\Omega$：微观状态数，具有可加性</li><li>可逆过程：无摩擦、准静态，包括卡诺循环</li><li>克劳修斯等式：对可逆过程，$\oint \frac{\mathrm{d}Q}{T}&#x3D;0$</li><li>克劳修斯熵：$S_2-S_1&#x3D;\int_{1}^{2}\frac{\mathrm{d}Q}{T},\mathrm{d}Q&#x3D;TdS$（可逆绝热时等熵）</li><li>理想气体熵增公式：$\Delta S&#x3D;\nu C_{V,m}\ln\frac{T_2}{T_1}+\nu R\ln\frac{V_2}{V_1}$（速度熵 $+$ 位形熵）</li><li>熵增加原理：<strong>孤立系统</strong>内的一切过程 $\Delta S\geq 0$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工程图学</title>
    <link href="/25Spring/EngineerGraph/"/>
    <url>/25Spring/EngineerGraph/</url>
    
    <content type="html"><![CDATA[<p>大一下学期工程图学的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、点线面"><a href="#一、点线面" class="headerlink" title="一、点线面"></a>一、点线面</h2><h3 id="1-投影"><a href="#1-投影" class="headerlink" title="1. 投影"></a>1. 投影</h3><ol><li>投影面平行线<ol><li>在其平行的那个投影面上的投影反映实长，并反映直线与另两投影面倾角的实际大小</li><li>另两个投影面上的投影平行于相应的投影轴，其到相应投影轴距离反映直线与它所平行的投影面之间的距离</li></ol></li><li>投影面垂直线<ol><li>在其垂直的投影面上，投影有积聚性</li><li>另外两个投影，反映线段实长，且垂直于相应的投影轴</li></ol></li><li>投影面垂直面<ol><li>在它垂直的投影面上的投影积聚成直线。且反映空间平面与另外两投影面夹角的大小</li><li>另外两个投影面上的投影是类似形</li></ol></li><li>投影面平行面<ol><li>在它所平行的投影面上的投影反映实形</li><li>另两个投影面上的投影积聚成直线，并且与相应的投影轴平行</li></ol></li></ol><h3 id="2-点线面的关系"><a href="#2-点线面的关系" class="headerlink" title="2. 点线面的关系"></a>2. 点线面的关系</h3><ol><li>内部<ol><li>平面上的直线<ol><li>若一直线过平面上的两点，则此直线必在该平面内</li><li>若一直线过平面上的一点，且平行于该平面上的另一直线，则此直线在该平面内</li></ol></li><li>平面上的点<ol><li>若点在平面内，则该点必属于平面内一直线</li></ol></li></ol></li><li>平行<ol><li>两直线平行<ol><li>若空间两直线平行，则它们的各同名投影必然平行；反之亦然</li><li>一般情况下，任意两对同名投影平行即可以判定两直线空间也平行；若两直线是投影面平行线时，还需进一步判断，如通过求第三投影的方法等</li></ol></li><li>直线与平面平行<ol><li>若直线平行于平面内某一直线，则该直线平行于平面；反之，若直线平行于平面，则在平面内任一点必可作一直线与该直线平行</li><li>若一直线与某一投影面垂直面平行，则该平面有积聚性的投影与该直线的同名投影平行</li></ol></li><li>两平面平行<ol><li>若两平面内有一对相交直线对应平行，则该两平面平行</li><li>若两投影面垂直面相互平行，则它们具有积聚性的那组投影必相互平行</li></ol></li></ol></li><li>相交<ol><li>两直线相交<ol><li>若空间两直线相交，则其同名投影必相交，且交点的投影必符合空间点的投影规律；反之亦然</li><li>相叉不相交：同面投影可能相交，但“交点”不符合空间一个点的投影规律；“交点”是两直线上的一对重影点的投影</li></ol></li><li>直线与平面相交<ol><li>当直线或平面至少其一具有积聚性投影时，交点必在具有积聚性的投影上</li><li>一般位置：包含已知直线作一个特殊位置平面，求辅助平面与已知平面的交线，再求交线与已知直线的交点</li></ol></li><li>平面与平面相交<ol><li>当两平面中至少其一具有积聚性投影时，可利用积聚性投影解题</li><li>一般位置：转化为线面相交，包含已知直线作两个特殊位置平面</li></ol></li><li>利用重影点判断可见性</li></ol></li><li>垂直<ol><li>两直线垂直<ol><li>当直角的一条边平行于投影面时，直角在该投影面上的投影仍为直角；反之亦然</li><li>一般位置：过线外点作一平面垂直于直线；求直线与平面的交点</li></ol></li><li>直线与平面垂直<ol><li>若直线垂直于平面上两条相交直线，则该直线与该平面垂直</li><li>直线若垂直于平面，必垂直于平面上的所有直线，包含平面上的投影面平行线</li><li>若一条直线垂直于某一平面，则该直线在各投影面上的投影必定垂直于该平面的同名迹线</li></ol></li><li>平面与平面垂直<ol><li>使平面通过垂直于已知平面的直线</li><li>使平面垂直于已知平面上的一条直线</li></ol></li></ol></li></ol><h3 id="3-换面法"><a href="#3-换面法" class="headerlink" title="3. 换面法"></a>3. 换面法</h3><ol><li>变换成投影面平行线<ol><li>一次换面</li><li>新投影：反映直线的实长及与该侧平面倾角实际大小</li></ol></li><li>变换成投影面垂直线<ol><li>两次换面：一般位置直线 $\to $ 投影面平行线 $\to $ 投影面垂直线</li><li>新投影：积聚为一点</li></ol></li><li>变换成投影面垂直面<ol><li>一次换面：以投影面平行线为主</li><li>新投影：投影面平行线积聚为点，面积聚为线且反映平面与该侧平面倾角实际大小</li></ol></li><li>变换成投影面平行面<ol><li>两次换面</li><li>新投影：反映图形的实际形状</li></ol></li></ol><h2 id="二、体"><a href="#二、体" class="headerlink" title="二、体"></a>二、体</h2><h3 id="1-基本体"><a href="#1-基本体" class="headerlink" title="1. 基本体"></a>1. 基本体</h3><ol><li>圆锥：辅助直线或辅助圆</li><li>球：辅助圆（本质：辅助平面）</li><li>圆环：辅助圆（本质：辅助平面）</li></ol><h3 id="2-截切"><a href="#2-截切" class="headerlink" title="2. 截切"></a>2. 截切</h3><ol><li>平面体的截切<ol><li>截交线的特点<ol><li>封闭的平面多边形</li><li>截交线是截平面与立体表面的共有线（公有性）</li><li>截交线的每条边是截平面与棱面的交线</li><li>截交线的每个端点是截平面与棱线的交点</li><li>求截交线的实质是求两平面的交线</li></ol></li><li>求法<ol><li>棱线法：求各棱线与截平面的交点，然后连接而成</li><li>棱面法：求各棱面与截平面的交线，然后连接而成</li></ol></li><li>步骤<ol><li>空间分析：平面体的形状、截平面与体的相对位置（确定截交线的空间形状）</li><li>投影分析：截平面与投影面的相对位置（确定截交线的投影特性）</li><li>画出截交线的投影：棱线法或棱面法</li></ol></li></ol></li><li>回转体的截切<ol><li>截交线的特点<ol><li>封闭的平面曲线和直线</li></ol></li><li>求法<ol><li>先找特殊点，补充中间点</li><li>将各点光滑地连接起来</li></ol></li><li>平面截圆锥<ol><li>过锥顶：两相交直线</li><li>圆、椭圆、抛物线、双曲线</li></ol></li><li>平面截圆环<ol><li>可以是一条或两条（波修斯曲线、伯努利曲线、卡西尼卵形线）</li></ol></li></ol></li></ol><h3 id="3-相贯"><a href="#3-相贯" class="headerlink" title="3. 相贯"></a>3. 相贯</h3><ol><li>平面体与回转体相交<ol><li>相贯线的形状：由若干段平面曲线（或直线）所组成的空间折线</li><li>相贯线的求法：求平面体各表面（棱面&#x2F;平面）与回转体表面的交线（求截交线问题）</li><li>步骤<ol><li>空间分析：分析各棱面与回转体的相对位置，判断交线的空间形状</li><li>投影分析：分析各棱面相对于投影面的位置，判断交线的已知投影</li><li>作图：求出各棱面与回转体表面的交线，连接，并判断可见性</li></ol></li><li>相贯线的产生<ol><li>外表面与外表面相交</li><li>外表面与内表面相交 </li><li>内表面与内表面相交</li></ol></li></ol></li><li>回转体与回转体相交<ol><li>相贯线的形状：一般为光滑封闭的空间曲线</li><li>两圆柱相贯：积聚性表面取点法<ol><li>步骤：先找特殊点（最高最低最前最后最左最右）$\to$ 补充中间点 $\to$ 光滑连接</li><li><strong>交线向大圆柱轴线弯</strong></li><li>蒙若定理：若两个二次曲面同时相切于第三个二次曲面，则这两个二次曲面的交线为平面曲线</li><li>推论：两个轴线相交的回转面同切于一个圆球面时，则这两个回转面的交线为椭圆（平面曲线）。其积聚性的投影为这两个回转面轮廓线的交点对连 <strong>（圆锥与圆柱）</strong></li></ol></li><li>非两圆柱的回转面相贯：辅助平面法<ol><li>选择辅助平面（使辅助平面与两回转体表面产生的交线的投影均为直线和圆）</li><li>分别求作辅助平面与两回转面的交线</li><li>两交线的交点即为两回转面的交线上的点</li></ol></li></ol></li></ol><h3 id="4-组合体"><a href="#4-组合体" class="headerlink" title="4. 组合体"></a>4. 组合体</h3><ol><li>多形体相交<ol><li>形体分析（搞清楚哪些形体相交，交线是什么）</li><li>两两求交线（注意两两相交时三条交线汇聚一点）</li></ol></li><li>组合体的表面关系<ol><li>共面：两基本体叠加后，相邻表面共面时，结合处无线</li><li>相切：以相切方式形成叠加体，相切处表面光滑过渡，没有线</li></ol></li><li>组合体的读图<ol><li>视图中的一个封闭线框表示一个面的投影，可以是平面、曲面、光滑过渡的平面和曲面的组合</li><li>相邻线可能是交线，也可能是某个面积聚而成</li></ol></li><li>组合体的画图<ol><li>分析表面过渡关系</li><li>回转体一定要画回转轴线、中心线</li><li>一定按照形体分析的过程，一个形体一个形体画，不可东一笔西一笔</li><li>先主后次、先大后小、先整体后细节、先定位后定形</li><li>先整体（主要）后局部（次要）、先外形后内形、先轮廓后交线</li></ol></li></ol><h2 id="三、表达方法"><a href="#三、表达方法" class="headerlink" title="三、表达方法"></a>三、表达方法</h2><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h3><ol><li>基本视图<ol><li>六个投影面的展开<ol><li>后视图在最右边</li><li>按规定位置配置时一律不标注</li></ol></li><li>向视图<ol><li>向视图的上方标注大写拉丁字母</li><li>当局部结构是完整的且外轮廓封闭时，波浪线可省略</li><li>按基本视图配置时可以省略标注</li></ol></li><li>斜视图：字母靠近箭头端，符号方向与旋转方向一致</li></ol></li><li>剖视图<ol><li>画法：画出视图 $\to $ 将剖开后看得见的虚线或剖到的虚线改成粗实线 $\to$ 擦掉多余的外形线</li><li>剖视图按基本视图关系配置时，可省略箭头</li><li>当单一剖切面通过机件的对称（或基本对称）平面，且剖视图按基本视图关系配置时，标注全省略</li><li>半剖：内、外形都需要表达，而形状又基本对称</li><li>局部剖：波浪线<strong>不与任何图线重合、不得超出轮廓线、不得穿空而过</strong></li><li>轮廓线与对称中心线重合时，不宜采用半剖视，而用局部剖视</li><li>实心杆件（轴、杆等）上有孔、槽时，采用局部剖视</li></ol></li><li>断面图<ol><li>重合断面图轮廓线用细实线绘制，移出断面图轮廓线用粗实线绘制</li><li>以下情况断面图局部按剖视图绘制：<ol><li>剖切平面通过<strong>回转面</strong>形成的孔或凹坑的轴线时</li><li>当剖切产生完全分离的结构时</li></ol></li><li>由两个或多个相交的剖切平面剖切得到的移出断面图，中间应断开</li><li>配置在剖切符号延长线上的断面不标字母</li><li>对称断面不标箭头</li><li>配置在视图中断处不标注</li></ol></li><li>简化画法<ol><li>当剖切平面通过肋厚度的对称平面时，肋不画剖面线，而用粗实线（轮廓线）将它与邻接部分分开</li><li>回转体上均匀分布的肋、轮辐、孔等结构不处于剖切平面上时，可将其旋转到剖切平面上画出</li><li>直径相同且呈规律分布的孔，可仅画一个或几个，其余只画中心线表示孔的中心位置 </li><li>圆柱体上的小孔、键槽、平面等处的交线允许省略或简化，但必须有一视图已将小孔、槽等的形状表示清楚</li><li>沿长度方向形状一致或规律变化的较长杆件（轴、杆）可断开后缩短绘制，断裂边界用波浪线绘制（但标注尺寸仍为实际长度）</li><li>在不致引起误解的情况下，对称机件允许只画1&#x2F;2或1&#x2F;4，但需在对称中心线两端绘制对称符号（两平行细直线）与其垂直</li><li>当剖切后产生不完整要素时，应将此部分按不剖绘制</li><li>采用剖视图后，在图中仍可使用虚线，但需不影响视图的清晰、可省略另一个视图，且不在其上标注尺寸</li><li>细实线对角线表示小平面</li></ol></li></ol><h3 id="2-尺寸标注"><a href="#2-尺寸标注" class="headerlink" title="2. 尺寸标注"></a>2. 尺寸标注</h3><ol><li>尺寸标注总体原则<ol><li>尺寸数字不可被任何图线所通过，否则必须将该图线断开</li><li>尺寸线不能与其他线重合；尺寸线不能在其他线的延长线上；尺寸线与尺寸线不能交叉</li><li>尽量避免在30°范围内标注尺寸，无法避免时应引出标注</li></ol></li><li>角度尺寸<ol><li>尺寸线应画成圆弧，圆心是角的顶点。尺寸界线应沿径向引出</li><li>角度数字一律写成水平方向，一般注写在尺寸线的中断处</li><li>必要时也可写在尺寸线的上方或外面，也可引出标注</li></ol></li><li>特殊尺寸画法<ol><li>位置不够时，允许用圆点或斜线代替箭头</li><li>相同结构的一组孔的尺寸注法：Nx (EQS)</li><li>板状零件厚度的尺寸注法：tx</li><li>断面为正方形：□14 or 14x14</li></ol></li><li>组合体尺寸标注<ol><li>尺寸类型：定形尺寸、定位尺寸、总体尺寸</li><li>圆柱、圆孔必须用中心进行定位，不能用轮廓线定位</li><li>圆角半径尺寸前不写数量</li><li>圆角两端光滑连接（相切）时，不标注圆心的定位尺寸（无论板上圆角与圆柱孔是否同心）</li></ol></li><li>尺寸的布置<ol><li>同心圆柱的直径尺寸，最好注在投影为非圆的视图上</li><li>尽量避免尺寸线、尺寸界线交叉</li><li>内形尺寸和外形尺寸最好分别标注在视图的两侧</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一下</tag>
      
      <tag>机电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第三讲 三大公式背后的“边界”之谜</title>
    <link href="/43Class/43Class-3/"/>
    <url>/43Class/43Class-3/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第三讲，介绍了微分型、外积与外导数的概念，并揭示了三大公式背后的“边界”之谜。</p><span id="more"></span><blockquote><p>数学是一门赋予不同事物以同样名字的艺术。 -Poincare</p></blockquote><p>笃实 43 班的同学们大家好。距离上一期肆叁小灶已经过去了接近一整个学期，暂缓更新的原因除了本学期学习任务的加重，也包括肆叁小灶进行转型的意图：我们希望，肆叁小灶不应局限于学委小组内部供稿，而应成为一个开放的平台，让所有有意愿分享的同学参与其中。我们预计会在明年的秋季学期正式开始转型，欢迎大家积极投稿。</p><p>在此之前，让我们先回到这期内容本身。在前几周的微积分课堂里，想必同学们都学习了 $\mathrm{Green},\mathrm{Gauss}$ 和 $\mathrm{Stokes}$ 三大公式。它们三者将我们先前学习的重积分与后面学习的曲线曲面积分联系在了一起，在有些时候可以简化计算。然而，这三个公式互相类似而又各不相同的特点导致了记忆上的困难，而且很容易有一种直觉：三者似乎是一个更大公式的不同特例。</p><p>其实，这个伏笔从本学期的第一节微积分课上就已经埋下了。请大家先思考一个似乎无关紧要的问题：为什么“边界”的符号和偏导数的符号一样，都是 $\partial$？现在回过头看，这是否在暗示些什么？实际上，这个问题本身确实和三大公式之间有着紧密的联系。但揭开这重关系需要一些更高阶的数学知识，我们将在这期推送中为大家作简要介绍，并最终揭开三大公式背后的“边界”之谜。</p><h2 id="一、从微分到微分型"><a href="#一、从微分到微分型" class="headerlink" title="一、从微分到微分型"></a>一、从微分到微分型</h2><p>首先，在我们积分各种 $f\mathrm{d}x+g\mathrm{d}y+h\mathrm{d}z$ 时，我们到底在干什么？到底什么是 $\mathrm{d}x$？微积分 A1 告诉我们，$\mathrm{d}x$ 是 $x$ 的无穷小量，这自然是对的，但我们也可以换一个视角：我们可以把 $\mathrm{d}x$ 看成一个“函数”或者一个“映射”，它的效果是接收一个向量，并输出它自己的 $x$ 坐标。比如有一个三维向量 $[0.001,0.002,0.003]$，那么 $\mathrm{d}x$ 就把它转化为了 $0.001$。不难发现，这是一个从 $\mathbb{R}^3$ 到 $\mathbb{R}$ 的线性映射。</p><p>而对于一段曲线 $\gamma$，不妨将其看成无数个无穷小向量连成的串串。也就是说，$\int_\gamma \mathrm{d}x$ 就是用 $\mathrm{d}x$ 这个映射接收所有这些无穷小的向量，并且把结果加起来。从这个角度，$\int_\gamma \mathrm{d}x$ 实际上就是在问 $\gamma$ 在 $x$ 轴方向上总共变化了多少。</p><p>那么，什么是 $f\mathrm{d}x$ 呢？它和 $\mathrm{d}x$ 一样，也是对无穷小向量的一个映射，不过比 $\mathrm{d}x$ 略为复杂：它的转化方法是，用 $f$ 在这个向量的出发点上的值去乘以 $\mathrm{d}x$，也即 $\mathrm{d}v$ 的 $x$ 坐标。自然地，所谓 $\int_\gamma f\mathrm{d}x$ 就是用 $f\mathrm{d}x$ 去接收 $\gamma$ 上所有无穷小向量，再把结果加起来。</p><p>同理，$f\mathrm{d}x+g\mathrm{d}y+h\mathrm{d}z$ 不过是把三个映射加了起来。与 $\mathrm{d}x$ 一样，$f\mathrm{d}x+g\mathrm{d}y+h\mathrm{d}z$ 也是一个从 $\mathbb{R}^3$ 到 $\mathbb{R}$ 的线性映射。把这个线性映射记作 $\omega&#x3D;f\mathrm{d}x+g\mathrm{d}y+h\mathrm{d}z$，我们称这样的 $\omega$ 为一个 <strong>1-微分型</strong>。高维空间下的1-微分型也是类似的，可以写作 $\omega&#x3D;f_1\mathrm{d}x_1+f_2\mathrm{d}x_2+\cdots+f_n\mathrm{d}x_n$。</p><p>接下来我们考虑 <strong>2-微分型</strong>。题目中常见的 $\mathrm{d}x\wedge\mathrm{d}y$ 实际上就是一个三维空间中的 2-微分型，它的作用是接收一个空间中无穷小的平行四边形 $(\mathrm{d}v,\mathrm{d}w)$（注意这里的顺序给出了平行四边形的有向性），并输出这个小平行四边形在 $xy$ 平面上的有向投影面积。</p><p>自然地，这就等价于先把这两个向量投影到 $xy$ 平面上，再计算这两个投影向量张成的平行四边形面积。借助1-微分型的语言，一个三维向量 $\mathrm{d}v$ 在 $xy$ 平面上的投影就是 $\begin{bmatrix}\mathrm{d}x(\mathrm{d}v)\\\mathrm{d}y(\mathrm{d}v)\end{bmatrix}$。从而，线性代数的知识告诉我们，计算 $\mathrm{d}v,\mathrm{d}w$ 的投影向量所张成的平行四边形面积就等价于计算一个二阶方阵 $\begin{bmatrix}\mathrm{d}x(\mathrm{d}v) &amp; \mathrm{d}x(\mathrm{d}w)\\\mathrm{d}y(\mathrm{d}v) &amp; \mathrm{d}y(\mathrm{d}w)\end{bmatrix}$ 的行列式。</p><p>和1-微分型一样，我们也可以将 $\mathrm{d}x\wedge\mathrm{d}y,\mathrm{d}y\wedge\mathrm{d}z,\mathrm{d}z\wedge\mathrm{d}x$ 前面乘上各自的系数 $f,g,h$ 后拼起来，得到三维空间下2-微分型的通式：$\omega&#x3D;f\mathrm{d}x\wedge\mathrm{d}y+g\mathrm{d}y\wedge\mathrm{d}z+h\mathrm{d}z\wedge\mathrm{d}x$。高维空间下的2-微分型也是类似的，可以写作 $\omega&#x3D;\sum f_{ij}\mathrm{d}x_i\wedge\mathrm{d}x_j$，其中 $i,j$ 取遍 $1,2,\cdots,n$。</p><p>普遍地，我们可以给出 $n$ 维空间下单个 $k$-微分型的定义：接收 $k$ 个有序的无穷小 $n$ 维向量，并输出某个有向的 $k$ 维无穷小投影平行体的体积，这也就等价于一个 $k$ 阶方阵的行列式。同理，$k$-微分型的通式就是把所有的单个 $k$-微分型乘上系数后加起来： $\omega&#x3D;\sum f_{i_1i_2\cdots i_k}\mathrm{d}x_{i_1}\wedge\mathrm{d}x_{i_2}\wedge\cdots\wedge\mathrm{d}x_{i_k}$，其中 $i_1,i_2,\cdots,i_k$ 取遍 $1,2,\cdots,n$。如果觉得这样写起来太麻烦，我们可以定义“复合角标”来简化书写：记复合角标 $I&#x3D;(i_1,i_2,\cdots,i_k)$，则 $k$-微分型的通式可以简化为 $\omega&#x3D;\sum f_I\mathrm{d}x_I$。</p><p>借助行列式的性质，我们自然有 $\mathrm{d}x_i\wedge\mathrm{d}x_j&#x3D;-\mathrm{d}x_j\wedge\mathrm{d}x_i$，因为交换两行后行列式改变正负号：也就是说，微分型是反对称的。同理，$\mathrm{d}x_i\wedge\mathrm{d}x_i&#x3D;0$。这一结论在后续的部分中会反复用到，请大家务必牢记。</p><p>同时，若 $k&#x3D;n$，则 $\omega&#x3D;\sum f_I\mathrm{d}x_I$ 只剩下了一项，这一项就是 $n$ 维体积本身。这几乎是不证自明的：将 $n$ 维空间投影到 $n$ 维空间上，显然就是它本身。在二维和三维下，也就自然有 $\mathrm{d}x\wedge\mathrm{d}y&#x3D;\mathrm{d}x\mathrm{d}y$ 和 $\mathrm{d}x\wedge\mathrm{d}y\wedge\mathrm{d}z&#x3D;\mathrm{d}x\mathrm{d}y\mathrm{d}z$。</p><p>从而，用微分型的语言来说，我们有以下结论：</p><ul><li>平面上的第二类曲线积分等价于对一个二维的1-微分型作积分</li><li>平面上的二重积分等价于对一个二维的2-微分型作积分</li><li>空间中的第二类曲线积分等价于对一个三维的1-微分型作积分</li><li>空间中的第二类曲面积分等价于对一个三维的2-微分型作积分</li><li>空间中的三重积分等价于对一个三维的3-微分型作积分</li></ul><p>我们也就不难发现，三大公式其实说的是这么一回事：</p><ul><li>$\mathrm{Green}$ 公式：二维的1-微分型与2-微分型的积分有联系</li><li>$\mathrm{Gauss}$ 公式：三维的2-微分型与3-微分型的积分有联系</li><li>$\mathrm{Stokes}$ 公式：三维的1-微分型与2-微分型的积分有联系</li></ul><p>难道说，$n$ 维下 $k$-微分型与 $k$+1-微分型的积分之间都有联系？这一猜想需要外积与外导数的概念得以支撑。我们先来看看外积的定义。</p><h2 id="二、外积与外导数"><a href="#二、外积与外导数" class="headerlink" title="二、外积与外导数"></a>二、外积与外导数</h2><p>外积其实就是把两个微分型拼起来。外积与微分型的符号相同，都是 $\wedge$；若两个微分型都是单个的，则对于复合角标 $I,J$，有 $f\mathrm{d}x_I\wedge g\mathrm{d}x_J&#x3D;fg\mathrm{d}x_{(I,J)}$。比如说，我们有 $\mathrm{d}x_{(1,2)}\wedge\mathrm{d}x_3&#x3D;\mathrm{d}x_{(1,2,3)}$。特殊地，若 $(I,J)$ 中有重复的角标，运用微分型的反对称性，则 $\mathrm{d}x_{(I,J)}&#x3D;0$；对于通式形式的微分型，运用乘法分配律即可，此处不加赘述。</p><p>而外导数则是对微分型求导的过程。比如说对于2-微分型 $\omega&#x3D;f\mathrm{d}x\wedge\mathrm{d}y$，前文已经说明了 $\omega$ 本身也是一个映射，这里我们希望探求 $\omega$ 的微分性质，即当输入的无穷小向量的起点发生微小变化时，$\omega$ 的输出会发生怎样的变化。</p><p>先将 $\omega$ 写作 $f\cdot (\mathrm{d}x\wedge\mathrm{d}y)$，由乘法的求导法则我们知道对 $\omega$ 求导等于 $\mathrm{d}f\cdot (\mathrm{d}x\wedge\mathrm{d}y)+f\cdot \mathrm{d}(\mathrm{d}x\wedge\mathrm{d}y)$。而 $\mathrm{d}x\wedge\mathrm{d}y$ 可以看作是一个“常数”：其在空间中每一个点的作用效果是相同的，都是计算到 $xy$ 平面的投影面积，故 $\mathrm{d}(\mathrm{d}x\wedge\mathrm{d}y)&#x3D;0$。因此我们有 $\mathrm{d}\omega&#x3D;\mathrm{d}f\cdot \mathrm{d}x\wedge\mathrm{d}y$，而 $\mathrm{d}f&#x3D;\sum \frac{\partial f}{\partial x_i}\mathrm{d}x_i$，可见 $\mathrm{d}f$ 本身也是一个1-微分型，故 $\mathrm{d}\omega&#x3D;\mathrm{d}f\cdot \mathrm{d}x\wedge\mathrm{d}y$ 应当写成 $\mathrm{d}\omega&#x3D;\mathrm{d}f\wedge \mathrm{d}x\wedge\mathrm{d}y$。外导数的一般定义运用乘法分配律即可，此处同样不加赘述。</p><h2 id="三、“边界”之谜"><a href="#三、“边界”之谜" class="headerlink" title="三、“边界”之谜"></a>三、“边界”之谜</h2><p>至此，我们已经准备好了所有工具，可以开始着手一统三大公式了。</p><ul><li><p>考虑 $\mathrm{d}(f\mathrm{d}x+g\mathrm{d}y)$，一通计算后我们发现这就等于 $(g^{\prime}_x-f^{\prime}_y)\mathrm{d}x\wedge\mathrm{d}y&#x3D;(g^{\prime}_x-f^{\prime}_y)\mathrm{d}x\mathrm{d}y$，这恰好对应了求平面向量场旋度的过程，也对应了 $\mathrm{Green}$ 公式的左右两边。</p></li><li><p>考虑 $\mathrm{d}(f\mathrm{d}y\wedge\mathrm{d}z+g\mathrm{d}z\wedge\mathrm{d}x+h\mathrm{d}x\wedge\mathrm{d}y)$，经过计算可以验证这就等于 $(f^{\prime}_x+g^{\prime}_y+h^{\prime}_z)\mathrm{d}x\mathrm{d}y\mathrm{d}z$，这对应了求空间向量场散度的过程，也对应了 $\mathrm{Gauss}$ 公式的左右两边。</p></li><li><p>考虑 $\mathrm{d}(f\mathrm{d}x+g\mathrm{d}y+h\mathrm{d}z)$，同样可以验证这就等于 $(g^{\prime}_x-f^{\prime}_y)\mathrm{d}y\wedge\mathrm{d}z+(h^{\prime}_y-g^{\prime}_z)\mathrm{d}z\wedge\mathrm{d}x+(f^{\prime}_z-h^{\prime}_x)\mathrm{d}x\wedge\mathrm{d}y$，这对应了求空间向量场旋度的过程，也对应了 $\mathrm{Stokes}$ 公式的左右两边。</p></li></ul><p>原来所谓梯度、旋度、散度，归根结底其实都是同一件事情，就是外导数。那么梯度、散度、旋度所对应的三大公式，自然也就是同一件事情，而这就是广义 $\mathrm{Stokes}$ 定理：</p><p><strong>（广义 $\mathrm{Stokes}$ 定理）</strong> 对任意有向的 $k+1$ 维曲面 $S$ 和 $k$-微分型 $\omega$，都有 $$\int_S \mathrm{d}\omega&#x3D;\int_{\partial S} \omega$$其中 $\partial S$ 是 $S$ 的边界，$\mathrm{d}\omega$ 是对 $\omega$ 求外导数。</p><p>实际上，在一维的情况下，$\mathrm{d}\omega$ 就是 $\mathrm{d}f$，而 $S$ 的边界就是 $[a,b]$ 的两个端点 $a,b$，所以 $\int_S \mathrm{d}\omega&#x3D;\int_a^b \mathrm{d}f&#x3D;f(b)-f(a)$，这就是我们熟悉的 $\mathrm{Newton-Leibnitz}$ 公式。因此，广义 $\mathrm{Stokes}$ 定理就是多元微积分里 $\mathrm{Newton-Leibnitz}$ 公式的推广，其核心思想可以概括为 <strong>“外部总的变化等于内部小变化之和”</strong>。</p><p>我们还可以发现一个有趣的事实：回忆线性代数，对 $\mathrm{Euclid}$ 空间上的双线性过程 $\langle v,w\rangle$，考虑实矩阵 $A$ 和其转置矩阵 $A^T$，我们有 $\langle Av,w\rangle&#x3D;\langle v,A^Tw\rangle$。现在考虑积分 $\int_M\omega$，我们知道积分对于积分区域和被积函数都是线性的，这意味着积分也是一个双线性过程。不妨把 $\int_M\omega$ 写成 $\langle M,\omega\rangle$，那么广义 $\mathrm{Stokes}$ 定理告诉我们，$\langle M,\mathrm{d}\omega\rangle&#x3D;\langle \partial M,\omega\rangle$。这等于在说，<strong>微分就是边界的转置</strong>。这也就解释了为什么边界的符号和偏导数的符号是一样的，都是 $\partial$。</p><p>事实上，上述结论还可以推广到酉空间；而在更一般的情况下，广义 $\mathrm{Stokes}$ 定理也可以推广到任意的微分流形上，我们在这里就不展开了，感兴趣的同学可以选修《高等线性代数选讲》、《复变函数》和《微分几何》。前两者是计算机系和前软院培养方案中的必修课，而后者则在我们院培养方案的4A和7B课组中，欢迎大家选修。</p><h2 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h2><p>微积分 A2 课程由于课时所限，大部分内容都局限于介绍计算方法，考试题型也大多是计算题。虽然这篇推送可能对于大家的考试没有直接帮助，但我们希望它能帮助大家更好地理解多元微积分的本质，帮助大家在今后的学习中更好地运用微积分的知识。</p><p>这篇推送的内容大部分来自杨一龙老师的《向量微积分》讲义，少数来自张友金老师的《数学分析》讲义。这里再给出一些资料，供大家参考，希望能帮助大家建立起对梯度、散度和旋度运算的直观理解：</p><ul><li><a href="https://www.bilibili.com/video/BV19s41157Z4">散度与旋度：麦克斯韦方程组、流体等所用到的语言</a></li><li><a href="https://www.bilibili.com/video/BV1a541127cX">【nabla算子】与梯度、散度、旋度</a></li><li><a href="https://www.zhihu.com/question/37466122/answer/3486678510?share_code=dvPZd6vVVyoP&utm_psn=1909795539484143778">外微分形式为什么要是反对称的？Cartan 当年为什么要这样定义？</a></li></ul><p>最后，祝大家微积分期末考试顺利，取得理想的成绩！</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学(1)：计算机导论</title>
    <link href="/CSDIY/CSDIY-1/"/>
    <url>/CSDIY/CSDIY-1/</url>
    
    <content type="html"><![CDATA[<p>大一寒假的自学笔记，由两门计算机导论课程组成。</p><span id="more"></span><h2 id="一、Crash-Course-Computer-Science"><a href="#一、Crash-Course-Computer-Science" class="headerlink" title="一、Crash Course : Computer Science"></a>一、Crash Course : Computer Science</h2><h3 id="1-计算机底层"><a href="#1-计算机底层" class="headerlink" title="1. 计算机底层"></a>1. 计算机底层</h3><ol><li>晶体管</li><li>逻辑门</li><li>半加器、寄存器</li><li>$\mathrm{ALU}$、$\mathrm{RAM}$</li><li>二进制编程</li><li>$\mathrm{CPU}$</li><li>汇编语言</li><li>操作系统</li><li>文件系统</li><li>编译型语言</li><li>解释型语言</li></ol><h3 id="2-计算机硬件"><a href="#2-计算机硬件" class="headerlink" title="2. 计算机硬件"></a>2. 计算机硬件</h3><ol><li>存储器：延迟线 $\Rightarrow$ 磁芯 $\Rightarrow$ 磁带 $\Rightarrow$ 磁盘 $\Rightarrow$ 光盘 $\Rightarrow$ 固态硬盘</li><li>$\mathrm{IO}$<ol><li>电传打字机 $\Rightarrow$ 阴极射线管 $\Rightarrow \mathrm{LCD}$</li><li>矢量扫描、光栅扫描</li></ol></li><li>$\mathrm{3D}$<ol><li>正交投影、透视投影</li><li>多边形渲染、扫描线、抗锯齿</li><li>画家算法、深度缓冲</li><li>表面法线、纹理映射</li></ol></li></ol><h3 id="3-计算机软件"><a href="#3-计算机软件" class="headerlink" title="3. 计算机软件"></a>3. 计算机软件</h3><ol><li>网络<ol><li>物理层</li><li>数据链路层：$\mathrm{MAC}$、载波侦听多路访问、指数退避</li><li>网络层：交换机、路由、跳数限制</li><li>传输层：报文、数据包、$\mathrm{IP}$、$\mathrm{UDP}$、$\mathrm{TCP}$ </li><li>会话层：$\mathrm{URL}$、$\mathrm{DNS}$、$\mathrm{HTTP}$、$\mathrm{HTML}$</li></ol></li><li>信息安全<ol><li>$\mathrm{Bell-LaPadula}$ 模型</li><li>攻击方式：社会工程学、钓鱼、假托、木马、暴力、$\mathrm{NAND}$ 镜像</li><li>漏洞利用：缓存区溢出（边界检查、金丝雀）、$\mathrm{SQL}$ 注入、蠕虫、僵尸网络</li><li>加密：$\mathrm{Diffie-Hellman}$ 密钥交换（模幂）、非对称加密</li></ol></li><li>人工智能<ol><li>分类：决策边界、混淆矩阵 $\Rightarrow$ 决策树 $\Rightarrow$ 森林 $\Rightarrow$ 支持向量机</li><li>神经网络：加权、求和、偏置、激活</li><li>$\mathrm{CV}$：颜色跟踪 $\Rightarrow$ 特征检测（核、卷积）$\Rightarrow$ 卷积神经网络</li><li>$\mathrm{NLP}$：分析树、知识图谱、语音识别（$\mathrm{FFT}$）、语音合成</li></ol></li></ol><h2 id="二、MIT-Missing-Semester"><a href="#二、MIT-Missing-Semester" class="headerlink" title="二、MIT Missing Semester"></a>二、MIT Missing Semester</h2><h3 id="4-Shell"><a href="#4-Shell" class="headerlink" title="4. Shell"></a>4. Shell</h3><ol><li>以 <code>/</code> 或盘符开头的是绝对路径，否则是相对路径；Linux,MacOS 用 <code>/</code>，Windows 用 <code>\</code></li><li>命令：<code>which</code>，<code>sudo su</code>，<code>cat</code>，<code>curl</code>，<code>grep</code>，<code>tee</code></li><li><code>cd</code> 需要权限 <code>x</code>；<code>ls</code> 需要权限 <code>r</code></li><li><code>&#39;</code> 不转义变量，<code>&quot;</code> 转义变量</li><li><code>$0</code> 脚本名，<code>$1-$9</code> 脚本参数，<code>$@</code> 所有参数，<code>$#</code> 参数个数，<code>$?</code> 返回值，<code>$$</code> PID，<code>!!</code> 上一个命令，<code>$_</code> 最后一个参数</li><li>标准错误流 <code>2&gt;</code>；不等于 <code>-ne</code>；比较时用 <code>[[ ]]</code></li><li>通配符：<code>*</code> 任意字符，<code>?</code> 单个字符，<code>[]</code> 字符集，<code>&#123;&#125;</code> 多个字符</li><li><code>find</code>: <code>-name</code> 文件名，<code>-type</code> 文件类型，<code>-size</code> 文件大小，<code>-exec</code> 执行命令，<code>path</code> 路径，<code>-mtime</code> 修改时间</li><li>正则表达式：<code>^</code> 开头，<code>$</code> 结尾，<code>.</code> 任意字符，<code>*</code> 0-多次，<code>+</code> 1-多次，<code>?</code> 0-1次，<code>[]</code> 字符集，<code>()</code> 分组，<code>|</code> 或，<code>\1,\2</code> 捕获组</li><li>数据整理：<code>awk</code>，<code>sed</code>，<code>sort</code>，<code>uniq</code>，<code>paste</code>，<code>wc</code>，<code>head</code>，<code>tail</code></li><li>终止：<code>^C</code> &#x3D; <code>SIGINT</code>，<code>^D</code> &#x3D; <code>EOF</code>，<code>^\</code> &#x3D; <code>SIGQUIT</code>，<code>kill</code> &#x3D; <code>SIGTERM</code>，<code>^Z</code> &#x3D; <code>SIGTSTP</code>，<code>SIGKILL</code> 立刻结束</li><li>进程管理：<code>fg</code> 前台继续，<code>bg</code> 后台继续，<code>jobs</code> 查看，<code>pgrep</code> 查找，<code>$!</code> 最后一个进程，<code>nohup</code> 后台运行</li><li>常用参数：<code>--verbose</code>，<code>-v</code>，<code>-vvv</code>，<code>--quiet</code>，<code>-</code>，<code>-r</code>，<code>-- -r</code></li><li>常见目录：<code>/etc</code>，<code>/var</code>，<code>/tmp</code>，<code>/dev</code>，<code>/bin</code>，<code>/sbin</code>，<code>/opt</code>，<code>/lib</code></li></ol><h3 id="5-VIM"><a href="#5-VIM" class="headerlink" title="5. VIM"></a>5. VIM</h3><ol><li>切模式：<code>i</code> 插入，<code>v</code> 可视，<code>V</code> 行可视，<code>^V</code> 块可视，<code>R</code> 替换，<code>:</code> 命令，<code>a</code> 插入</li><li>移动：<code>hjkl</code>，<code>w</code>，<code>b</code>，<code>e</code>，<code>0</code>，<code>^</code>，<code>$</code>，<code>gg</code>，<code>G</code>，<code>H</code>，<code>M</code>，<code>L</code>，<code>^U</code>，<code>^D</code></li><li>搜索：<code>%</code> 找配对括号，<code>f</code>,<code>t</code>,<code>F</code>,<code>T</code> 查找，<code>/</code> 搜索，<code>,</code>,<code>;</code>,<code>n</code>,<code>N</code> 导航匹配</li><li>编辑：<code>o</code>，<code>O</code>，<code>r</code>，<code>d</code>，<code>x</code>，<code>s</code>，<code>y</code>，<code>p</code>，<code>u</code>，<code>~</code>，<code>.</code>，<code>i</code> 内部，<code>a</code> 周围，<code>ci[</code></li></ol><h3 id="6-GIT"><a href="#6-GIT" class="headerlink" title="6. GIT"></a>6. GIT</h3><ol><li>命令：<code>init</code>，<code>status</code>，<code>add</code>，<code>commit</code>，<code>log</code>，<code>diff</code>，<code>checkout</code>，<code>branch</code>，<code>merge</code></li><li>远程：<code>remote add</code>，<code>push</code>，<code>pull</code>，<code>clone</code>，<code>fetch</code></li></ol><h3 id="7-杂项"><a href="#7-杂项" class="headerlink" title="7. 杂项"></a>7. 杂项</h3><ol><li>tmux：<code>tmux</code>，<code>tmux ls</code>，<code>tmux a</code>，<code>^A</code>+<code>d</code>,<code>c</code>,<code>1</code>,<code>n</code>,<code>p</code>,<code>,</code>,<code>w</code>,<code>&quot;</code>,<code>%</code>,<code>x</code>,<code>y</code>,<code>z</code></li><li>ssh：<code>ssh</code>，<code>scp</code>，<code>ssh-keygen</code>，<code>ssh-copy-id</code></li><li>配置文件：<code>~/.bashrc</code>，<code>~/.gitconfig</code>，<code>~/.vimrc</code>，<code>~/.tmux.conf</code>，<code>~/.ssh/config</code></li><li>版本管理：主版本号.次版本号.补丁号</li><li>元编程：Makefile，CMake，CI，GitHub Pages，Jekyll</li><li>密码学：Hash 函数，盐，对称加密，密钥交换，非对称加密，加密邮件，数字签名</li><li>其他：VM，Docker，Jupyter Notebook</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>自学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 | 逆天高三模卷数学压轴一则</title>
    <link href="/Others/Bytalk-2/"/>
    <url>/Others/Bytalk-2/</url>
    
    <content type="html"><![CDATA[<p>杂谈第二期，介绍了2025年WJXSAT考试数学压轴题的解法，题目难度较大，解法较为复杂。</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>对定义在 $\mathbb R$ 上的函数 $f(x)$ 与正实数 $r$，定义 $S_r&#x3D;\{x|x^2+f^2(x)\le r^2\}$. </p><p>若 $f(x)$ 满足对任意正实数 $r$，均有 $S_r&#x3D;[-g(r),g(r)]$，其中 $g(x)$ 是定义在 $(0,+\infty)$ 上的可导函数，且$\forall x\gt 0,\begin{cases}g(x)\gt 0\\0\lt g^{\prime}(x)\lt 1\end{cases}$，</p><p>证明：$f(x)$ 是 $\mathbb R$ 上的严格增函数<strong>当且仅当</strong> $\{x|f(x)\ge 0\}&#x3D;[0,+\infty)$.</p><p>本题改编自公众号<strong>未来教研之星</strong>举办的 $\mathrm{WJXSAT}$ 考试，供题人为B站<strong>艺扬飞翔在出题</strong>，原题链接见页尾“阅读原文”。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="充分性："><a href="#充分性：" class="headerlink" title="充分性："></a>充分性：</h4><p>证明：假设 $f(0)\neq 0$，设 $f(0)&#x3D;m\neq 0$，则取 $r^2&#x3D;\frac{1}{2}m^2$，$S_r$ 不包含 $0$，矛盾。</p><p>故 $f(0)&#x3D;0$，又 $f(x)$ 在 $\mathbb R$ 上严格递增，故 $\{x|f(x)\ge 0\}&#x3D;[0,+\infty)$.</p><h4 id="必要性："><a href="#必要性：" class="headerlink" title="必要性："></a>必要性：</h4><p>先证明两个引理。</p><p><strong>引理 $1$：令 $h(x)&#x3D;x^2+f^2(x)$，则 $h(x)$ 在 $(-\infty,0]$ 上严格递减，$[0,+\infty)$ 上严格递增。</strong></p><p>证明：先考虑 $[0,+\infty)$ 的情况，假设 $h(x)$ 不严格递增，分两种情况讨论：</p><p>$(\mathrm{i})$ $\exists x_1\lt x_2,h(x_1)\gt h(x_2)$，取 $r^2&#x3D;h(x_2)$，则 $S_r$ 不包含 $x_1$，矛盾。</p><p>$(\mathrm{ii})$ $\exists x_1\lt x_2,h(x)$ 在 $[x_1,x_2]$ 上是常值函数，则 $\forall \epsilon\gt 0$，取 $r^2&#x3D;h(x_2)-\epsilon$，$g(r)\lt x_1$，但 $r^2&#x3D;h(x_2)$ 时，$g(r)\ge x_2$，则 $g(r)$ 不连续，矛盾。</p><p>故 $h(x)$ 在 $[0,+\infty)$ 上严格递增，同理可证 $h(x)$ 在 $(-\infty,0]$ 上严格递减。</p><p>由引理 $1$ 可得，则 $g(r)$ 为 $\sqrt{x^2+f^2(x)}(x\gt 0)$ 的反函数，由于 $g(r)$ 为定义在 $(0,+\infty)$ 上的可导函数，则 $f(x)$ 在 $[0,+\infty)$ 上可导。</p><p><strong>引理 $2$：$f(x)$ 为奇函数。</strong></p><p>证明：由引理 $1$ 及其推论，$\forall x_0\gt 0$，取 $r_0^2&#x3D;x_0^2+f^2(x_0)$，则 $g(r_0)&#x3D;x_0,-g(r_0)&#x3D;-x_0$，故 $(-x_0)^2+f^2(-x_0)&#x3D;r_0^2$，则 $\forall x_0\gt 0,f^2(x_0)&#x3D;f^2(-x_0)$.</p><p>假设 $\exists x_0\gt 0,f(x_0)&#x3D;f(-x_0)$，则 $f(-x_0)&#x3D;f(x_0)\gt 0$，但 $-x_0\lt 0$ 不在 $\{x|f(x)\ge 0\}$ 中，矛盾，故 $f(x)&#x3D;-f(-x)$，$f(x)$ 为奇函数。</p><p>由引理 $2$ 可得，$\forall x\gt 0$，$f(x)\gt 0$.</p><p>接下来先考虑 $x\ge 0$ 的情况，由引理 $1$ 的推论，$g^{\prime}(r)\lt 1 \Rightarrow \forall x\gt 0,(\sqrt{x^2+f^2(x)})^{\prime}\gt 1$，即 $f^{\prime}(x)\gt \sqrt{(\frac{x}{f(x)})^2+1}-\frac{x}{f(x)}\gt 0$，$f(x)$ 在 $[0,+\infty)$ 上严格递增。</p><p>又由引理 $2$，$f(x)$ 为奇函数，故 $f(x)$ 在 $\mathbb R$ 上严格递增。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前标准答案尚未公布，题解为笔者自己的做法，解题过程中使用了连续性的定义和反函数的导数等高等知识，期待标答给出的纯初等解法。</p><p>个人认为本题难度过大，但题目质量还是很高的。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 | 一道高三一模数学题引发的思考</title>
    <link href="/Others/Bytalk-1/"/>
    <url>/Others/Bytalk-1/</url>
    
    <content type="html"><![CDATA[<p>杂谈第一期，介绍了一道有争议的高三一模数学题的解法与思考，涉及到一些高等数学的知识。</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/Bytalk-1/1.jpg"></p><p>上图为今年上海市崇明区高三数学一模压轴题最后一问的原题以及区教研组提供的参考答案。事实上，题设中的条件已经够强，只需要借助一些高等知识，就可以证明：满足条件的 $f$ 只能是零函数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了证明 $f&#x3D;0$，先证明两个引理：</p><p><strong>引理 $1$：满足条件的 $f$ 若存在两个零点 $x_1\neq x_2$，则 $\forall x\in[x_1,x_2],f(x)&#x3D;0$</strong></p><p>证明：考虑函数 $g(x)&#x3D;|f(x)|$，由 $g(x)$ 的连续性，$g$ 在 $[x_1,x_2]$ 上存在最大值，分两种情况讨论：</p><p>$(1)$ $g$ 在区间上的最大值在端点处取到，则自然有 $\forall x\in[x_1,x_2],|f(x)|&#x3D;0\Leftrightarrow f(x)&#x3D;0$ 成立</p><p>$(2)$ $g$ 在区间上的最大值在内点 $x_0$ 处取到，此时有 $g(x_0)\neq 0$，不妨设 $g(x_0)\gt 0$，则在 $x_0$ 的邻域上有 $g(x)&#x3D;f(x)$ 或 $g(x)&#x3D;-f(x)$，则 $g(x)$ 在 $x_0$ 处可导，因此由 $\mathrm{Fermat}$ 引理，有 $g^{\prime}(x_0)&#x3D;0$，则 $g(x_0)&#x3D;g^{\prime}(x_0)&#x3D;0$，故也有 $\forall x\in[x_1,x_2],|f(x)|&#x3D;0\Leftrightarrow f(x)&#x3D;0$ 成立</p><p><strong>引理 $2$：若函数在区间 $I$ 上不存在零点，则函数在该区间上单调</strong></p><p>证明：若函数不单调，则 $\exists \xi\in I,s.t. f^{\prime}(\xi)&#x3D;0$，则 $f(\xi)&#x3D;0$，与函数在区间 $I$ 上不存在零点矛盾</p><p><strong>接下来考虑 $f$ 的零点构成的集合 $S$，分四种情况讨论：</strong></p><p>$(1)$ $S$ 不存在上下确界，则由引理 $1$，$S&#x3D;\mathbb R$，则 $f&#x3D;0$</p><p>$(2)$ $S$ 的上下确界中的一个不存在，不妨设下确界不存在，记 $S$ 的上确界为 $M$，则 $f$ 在 $[M,+\infty)$ 上单调，且 $f(M-1)&#x3D;0$，由于添加零区间不影响函数的单调性，故 $f$ 在 $[M-1,+\infty)$ 上也单调，不妨设 $f$ 在 $[M-1,+\infty)$ 上单调递增，$f^{\prime}(x)\ge 0$，则由条件 $1$ 和 $f$ 的单调性有 $0\le f(x)\le f^{\prime}(x)$，此时考虑函数 $\displaystyle h(x)&#x3D;\frac{f(x)}{e^x}$，$\displaystyle h^{\prime}(x)&#x3D;\frac{f^{\prime}(x)-f(x)}{e^x}\ge 0$，$h(x)$ 在 $[M-1,+\infty)$ 上单调递增，再将 $f(x)&#x3D;h(x)e^x$ 代入条件 $2$，有 $\displaystyle 0\le h(x)\le \frac{\sqrt{2}}{e^x}$，由夹逼定理，则 $\displaystyle \lim_{x\to +\infty} h(x)&#x3D;0$，又由于 $h(M-1)&#x3D;0$，且 $h$ 在 $[M-1,+\infty)$ 上单调递增，故 $\forall x\in[M-1,+\infty),h(x)&#x3D;0\Rightarrow f(x)&#x3D;0$，而又由于引理 $1$， $(-\infty,M-1]\subset S$，故 $\forall x\in \mathbb R, f(x)&#x3D;0$ </p><p>$(3)$ $S$ 上下确界均存在，此时仿照 $(2)$ 即可</p><p>$(4)$ $S$ 为空集，不妨设 $f\gt 0$，记 $f(0)&#x3D;m_0\gt 0$，由于 $f$ 在 $\mathbb R$ 上单调，再分两种情况讨论：</p><p>$(\mathrm{i})$ 若 $f$ 单调递增，则 $\forall x\in [0,+\infty),f^{\prime}(x)\ge f(x)\ge f(0)&#x3D;m_0\gt 0$，显然与 $f$ 有界矛盾</p><p>$(\mathrm{ii})$ 若 $f$ 单调递减，考虑函数 $h(x)&#x3D;f(-x)$，容易验证若 $f$ 满足条件，则 $h$ 也满足条件，且有 $h(0)\gt 0$，$h$ 在 $\mathbb R$ 上单调递增，由情况 $(\mathrm{i})$，$h$ 不存在，故 $f$ 也不存在，矛盾</p><p>综上，$f$ 满足条件当且仅当 $f&#x3D;0$</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>原题作为高三数学一模压轴题的最后一问，题设的条件显然欠妥；然而，改编后的题目却很适合作为微积分或数学分析的一道习题。</p><p>事实上，证明过程中的引理 $1$ 是今年上海交通大学高等数学 $\mathrm{A}(1)$ 期末考试的压轴题，而情况 $(2)$ 中构造的函数 $h$ 也是利用微分方程解决不等式问题的常见技巧。</p><p>希望能借这道题帮看到这篇文章的同学们回顾一下上学期所学的微积分知识，也祝同学们在微积分 $\mathrm{A}(1)$ 中取得满意的成绩。（笔者已经寄了，$\mathrm{qwq}$）</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分A(1)</title>
    <link href="/24Fall/Calculus-A1/"/>
    <url>/24Fall/Calculus-A1/</url>
    
    <content type="html"><![CDATA[<p>大一上学期微积分A(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、数列极限"><a href="#一、数列极限" class="headerlink" title="一、数列极限"></a>一、数列极限</h2><h3 id="1-计算"><a href="#1-计算" class="headerlink" title="1. 计算"></a>1. 计算</h3><ol><li>定义法<ol><li>固定有限项，分步确定 $N$<ol><li>证明：若 $\displaystyle\lim_{n\to \infty}a_n&#x3D;a$，则 $\displaystyle \lim_{n\to \infty}\frac{a_1+a_2+\dots +a_n}{n}&#x3D;a$</li><li>证明：若 $\displaystyle\lim_{n\to \infty}\frac{a_n}{n}&#x3D;0$，则 $\displaystyle \lim_{n\to \infty}\frac{\max\{a_1,a_2,\dots ,a_n\}}{n}&#x3D;0$</li></ol></li><li>二项式定理放缩<ol><li>证明： $\displaystyle\lim_{n\to \infty}\sqrt[n]{n}&#x3D;1$</li><li>求 $\displaystyle\lim_{n\to \infty}n\left(\sqrt[n]{n}-1\right)^2$</li></ol></li><li>迭代：若 $\displaystyle\lim_{n\to \infty}\left(2a_n+a_{n+1}\right)&#x3D;0$，证明 $a_n$ 收敛，并求 $\displaystyle \lim_{n\to \infty}a_n$</li></ol></li><li>夹逼定理<ol><li>裂项放缩<ol><li>求 $\displaystyle\lim_{n\to \infty}\frac{n}{(n+1)^2}+\frac{n}{(n+2)^2}+\dots +\frac{n}{(2n)^2}$</li><li>求 $\displaystyle\lim_{n\to \infty}\frac{(2n-1)!!}{(2n)!!}$</li><li>证明： $\displaystyle\frac{1}{2\sqrt{n}}\lt \prod^n_{i&#x3D;1}\frac{2i-1}{2i}\lt \frac{1}{\sqrt{2n+1}}$</li></ol></li><li>常用放缩技巧<ol><li>$\gt 1;\gt 0$</li><li>$n!\gt \left(\frac{n}{2}\right)^{\frac{n}{2}}$</li><li>最大&#x2F;最小&#x2F;第一项放缩</li><li>$\sin ;\cos$ 有界</li><li>分子有理化</li><li>$\mathrm{Bernoulli}$ 不等式</li><li>平方差公式：求 $\displaystyle\prod_{i&#x3D;1}^{\infty}\left(1+\frac{1}{2^{2^i}}\right)$ </li><li>和差化积</li></ol></li></ol></li><li>单调收敛原理<ol><li>递推数列<ol><li>若 $\displaystyle a_{n+1}&#x3D;a_n+\frac{2-a_n^2}{2a_n}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>若 $\displaystyle 0\lt c\le 1,a_1&#x3D;\frac{c}{2},a_{n+1}&#x3D;\frac{c}{2}+\frac{a_n^2}{2}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>若 $\displaystyle a_1&#x3D;1,a_{n+1}&#x3D;1+\frac{1}{a_n}$，求 $\displaystyle \lim_{n\to \infty}a_n$</li></ol></li><li>上界放缩（见常用放缩技巧）</li></ol></li><li>$\mathrm{Stolz}$ 定理<ol><li>分子或分母为数列形式</li><li>分子或分母为 $n$<ol><li>证明：若 $\displaystyle a_0&#x3D;1,a_n&#x3D;\sin{a_{n-1}}$，则 $\displaystyle \lim_{n\to \infty}\sqrt{\frac{n}{3}}a_n&#x3D;1$</li><li>求 $\displaystyle\lim_{n\to \infty}\sqrt[n]{\frac{n!}{n^n}}$</li></ol></li></ol></li><li>利用函数（见函数极限）</li></ol><h3 id="2-证明"><a href="#2-证明" class="headerlink" title="2. 证明"></a>2. 证明</h3><ol><li>单调收敛原理</li><li>四则运算：若 $\displaystyle\lim_{n\to \infty}\left(a_n+a_{n+1}\right)&#x3D;\lim_{n\to \infty}\left(a_n+a_{n+2}\right)&#x3D;a$，求 $\displaystyle \lim_{n\to \infty}a_n$</li><li>$\mathrm{Cauchy}$ 收敛原理<ol><li>核心：将两元化为一元&#x2F;放缩（见常用放缩技巧）</li><li>证明：若 $\displaystyle a_1&#x3D;1,a_{n+1}&#x3D;a_n+\frac{1}{\sum_{k&#x3D;1}^{n}a_k}$，则 $a_n$ 收敛</li><li>证明：若 $0\lt a\lt 1$，则存在唯一的 $x$，使得 $x-a\sin x&#x3D;b$ </li><li>证明：若 $\displaystyle\exists M\gt 0,s.t.\forall n,\sum_{k&#x3D;1}^n{|x_{k+1}-x_k}|\le M$，则 $\{x_n\}$ 为 $\mathrm{Cauchy}$ 列</li><li>证明：若 $\displaystyle\forall n,p\in \mathbb N,|x_n-x_{n+p}|\le\frac{p}{n^2}$，则 $\{x_n\}$ 为 $\mathrm{Cauchy}$ 列</li></ol></li><li>反证法：证明 $a_n&#x3D;\tan n,a_n&#x3D;\sin n$ 发散</li><li>不同子列收敛到不同极限：证明 $\{(-1)^n\}$ 发散</li><li>常用证明技巧<ol><li>二分区间</li><li>取有界列的收敛子列</li></ol></li><li>常见陷阱<ol><li>无穷个子列的并收敛到同一极限 $\neq$ 极限存在</li><li>$\displaystyle\lim_{n\to \infty}|x_n-x_{n+p}|&#x3D;0,\forall p\in \mathbb N\rightarrow \{x_n\}$ 为 $\mathrm{Cauchy}$ 列？反例：$\displaystyle \sqrt n,\ln n,\sum_{k&#x3D;1}^{n}\frac{1}{k}$ </li><li>$\displaystyle|x_n-x_{n+p}|\le\frac{p}{n},\forall n,p\in \mathbb N\rightarrow \{x_n\}$ 为 $\mathrm{Cauchy}$ 列？反例： $\displaystyle\sum_{k&#x3D;1}^{n}\frac{1}{k}$</li></ol></li></ol><h2 id="二、函数极限"><a href="#二、函数极限" class="headerlink" title="二、函数极限"></a>二、函数极限</h2><h3 id="1-函数极限"><a href="#1-函数极限" class="headerlink" title="1. 函数极限"></a>1. 函数极限</h3><ol><li>利用数列<ol><li>取整</li><li>$\mathrm{Heine}$ 定理</li><li>从数列极限继承的方法</li><li>三角换元</li></ol></li><li>常见陷阱<ol><li>无穷多个无穷小量的乘积不一定是无穷小量</li><li>$\displaystyle a\gt 1,n\rightarrow \infty,n \cdot o\left(\frac{1}{n^a}\right)\neq o\left(\frac{1}{n^{a-1}}\right)$ </li><li>$0^0,1^\infty,\infty ^0$ 无意义</li><li>复合函数极限 $g(x)\neq u_0$ 或 $f(x)$ 连续</li><li>极限为 $0$ 的函数不一定为 $k$ 阶无穷小量：$\displaystyle\lim_{x\to 0}x\sin \frac{1}{x}$ </li><li>局部取极限&#x2F;等价因子替换：改用小 $o$ 或 $\mathrm{Taylor}$ 公式</li><li>$\mathrm{L^{\prime}Hospital}$ 法则：<ol><li>分母的导函数在邻域上不为零</li><li>导函数不一定连续</li><li>若 $f(x)$ 二阶可导，求 $\displaystyle\lim_{h\to 0}\frac{f(a+h)-2f(a)+f(a-h)}{h^2}$ </li><li>若 $f(x)$ 可导，且 $\displaystyle f(0)&#x3D;f^{\prime}(0)&#x3D;1$，求 $\displaystyle \lim_{x\to 0}\frac{f(\sin x)-1}{\ln f(x)}$</li></ol></li></ol></li><li>例题<ol><li>求 $\displaystyle \lim_{n\to \infty}n^p\sin \left(\sqrt 2+1\right)^n\pi$，其中 $p\gt 0$ </li><li>对于 $-1\lt a_0\lt 1$，若 $\displaystyle a_n&#x3D;\sqrt{\frac{1+a_{n-1}}{2}},b_n&#x3D;4^n\left(1-a_n\right)$，求 $\displaystyle \lim_{n\to \infty}b_n$ </li><li>已知 $\displaystyle b_1\gt a_1\gt 0$，若 $\displaystyle a_{n+1}&#x3D;\frac{a_n+b_n}{2},b_{n+1}&#x3D;\sqrt{a_{n+1}b_n}$，求 $\displaystyle\lim_{n\to \infty}a_n,\lim_{n\to \infty}b_n$ </li><li>求 $\displaystyle\lim_{n\to \infty}\sum_{k&#x3D;1}^{n}\left(\sqrt[3]{1+\frac{k}{n^2}}-1\right)$</li></ol></li></ol><h3 id="2-连续函数"><a href="#2-连续函数" class="headerlink" title="2. 连续函数"></a>2. 连续函数</h3><ol><li>常见反例函数<ol><li>$x^n\sin \frac{1}{x}$</li><li>$\mathrm{Dirichlet}$ 函数：$D(x)&#x3D;\begin{cases}0,x\in \mathbb R-\mathbb Q\\1,x\in Q\end{cases}$ </li><li>$\mathrm{Riemann}$ 函数：$R(x)&#x3D;\begin{cases}0,x\in \mathbb R-\mathbb Q\\\frac{1}{q},x&#x3D;\frac{p}{q},p,q互质,q\gt 0\end{cases}$</li></ol></li><li>闭区间上连续函数的性质<ol><li>零点定理</li><li>介值定理</li><li>有界性定理</li><li>最大最小值定理</li></ol></li><li>其他常用定理<ol><li>开区间上的单调函数：不存在可去间断点</li><li>区间上的单调函数：值域为区间 $\leftrightarrow$ 连续</li><li>区间上的严格单调连续函数：值域为区间，且反函数在原函数值域上连续</li></ol></li><li>一致连续<ol><li>等价条件<ol><li>闭区间上：连续</li><li>开区间上：$\exists M,\forall x,y,|f(y)-f(x)|\le M|y-x|^p,p\gt 0$ </li><li>证伪：$\displaystyle\exists \epsilon_0 \gt 0,\exists \{u_n\},\{v_n\},\lim_{n\to \infty}\left(u_n-v_n\right)&#x3D;0,|f(u_n)-f(v_n)|\gt \epsilon_0$</li></ol></li><li>例题：判断下列函数在给定区间上是否一致连续<ol><li>$\ln x,[2,+\infty)$ </li><li>$\sin x,[1,+\infty)$ </li><li>$x^\frac{1}{2},[0,+\infty)$ </li><li>$\sin x^2,x\in \mathbb R$</li></ol></li></ol></li><li>常用证明技巧<ol><li>二分区间</li><li>闭区间套定理</li><li>取有界列的收敛子列</li><li>$\displaystyle\lim_{x\to +\infty}f(x)&#x3D;+\infty\Leftrightarrow \exists \{x_n\},x_n\rightarrow +\infty,f(x_n)\lt a$ </li><li>补充间断点或无穷远点构造闭区间连续条件</li></ol></li><li>例题<ol><li>已知 $f,g\in C[a,b],\{x_n\}\subset [a,b]$，若 $f(x_1)&lt;g(x_1)$，且 $\forall x\in \mathbb N,g(x_n)&#x3D;f(x_{n+1})$，证明：$\exists \xi \in [a,b],s.t. f(\xi)&#x3D;g(\xi).$ </li><li>已知 $f\in C\{0\}$，若 $f(x+y)&#x3D;f(x)+f(y),\forall x,y\in \mathbb R$，证明：$f(x)&#x3D;cx.$ </li><li>证明：若 $f(x)$ 只有可去间断点，令 $\displaystyle g(x)&#x3D;\lim_{t\to x}f(t)$，则 $g(x)$ 为连续函数</li><li>$(2023)$ 设 $f(x)$ 在区间 $[a,+\infty)$ 上连续. 假设极限 $\displaystyle\lim_{x\to +\infty}f(x)$ 存在且有限，证明 $f(x)$ 在区间 $[a,+\infty)$ 上或者有最大值，或者有最小值.</li></ol></li></ol><h2 id="三、导数与微分"><a href="#三、导数与微分" class="headerlink" title="三、导数与微分"></a>三、导数与微分</h2><h3 id="1-导数"><a href="#1-导数" class="headerlink" title="1. 导数"></a>1. 导数</h3><ol><li>常见陷阱<ol><li>存在 $\mathrm{Weierstrass}$ 函数处处连续处处不可导</li><li>导数的四则运算要求 $f(x),g(x)$ 导数存在</li><li>$f(x)$ 在 $[a,b]$ 上可导 $\to$ $f^{\prime}(x)$ 在 $[a,b]$ 上连续？反例：$\displaystyle x^2\sin \frac{1}{x}$ </li><li>$f(x)\in C[a,b]$，$f(x)$ 在 $(a,b)$ 上可导 $\to$ $f^{\prime}_+(a),f^{\prime}_-(b)$ 存在？反例：$\displaystyle|x|^a\sin \frac{1}{x},0\lt a\le 1$ </li><li>可导的严格单调递增函数 $f^{\prime}(x)\gt 0$ ？反例：$x^3$ </li><li>导函数的左极限 $\neq$ 左导数</li></ol></li><li>例题<ol><li>利用微分求近似：$\sin 29°$ </li><li>求滑动门的包络线：$\begin{cases}\frac{x}{\cos \theta}+\frac{y}{\sin \theta}&#x3D;1\\\frac{y^{\prime}(\theta)}{x^{\prime}(\theta)}&#x3D;\frac{dy}{dx}&#x3D;-\tan \theta\end{cases}$ </li><li>$(2023)$ 求常数 $a$ 和 $b$，使得函数 $f\left(x\right)&#x3D;\begin{cases}\cos x, x\ge 0\\\frac{x^2+ax+b}{1+x}, x\lt 0\end{cases}$ 在点 $x&#x3D;0$ 处可导.</li></ol></li><li>高阶导数<ol><li>递推法<ol><li>令 $y&#x3D;(\arcsin x)^2$，求 $y^{(n)}(0)$ </li><li>令 $y&#x3D;\left(x+\sqrt{x^2+1}\right)^m$，求 $y^{(n)}(0)$ </li><li>令 $f(x)&#x3D;\arctan x$，证明：$(1+x^2)f^{(n+2)}(x)+2(n+1)xf^{(n+1)}(x)+n(n+1)f^{(n)}(x)&#x3D;0$，并求 $f^{(n)}(0)$</li></ol></li><li>利用多项式性质<ol><li>令 $\displaystyle P_{n,m}(x)&#x3D;\frac{d^n}{dx^n}\left(1-x^m\right)^n$，求 $P_{n,m}(1)$ </li><li>证明 $f(x)&#x3D;\begin{cases}e^{-\frac{1}{x^2}},x\neq 0\\0,x&#x3D;0\end{cases}$ 任意阶可导，并求 $f^{(n)}(0)$</li></ol></li><li>利用 $\mathrm{Euler}$ 公式：$e^{x+iy}&#x3D;e^x (\cos y+i\sin y)$ <ol><li>令 $f (x)&#x3D;e^x\sin x$，求 $f^{(n)}(x)$</li></ol></li><li>利用级数 $\displaystyle\frac{1}{1-x}&#x3D;\sum^\infty_{n&#x3D;0}x^n$ <ol><li>$(2023)$ 求函数 $f (x)$ 在点 $x&#x3D;0$ 处的 $2023$ 阶导数值 $f^{(2023)}(0)$</li></ol></li></ol></li></ol><h3 id="2-微分中值定理"><a href="#2-微分中值定理" class="headerlink" title="2. 微分中值定理"></a>2. 微分中值定理</h3><ol><li>定理内容<ol><li>$\mathrm{Fermat}$ 引理</li><li>$f(x),g(x)\in C[a,b],f(x),g(x)$ 在 $(a,b)$ 上可导<ol><li>$\mathrm{Rolle}$ 中值定理</li><li>$\mathrm{Lagrange}$ 中值定理</li><li>$\mathrm{Cauchy}$ 中值定理</li></ol></li><li>$f(x)$ 在 $[a,b]$ 上可导：$\mathrm{Darboux}$ 定理<ol><li>推论：导函数没有第一类间断点（即导函数的介值性质）</li></ol></li><li>广义 $\mathrm{Rolle}$ 中值定理<ol><li>$f(x)$ 在 $(a,b)$ 上可导，$\displaystyle\lim_{x\to a^+}f(x)&#x3D;\lim_{x\to b^-}f(x)$，则 $\exists \xi \in (a,b),s.t.f^{\prime}(\xi)&#x3D;0$ </li><li>$f(x)$ 在 $(a,+\infty)$ 上可导，$\displaystyle\lim_{x\to a^+}f(x)&#x3D;\lim_{x\to +\infty}f(x)$，则 $\exists \xi \in (a,+\infty),s.t.f^{\prime}(\xi)&#x3D;0$</li></ol></li></ol></li><li>应用<ol><li>求极限<ol><li>求 $\displaystyle\lim_{x\to e}\frac{\tan x^x-\tan e^x}{e^{x^x}-e^{e^x}}$ </li><li>求$\displaystyle\lim_{n\to \infty}n(\arctan \ln (n+1)-\arctan \ln n))$</li></ol></li><li>证明不等式<ol><li>证明： $\displaystyle\frac{x}{1+x}\lt \ln (1+x)\lt x$，其中 $x\gt -1$，且 $x\neq 0$ </li><li>证明： $px^{p-1}\le (x+1)^p-x^p\le p(x+1)^{p-1}$，其中 $p\gt 0$，并求 $\displaystyle\lim_{n\to \infty}\frac{1^p+2^p+\dots +n^p}{(n+1)^{p+1}}$</li><li>证明： $\displaystyle\frac{a^\frac{1}{n+1}}{(n+1)^2}\lt \frac{a^\frac{1}{n}-a^\frac{1}{n+1}}{\ln a}\lt \frac{a^\frac{1}{n}}{n^2}$ </li><li>证明： $a^y-a^x\gt (\cos x-\cos y)a^x\ln a$，其中 $\displaystyle 0\lt x\lt y\lt \frac{\pi}{2},a\gt 1$ </li><li>已知 $f(x)$ 在 $[0,+\infty)$ 上可导，若 $f^{\prime}(x)$ 单调递减，且 $f(0)&#x3D;0$，证明：$f(x_1+x_2)\le f(x_1)+f(x_2)$</li></ol></li><li>利用 $\mathrm{Rolle}$ 分析零点存在性<ol><li>证明： $x^4+2x^3+6x^2-4x-5&#x3D;0$ 有且仅有两个不同的实根</li><li>证明： $n$ 阶 $\mathrm{Laguerre}$ 多项式 $\displaystyle L_n(x)&#x3D;e^x\frac{d^n}{dx^n}(x^ne^{-x})$ 在 $(0,+\infty)$ 上有且仅有 $n$ 个根</li></ol></li><li>辅助函数 $(\mathrm{I})$：利用 $e^x$ <ol><li>$f^{\prime}(x)+g^{\prime}(x)f(x)$：构造 $(f(x)e^{g(x)})^{\prime}$ </li><li>$f^{\prime\prime}(x)+2f^{\prime}(x)+f(x)$：构造 $(f(x)e^x)^{\prime\prime}$</li><li>$f^{\prime\prime}(x)-f(x)$：构造 $(e^x(f^{\prime}(x)-f(x)))^{\prime}$ 或 $(e^{-x}(f^{\prime}(x)+f(x)))^{\prime}$ </li><li>$f^{\prime\prime}(x)-f^{\prime}(x)$：构造 $(f^{\prime}(x)-f(x))^{\prime}$ 或 $(e^{-x}f^{\prime}(x))^{\prime}$ </li><li>若 $f(x)$ 在 $\displaystyle\left[\frac{3\pi}{4},\frac{7\pi}{4}\right]$ 上可导，$\displaystyle f\left(\frac{3\pi}{4}\right)&#x3D;f\left(\frac{7\pi}{4}\right)&#x3D;0$，证明：$\displaystyle\exists \xi \in \left(\frac{3\pi}{4},\frac{7\pi}{4}\right),f^{\prime}(\xi)+f(\xi)&#x3D;\cos \xi$</li></ol></li><li>辅助函数 $(\mathrm{II})$：利用微分方程<ol><li>若 $f(x),g(x)$ 在 $[a,b]$ 上二阶可导，$f(a)&#x3D;f(b)&#x3D;g(a)&#x3D;g(b)&#x3D;0,g^{\prime\prime}(x)\neq 0(x\in (a,b))$，证明：$\displaystyle\exists \xi \in (a,b),s.t.\frac{f(\xi)}{g(\xi)}&#x3D;\frac{f^{\prime\prime}(\xi)}{g^{\prime\prime}(\xi)}$：构造 $h(x)&#x3D;f^{\prime}(x)g(x)-f(x)g^{\prime}(x)$ </li><li>若 $f(x),g(x)$ 在 $[a,b]$ 上可导，$g^{\prime}(x)\neq 0(x\in (a,b))$，证明：$\displaystyle\exists \xi \in (a,b),s.t.\frac{f(a)-f(\xi)}{g(\xi)-g(b)}&#x3D;\frac{f^{\prime}(\xi)}{g^{\prime}(\xi)}$：构造 $h(x)&#x3D;(f(a)-f(x))(g(x)-g(b))$ </li><li>若 $f(x)$ 在 $[0,1]$ 上可导，$f(0)&#x3D;0,f(x)\gt 0(0\lt x\lt 1)$，证明：$\displaystyle\exists \xi \in (0,1),s.t.\frac{2f^{\prime}(\xi)}{f(\xi)}&#x3D;\frac{f^{\prime}(1-\xi)}{f(1-\xi)}$：构造 $h(x)&#x3D;f^2(x)f(1-x)$ </li><li>若 $f(x)$ 在 $[0,1]$ 上二阶可导，$f(x)&gt;0(x\in [0,1]),f^{\prime}(0)&#x3D;f^{\prime}(1)&#x3D;0$，证明：$\exists \xi \in (0,1),s.t.f(\xi)f^{\prime\prime}(\xi)-2(f^{\prime}(\xi))^2&#x3D;0$：构造 $\displaystyle h(x)&#x3D;\frac{f^{\prime}(x)}{f^2(x)}$</li></ol></li></ol></li><li>例题<ol><li>若 $f(x)$ 在 $[a,c]$ 上连续，在 $(a,b)\cup (b,c)$ 上可导，证明：$\displaystyle\exists \xi \in [a,c],s.t.\left| \frac{f(c)-f(a)}{c-a}\right| \le \vert f^{\prime}(\xi)\vert$</li><li>若 $\displaystyle f(x)\in C^1[0,+\infty)$，且 $\displaystyle0\le f(x)\le \frac{x}{1+x^2}$，证明：$\displaystyle\exists \xi \gt 0,s.t. f^{\prime}(\xi)&#x3D;\frac{1-\xi ^2}{(1+\xi ^2)^2}$ </li><li>已知 $f(x)$ 在 $(a,+\infty)$ 上可导，若 $\displaystyle\displaystyle\lim_{x\to +\infty}f(x)$ 存在且有限，且 $\vert f^{\prime}(x)\vert$ 在 $(a,+\infty)$ 上递减，证明：$\displaystyle\lim_{x\to +\infty}xf^{\prime}(x)&#x3D;0$</li></ol></li></ol><h3 id="3-Taylor-公式"><a href="#3-Taylor-公式" class="headerlink" title="3. Taylor 公式"></a>3. Taylor 公式</h3><ol><li>求法<ol><li>典式：$e^x,\sin x,\cos x,\tan x,\ln (1+x),(1+x)^a,(1+x)^{-1},(1-x)^{-1}$ </li><li>变量替换：$\displaystyle \frac{1}{2x-x^2}(x&#x3D;1),e^{\sin ^2x}$ </li><li>长除法：$\displaystyle \frac{1}{\cos x},\frac{x}{x^2-2x+2}(x&#x3D;1)(2023)$ </li><li>利用奇偶性待定系数：$\displaystyle \frac{1}{\cos x},\arcsin x$ </li><li>利用级数（见高阶导数）：$\displaystyle \frac{x}{x^2-2x+2}(x&#x3D;1)(2023)$</li></ol></li><li>应用<ol><li>求近似：$\sqrt[12]{4000}$ </li><li>利用带 $\mathrm{Lagrange}$ 余项的 $\mathrm{Taylor}$ 展式<ol><li>设 $f(x)$ 在 $[a,b]$ 上二阶可导，证明：$\displaystyle \exists \xi \in (a,b),f(b)-2f\left(\frac{a+b}{2}\right)+f(a)&#x3D;\frac{(b-a)^2}{4}f^{\prime\prime}(\xi)$ </li><li>证明：$e\in \mathbb R-\mathbb Q$ </li><li>令 $f (x)&#x3D;f (0)+f^{\prime} (0) x+\frac{1}{2}f^{\prime\prime} (\theta (x) x) x^2,\theta (x)\in (0,1)$，证明：若 $f^{\prime\prime\prime} (x)\neq 0$，则 $\displaystyle\lim_{x\to 0}\theta (x)&#x3D;\frac{1}{3}$</li></ol></li><li>求数列极限：若 $\displaystyle a_n&#x3D;1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+\dots \frac{-1^{n-1}}{n}$，求 $\displaystyle \lim_{n\to \infty}a_n$ </li><li>利用两个对称的 $\mathrm{Taylor}$ 展式<ol><li>若 $f (x)$ 在 $[-1,1]$ 上三阶可导，且 $f (1)&#x3D;1, f (-1)&#x3D;0, f^{\prime} (0)&#x3D;0$，证明：$\exists \xi \in [-1,1], f^{\prime\prime\prime} (\xi)&#x3D;3$ </li><li>若 $\forall x\in \mathbb R,\vert f (x)\vert \le M_0, \vert f^{\prime\prime} (x)\vert \le M_2$，证明：$\vert f^{\prime} (x)\vert \le \sqrt{2 M_0 M_2}$ </li><li>若 $\forall x\in (0,1),\vert f (x)\vert \le M_0, \vert f^{\prime\prime} (x)\vert \le M_2$，证明：$\vert f^{\prime} (x)\vert \le 2M_0+\frac{1}{2}M_2$</li></ol></li></ol></li></ol><h3 id="4-导数的应用"><a href="#4-导数的应用" class="headerlink" title="4. 导数的应用"></a>4. 导数的应用</h3><ol><li>凹凸性<ol><li>开区间上的凸函数连续，且每一点处左右导数存在</li><li>闭区间反例：$\arcsin x, x\in[0,1], f (x)&#x3D;\begin{cases}x^2, -1\lt x\lt 1\\2, x&#x3D;\pm 2 \end{cases}$ （左右端点处）</li><li>开&#x2F;闭区间可导，则闭区间下凸 $\Leftrightarrow$  每一点切线在曲线下方</li><li>闭区间连续、开区间可导，则闭区间下凸 $\Leftrightarrow$ 导函数在开区间单增</li><li>闭区间连续、开区间二阶可导，则闭区间下凸 $\Leftrightarrow$ 二阶导 $\ge 0$</li></ol></li><li>$\mathrm{Newton}$ 法<ol><li>设 $f\in C^2[a, b], f (a) f (b)\lt 0,\forall x\in[a, b], f^{\prime}(x) f^{\prime\prime}(x)\neq 0$，且 $f$ 在 $(a, b)$ 上有唯一零点 $c$，则任取 $x_0\in[a, b]$，令 $\displaystyle x_{n+1}&#x3D;x_n-\frac{f (x_n)}{f^{\prime} (x_n)}$，若 $x_1\in [a, b]$，则 $\displaystyle \lim_{n\to \infty}x_n&#x3D;c$，且 $\displaystyle |x_{n+1}-c|\le \frac{M}{2 m}|x_n-c|^2, M&#x3D;\sup_{x\in[a, b]}|f^{\prime\prime} (x)|, m&#x3D;\inf_{x\in[a, b]}|f^{\prime} (x)|$</li></ol></li><li>函数作图<ol><li>要点：定义域、周期性、奇偶性、对称性、渐近线、增减性、凹凸性、特殊点</li><li>斜渐近线 $\displaystyle \Leftrightarrow \lim_{x\to \infty} \frac{f (x)}{x}&#x3D;a,\lim_{x\to \infty}(f (x)-ax)&#x3D;b$</li></ol></li><li>例题<ol><li>证明：$\displaystyle ab\le \frac{a^p}{p}+\frac{b^q}{q}$，其中 $\displaystyle p\gt 1, q\gt 1,\frac{1}{p}+\frac{1}{q}&#x3D;1, a\gt 0, b\gt 0$ </li><li>求曲线 $y^3-x^3+3 xy&#x3D;0$ 的渐近线</li><li>$(2024)$ 利用函数的凹凸性证明：<ol><li>$\forall x\in (0,1),n\in \mathbb N$，$\displaystyle \frac{n^x\cdot n!}{(x+1)\cdots (x+n)}\lt 1$ </li><li>$\displaystyle \lim_{n\to +\infty}\frac{n^x\cdot n!}{(x+1)\cdots (x+n)}$ 存在</li></ol></li></ol></li></ol><h2 id="四、积分"><a href="#四、积分" class="headerlink" title="四、积分"></a>四、积分</h2><h3 id="1-不定积分"><a href="#1-不定积分" class="headerlink" title="1. 不定积分"></a>1. 不定积分</h3><ol><li>常用方法<ol><li>分部积分</li><li>有理分式分解</li><li>三角换元</li><li>万能替换</li><li>可化为有理式的简单无理式</li><li>$\mathrm{Euler}$ 换元</li><li>联合积分法</li><li>递推法</li></ol></li><li>例题<ol><li>$\displaystyle \int \sqrt{x^2+a^2} dx$ </li><li>$\displaystyle \int \left((x+a)^2+b^2\right)^{-k}dx, b\neq 0$ </li><li>$\displaystyle I&#x3D;\int e^{ax}\sin bx dx, J&#x3D;\int e^{ax} \cos bx dx$ </li><li>$\displaystyle \int \frac{\alpha \cos x+\beta \sin x}{\lambda \cos x+\mu \sin x}dx$</li><li>$\displaystyle I&#x3D;\int \frac{1}{1+x^2+x^4}dx, J&#x3D;\int \frac{x^2}{1+x^2+x^4}dx$ </li><li>$\displaystyle I&#x3D;\int \frac{\cos^3 x}{\cos x+\sin x}dx, J&#x3D;\int \frac{\sin^3 x}{\cos x+\sin x}dx$ </li><li>$\displaystyle \int \frac{1}{\sin (x+a)\sin (x+b)}dx, a-b\neq k\pi, k\in \mathbb Z$</li><li>$\displaystyle \int e^x\left (\frac{1-x}{1+x^2}\right)^2 dx$ </li><li>$\displaystyle \int \frac{1+\sin x}{1+\cos x}e^x dx$ </li><li>$\displaystyle \int \frac{x^2-1}{x^2+1}\frac{dx}{\sqrt{1+x^2+x^4}}$ </li><li>$\displaystyle \int \frac{5 x^3+3 x-1}{(x^3+3 x+1)^3}dx$ </li><li>$\displaystyle \int \frac{1-2 x^3}{(x^2-x+1)^3}dx$ </li><li>$\displaystyle \int \frac{1}{x^4+1}dx$</li></ol></li></ol><h3 id="2-定积分与广义积分"><a href="#2-定积分与广义积分" class="headerlink" title="2. 定积分与广义积分"></a>2. 定积分与广义积分</h3><ol><li>常用方法<ol><li>转为不定积分（见不定积分）</li><li>颠倒积分区间后相加</li><li>递推法</li><li>拆积分区间</li></ol></li><li>例题<ol><li>$\displaystyle \int_0^{+\infty} \frac{\arctan x}{(1+x^2)^\frac{3}{2}}dx$ </li><li>$\displaystyle \int_0^1 \frac{\ln (1+x)}{1+x^2}dx$ </li><li>$\displaystyle \int_0^{\frac{\pi}{2}}\ln\cos xdx$ </li><li>$\displaystyle \int_0^{+\infty} \frac{x\ln x}{(1+x^2)^2}dx$ </li><li>$\displaystyle \int_0^{+\infty} \frac{\arctan ax-\arctan bx}{x}dx$，其中 $a,b\gt 0$ </li><li>证明：$\displaystyle I_n&#x3D;\int_0^{\frac{\pi}{2}}\sin^nxdx&#x3D;\int_0^{\frac{\pi}{2}} \cos^nxdx$，并求 $I_n$ </li><li>$f\in C[1,+\infty)$，证明：$\forall a\gt 1,\displaystyle \int_1^a f (x^2+\frac{a^2}{x^2})\frac{dx}{x}&#x3D;\int_1^a f (x+\frac{a^2}{x})\frac{dx}{x}$</li></ol></li></ol><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h3><ol><li>平面区域的面积：函数形式、极坐标形式、参数方程形式</li><li>曲线弧长：函数形式、参数方程形式（极坐标转化为参数方程）</li><li>旋转体的体积：函数形式、参数方程形式</li><li>旋转面的面积：函数形式、参数方程形式（极坐标转化为参数方程）</li><li>平面曲线的曲率</li><li>积分的物理应用</li></ol><h3 id="4-积分审敛"><a href="#4-积分审敛" class="headerlink" title="4. 积分审敛"></a>4. 积分审敛</h3><ol><li>$\mathrm{Cauchy}$ 收敛原理</li><li>非负函数：比较判别法</li><li>变号函数：$\mathrm{Dirichlet}$ 判别法、$\mathrm{Abel}$ 判别法</li></ol><h3 id="5-证明"><a href="#5-证明" class="headerlink" title="5. 证明"></a>5. 证明</h3><ol><li>常用定理<ol><li>积分估值</li><li>$\mathrm{Cauchy}$ 不等式</li><li>积分第一中值定理</li><li>积分第二中值定理</li><li>$\mathrm{Newton-Leibnitz}$ 公式</li><li>带积分余项的 $\mathrm{Taylor}$ 公式：余项为 $\displaystyle \frac{1}{n!}\int_{x_0}^x (x-t)^n f^{(n+1)}(t) dt$</li></ol></li><li>例题<ol><li>$f$ 在 $[0,1]$ 上可导，$\displaystyle f (1)&#x3D;4\int_{0}^{\frac{1}{4}}e^{1-x^3}f (x) dx$，证明：$\exists \xi \in[0,1], s.t. f^{\prime} (\xi)&#x3D;3\xi^2 f (\xi)$ </li><li>$f$ 可导，$f^{\prime} (0)\neq 0$，$\displaystyle \int_{0}^{x}f (t) dt&#x3D;f (\xi (x)) x$，其中 $\xi (x)&#x3D;(0, x)$，求 $\displaystyle \lim_{x\to 0}\frac{\xi (x)}{x}$ </li><li>$f\in C^2[-1,1]$，$f (0)&#x3D;0$，证明：$\displaystyle \exists \xi \in [-1,1], s.t.f^{\prime\prime} (\xi)&#x3D;3\int_{-1}^{1}f (x) dx$ </li><li>$\displaystyle f, g\in C[a, b],\int_{a}^{x}f (t) dt\ge \int_{a}^{x}g (t) dt$，其中 $a\le x\le b$，且 $\displaystyle \int_{a}^{b}f (t) dt&#x3D;\int_{a}^{b}g (t) dt$，证明：$\displaystyle \int_{a}^{b}xf (x) dx\le \int_{a}^{b}xg (x) dx$ </li><li>$f\in C^1[a, b]$，且 $f (a)&#x3D;0$，证明：$\displaystyle \int_a^b f^2 (x) dx\le \frac{(b-a)^2}{2}\int_a^b (f^{\prime} (x))^2 dx-\frac{1}{2}\int_a^b (x-a)^2 (f^{\prime} (x))^2 dx$ </li><li>证明：$\displaystyle \left (\frac{2 n-1}{e}\right)^{\frac{2 n-1}{2}}\lt 1\cdot 3\cdot 5\cdot \dots \cdot (2 n-1)\lt \left (\frac{2 n+1}{e}\right)^{\frac{2 n+1}{2}}$ </li><li>$f\in C^1[0, a]$，$f (0)&#x3D;0$，证明：$\displaystyle \int_0^a|f (x) f^{\prime} (x)|dx\le \frac{a}{2}\int_0^a (f^{\prime} (x))^2 dx$ </li><li>$f\in C^1[0,1]$，证明：<ol><li>$\displaystyle |f (x)|\le\int_0^1|f (t)|dt+\int_0^1|f^{\prime} (t)|dt$，其中 $x\in[0,1]$ </li><li>$\displaystyle \left|f \left(\frac{1}{2}\right)\right|\le\int_0^1|f (t)|dt+\frac{1}{2}\int_0^1|f^{\prime} (t)|dt$</li></ol></li><li>证明：$\displaystyle \int_0^{\frac{\pi}{2}}e^{-R\sin x}\begin{cases}\lt \frac{\pi}{2 R}(1-e^{-R}), R\gt 0\\\gt \frac{\pi}{2 R}(1-e^{-R}), R\lt 0 \end{cases}$ </li><li>证明下列等式：<ol><li>$\displaystyle \sum_{k&#x3D;1}^n (-1)^{k+1}\frac{1}{k}C_n^k&#x3D;1+\frac{1}{2}+\dots +\frac{1}{n}$ </li><li>$\displaystyle \sum_{k&#x3D;0}^n (-1)^k\frac{1}{2 k+1}C_n^k&#x3D;\frac{(2 n)!!}{(2 n+1)!!}$</li></ol></li><li>设 $f (x)$ 在每个有限区间上可积，且 $\displaystyle \lim_{x\to +\infty}f (x)&#x3D;A,\lim_{x\to -\infty}f (x)&#x3D;B$，其中 $A, B$ 都是有限数，证明：$\displaystyle \forall a\gt 0,\int_{-\infty}^{+\infty}(f (x+a)-f (x)) dx$ 存在，并求其值</li><li>设函数 $f (x)$ 在 $[0,+\infty)$ 上连续且极限 $\displaystyle \lim_{x\to +\infty}f (x)$ 存在，记作 $f (+\infty)$，证明：$\displaystyle \int_0^{+\infty}\frac{f (ax)-f (bx)}{x}dx&#x3D;(f (0)-f (+\infty)) \ln\frac{b}{a}$，其中 $a, b$ 为两个正数</li><li>$\displaystyle \int_a^{+\infty} f (x) dx$ 收敛，$f (x)$ 在 $[a,+\infty)$ 上单调，证明：$\displaystyle \lim_{x\to +\infty}xf (x)&#x3D;0$ </li><li>设 $f (x)$ 在 $(0,1]$ 上单调，在 $x&#x3D;0$ 的邻域内无界，证明：$\displaystyle \int_0^1 f (x) dx$ 收敛时，有 $\displaystyle \int_0^1 f (x) dx&#x3D;\lim_{n\to \infty}\frac{1}{n}\sum_{i&#x3D;1}^n f\left(\frac{i}{n}\right)$；对于一般的 $f (x)$，瑕积分 $\displaystyle \int_a^b f (x) dx$ 是否可以看成相应 $\mathrm{Riemann}$ 和 $\displaystyle \sum_{i&#x3D;1}^nf (\xi_i)\Delta x_i$ 的极限？</li><li>设 $f\in C (0,+\infty)$，且 $\forall a\gt 0, b\gt 1$，都有积分值 $\displaystyle \int_a^{ab}f (x) dx$ 与 $a$ 无关，求证：存在常数 $C$，使得 $\displaystyle f (x)&#x3D;\frac{C}{x}, x\in (0,+\infty)$</li></ol></li></ol><h2 id="五、常微分方程"><a href="#五、常微分方程" class="headerlink" title="五、常微分方程"></a>五、常微分方程</h2><h3 id="1-ODE-的计算"><a href="#1-ODE-的计算" class="headerlink" title="1. ODE 的计算"></a>1. ODE 的计算</h3><ol><li>一阶 $\mathrm{ODE}$<ol><li>变量分离法</li><li>常数变易法</li><li>齐次方程：$\displaystyle y^{\prime}&#x3D;f \left(\frac{y}{x}\right)\Rightarrow$ 令 $\displaystyle u&#x3D;\frac{y}{x}$ </li><li>一次分式：$\displaystyle y^{\prime}&#x3D;\frac{a_1 x+b_1 y+c_1}{a_2 x+b_2 y+c_2}$<ol><li>$\displaystyle c_1&#x3D;c_2&#x3D;0\Rightarrow y^{\prime}&#x3D;\frac{a_1+b_1\frac{y}{x}}{a_2+b_2\frac{y}{x}}$，再令 $\displaystyle u&#x3D;\frac{y}{x}$ </li><li>$\displaystyle \frac{a_1}{a_2}&#x3D;\frac{b_1}{b_2}&#x3D;k\Rightarrow$ 令 $\displaystyle a_2 x+b_2 y&#x3D;u$</li><li>$\displaystyle \begin{cases}a_1 x+b_1 y+c_1\\a_2 x+b_2 y+c_2 \end{cases}$ 交于一点 $(x_0, y_0)\Rightarrow$ 令 $\displaystyle \begin{cases}X&#x3D;x-x_{0}\\Y&#x3D;y-y_{0} \end{cases}$，再令 $\displaystyle u&#x3D;\frac{Y}{X}$</li></ol></li><li>一阶隐方程<ol><li>$y&#x3D;f (x, y^{\prime})\Rightarrow$ 令 $u&#x3D;y^{\prime}$，再两边对 $x$ 求导</li><li>$x&#x3D;f (y, y^{\prime})\Rightarrow$ 令 $u&#x3D;y^{\prime}$，再两边对 $y$ 求导</li><li>$F (x, y^{\prime})&#x3D;0\Rightarrow$ 令 $u&#x3D;y^{\prime}$，若 $\displaystyle \begin{cases}x&#x3D;f(t)\\u&#x3D;g (t) \end{cases}$，则 $\displaystyle \begin{cases}x&#x3D;f(t)\\y&#x3D;\int g (t) f^{\prime} (t) dt+C \end{cases}$ </li><li>$F (y, y^{\prime})&#x3D;0\Rightarrow$ 令 $u&#x3D;y^{\prime}$，若 $\displaystyle \begin{cases}y&#x3D;f(t)\\u&#x3D;g (t) \end{cases}$，则 $\displaystyle \begin{cases}x&#x3D;\int g(t) f^{\prime}(t) dt+C\\y&#x3D;f (t) \end{cases}$</li></ol></li><li>恰当方程<ol><li>$ydx+xdy&#x3D;d (xy)$ </li><li>$\displaystyle \frac{ydx-xdy}{y^2}&#x3D;d\left (\frac{x}{y}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2}&#x3D;-d\left (\frac{y}{x}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{xy}&#x3D;d\left (\ln\left|\frac{x}{y}\right|\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2+y^2}&#x3D;d\left (\arctan \frac{x}{y}\right)$ </li><li>$\displaystyle \frac{ydx-xdy}{x^2-y^2}&#x3D;\frac{1}{2}d\left (\ln\left|\frac{x-y}{x+y}\right|\right)$ </li><li>$\displaystyle \frac{xdx+ydy}{x^2+y^2}&#x3D;\frac{1}{2}d\left(\ln(x^2+y^2)\right)$</li></ol></li><li>特殊方程<ol><li>$\displaystyle \frac{dy}{dx}&#x3D;p (x) y+q (x) y^n\Rightarrow y^{-n}\frac{dy}{dx}&#x3D;p (x) y^{1-n}+q (x)\Rightarrow$ 令 $z&#x3D;y^{1-n}$ </li><li>$\displaystyle \frac{dy}{dx}&#x3D;p (x) y^2+q (x) y+r (x)\Rightarrow$ 找特解 $\psi (x)$，再令 $z&#x3D;y-\psi (x)$</li></ol></li></ol></li><li>高阶 $\mathrm{ODE}$<ol><li>降阶法<ol><li>$F (x, y^{(k)}, y^{(k+1)},\dots ,y^{(n)})&#x3D;0\Rightarrow$ 令 $u&#x3D;y^{(k)}$ </li><li>$F (y, y^{\prime}, \dots ,y^{(n)})&#x3D;0\Rightarrow$ 令 $u&#x3D;y^{\prime}$ </li><li>$y, y^{\prime}, \dots ,y^{(n)}$ 以齐次多项式出现 $\Rightarrow$ 令 $\displaystyle u&#x3D;\frac{y^{\prime}}{y}$</li></ol></li><li>二阶线性 $\mathrm{ODE}$ 的常数变易法<ol><li>已知两个线性无关解：假设 $c_1^{\prime} (x) y_1(x)+c_2^{\prime} (x) y_2 (x)&#x3D;0$ </li><li>已知一个非零解</li></ol></li><li>常系数 $\mathrm{ODE}$ 的特征法<ol><li>齐次：单实根、单复根、多重实根、多重复根</li><li>非齐次<ol><li>$p (t) e^{\lambda t}\Rightarrow q (t) t^ke^{\lambda t}$ </li><li>$p (t) e^{\alpha t}\sin \beta t$ 或 $p (t) e^{\alpha t}\cos \beta t\Rightarrow t^k[P (t) \cos\beta t+Q (t)\sin \beta t]e^{\alpha t}$ </li><li>叠加原理</li></ol></li></ol></li><li>$\mathrm{Euler}$ 方程：$x^ny^{(n)}+a_1 x^{n-1}y^{(n-1)}+\dots +a_{n-1}xy^{\prime}+a_nx&#x3D;f (x)$<ol><li>令 $u&#x3D;\ln|x|\Rightarrow x^ny^{(n)}&#x3D;D (D-1)\dots (D-n+1) y$，其中 $D$ 表示 $\displaystyle \frac{d}{du}$</li></ol></li></ol></li><li>微分方程组：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a></li><li>例题<ol><li>$xy^{\prime}+y&#x3D;y\ln (xy)$ </li><li>$xdy-ydx&#x3D;\sqrt{x^2+y^2}dx$ </li><li>$y^{\prime\prime}\cos x-2 y^{\prime}\sin x+3 y\cos x&#x3D;e^x$ </li><li>$(x-2 xy-y^2) y^{\prime}+y^2&#x3D;0$ </li><li>$y^4 dx+(2 x^2-3 xy^3) dy&#x3D;0$ </li><li>$x^{\prime}&#x3D;\begin{pmatrix} 3&amp;5\\ -5&amp;3\end{pmatrix}x$</li><li>$\begin{cases} x^{\prime}&#x3D;-3x-y\\y^{\prime}&#x3D;x-y\end{cases}$</li><li>$x^{\prime}&#x3D;\begin{pmatrix} 1&amp;1 \\ 0&amp;1 \end{pmatrix} x+\begin{pmatrix} e^{-t} \\ 0 \end{pmatrix}$，$x(0)&#x3D;\begin{pmatrix} -1\\1 \end{pmatrix}$</li><li>$\begin{cases} x^{\prime}&#x3D;y+z\\y^{\prime}&#x3D;z+x\\z^{\prime}&#x3D;x+y\end{cases}$，$\begin{cases}x(0)&#x3D;1\\y(0)&#x3D;0\\z(0)&#x3D;5\end{cases}$</li></ol></li></ol><h3 id="2-证明题"><a href="#2-证明题" class="headerlink" title="2. 证明题"></a>2. 证明题</h3><ol><li>解的存在唯一性定理<ol><li>一阶 $\mathrm{ODE}$</li><li>一阶线性 $\mathrm{ODE}$</li><li>高阶线性 $\mathrm{ODE}$</li><li>微分方程组</li></ol></li><li>例题<ol><li>$\displaystyle f\in C^1[0,+\infty),\lim_{x\to +\infty}f (x)+f^{\prime} (x)&#x3D;0$，求 $\displaystyle \lim_{x\to +\infty} f (x)$ </li><li>$f (x), g (x), y (x)\in C[a, b], f (x)\gt 0,\displaystyle y (x)\le g (x)+\int_a^x f (t) y (t) dt,\forall x\in [a, b]$，证明：$\displaystyle y (x)\le g (x)+\int_a^xf (t) g (t) e^{\int_t^xf (s) ds}dt,\forall x\in[a, b]$ </li><li>$f (x)$ 在 $[0,+\infty)$ 上连续，$\displaystyle \forall x\ge 0,0\le \int_0^xf (t) dt\le f^2 (x)$，证明：<ol><li>若存在 $0\le a\lt b, f (a)&#x3D;f (b)&#x3D;0$，则 $\forall x\in[a, b], f (x)&#x3D;0$ </li><li>若存在 $c\gt 0, f (c)\neq 0$，则 $\displaystyle f (x)\gt \frac{1}{2}(x-c)$</li></ol></li><li>设 $f (x)$ 在 $[0,1]$ 上非负连续，且满足 $\displaystyle (f (x))^2\le 1+2\int_0^x f (t) dt, x\in [0,1]$，证明：$f (x)\le 1+x, x\in[0,1]$ </li><li>$(2023)$ 在微分方程 $y^{\prime}+a (x) y&#x3D;b (x)$ 中，已知 $a(x), b(x)\in C(\mathbb R)$，若 $\exists c\gt 0, s.t. a (x)\ge c,\forall x\ge 0$，且 $\displaystyle \lim_{x\to +\infty}b (x)&#x3D;0$，证明：该方程的任意解 $y (x)$ 均满足 $\displaystyle \lim_{x\to +\infty} y (x)&#x3D;0$ </li><li>$(2023)$ 设函数 $f (x)\in C[0,1]$，且满足 $\displaystyle |f (x)|\le 1+\int_0^x f (t) dt,\forall x\in[0,1]$，证明：$|f (x)|\le e^x,\forall x\in [0,1]$ </li><li>设 $p (x)&#x3D;x^n+a_{n-1}x^{n-1}+\dots +a_1 x+a_0$ 为实系数 $n$ 次多项式，若 $p (x)\ge 0, x\in \mathbb R$，证明：$p (x)+p^{\prime} (x)+\dots +p^{(n)}(x)\ge 0, x\in \mathbb R$</li><li>证明：若函数 $f$ 在 $\mathbb R$ 上可导，且 $\forall x\in \mathbb R$，$\begin{cases} |f^{\prime}(x)|\ge |f(x)|\\ |f(x)|\le \sqrt{2}\end{cases}$，则 $f&#x3D;0$</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础</title>
    <link href="/24Fall/CProgramming/"/>
    <url>/24Fall/CProgramming/</url>
    
    <content type="html"><![CDATA[<p>大一上学期程序设计基础的CheatSheet，目前已完结。</p><span id="more"></span><h2 id="一、随机数"><a href="#一、随机数" class="headerlink" title="一、随机数"></a>一、随机数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">double</span> a,b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>    <span class="hljs-type">double</span> d=<span class="hljs-built_in">rand</span>()/(<span class="hljs-type">double</span>)(RAND_MAX<span class="hljs-number">+1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,a+d*(b-a<span class="hljs-number">+1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、二维动态数组"><a href="#二、二维动态数组" class="headerlink" title="二、二维动态数组"></a>二、二维动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-type">int</span> **a = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span> *));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        a[i] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-built_in">free</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、链表"><a href="#三、链表" class="headerlink" title="三、链表"></a>三、链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *last;<br>&#125;NODE;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    NODE *head = <span class="hljs-literal">NULL</span>;<br>    NODE *tail = <span class="hljs-literal">NULL</span>;<br>    NODE *temp = <span class="hljs-literal">NULL</span>;<br>    NODE *newNode = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">// 插入元素</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        newNode = (NODE *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(NODE));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newNode-&gt;data);<br>        newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            head = newNode;<br>            tail = newNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tail-&gt;next = newNode;<br>            newNode-&gt;last = tail;<br>            tail = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(temp-&gt;data==x)&#123;<br>            <span class="hljs-keyword">if</span>(temp==head)&#123;<br>                head = head-&gt;next;<br>                head-&gt;last = <span class="hljs-literal">NULL</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp==tail)&#123;<br>                tail = tail-&gt;last;<br>                tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp-&gt;last-&gt;next = temp-&gt;next;<br>                temp-&gt;next-&gt;last = temp-&gt;last;<br>            &#125;<br>            <span class="hljs-built_in">free</span>(temp);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 循环链表</span><br>    tail-&gt;next = head;<br>    head-&gt;last = tail;<br>    <br>    <span class="hljs-comment">// 取消循环</span><br>    tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;last = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    NODE *p = head;<br>    NODE *q = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        q = p-&gt;last;<br>        p-&gt;last = p-&gt;next;<br>        p-&gt;next = q;<br>        p = p-&gt;last;<br>    &#125;<br>    head = q-&gt;last;<br><br>    <span class="hljs-comment">// 正向输出</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">// 反向输出</span><br>    temp = tail;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>        temp = temp-&gt;last;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">// 链表排序</span><br>    NODE *p1 = head;<br>    NODE *p2 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span>)&#123;<br>        p2 = p1-&gt;next;<br>        <span class="hljs-keyword">while</span>(p2!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)&#123;<br>                <span class="hljs-type">int</span> temp = p1-&gt;data;<br>                p1-&gt;data = p2-&gt;data;<br>                p2-&gt;data = temp;<br>            &#125;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 释放链表</span><br>    temp = head;<br>    <span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = head;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、快排与二分"><a href="#四、快排与二分" class="headerlink" title="四、快排与二分"></a>四、快排与二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> i=l,j=r;<br>        <span class="hljs-type">int</span> pivot=a[l];<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">while</span>(a[i]&lt;=pivot &amp;&amp; i&lt;r)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(a[j]&gt;pivot)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                <span class="hljs-type">int</span> temp=a[i];<br>                a[i]=a[j];<br>                a[j]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> temp=a[l];<br>        a[l]=a[j];<br>        a[j]=temp;<br>        <span class="hljs-built_in">qsort</span>(a,l,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">qsort</span>(a,j<span class="hljs-number">+1</span>,r);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]==x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&gt;x)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">bsearch</span>(a,l,mid<span class="hljs-number">-1</span>,x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">bsearch</span>(a,mid<span class="hljs-number">+1</span>,r,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowerbound</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=x)&#123;<br>            <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">0</span> || a[mid<span class="hljs-number">-1</span>]&lt;x)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowerbound</span>(a,l,mid<span class="hljs-number">-1</span>,x);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowerbound</span>(a,mid<span class="hljs-number">+1</span>,r,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> *a=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-built_in">qsort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 二分查找等于</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">bsearch</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,x));<br><br>    <span class="hljs-comment">// 二分查找大于等于</span><br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">lowerbound</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,y));<br>    <br>    <span class="hljs-comment">// 二分查找大于</span><br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;z);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">lowerbound</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,z<span class="hljs-number">+1</span>));<br>    <br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、STL-Deque"><a href="#五、STL-Deque" class="headerlink" title="五、STL Deque"></a>五、STL Deque</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tuple_cmp</span><span class="hljs-params">(tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a,tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)==<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a)&lt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)&lt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_matrix</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;deque&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>            temp.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        matrix.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,matrix[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_sorted_tuple</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; sorted_tuple;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>        sorted_tuple.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_tuple</span>(x,y));<br>    &#125;<br>    <span class="hljs-built_in">stable_sort</span>(sorted_tuple.<span class="hljs-built_in">begin</span>(),sorted_tuple.<span class="hljs-built_in">end</span>(),tuple_cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(sorted_tuple[i]),<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(sorted_tuple[i]));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_stack</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        stack.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack.<span class="hljs-built_in">back</span>());<br>        stack.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        queue.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,queue.<span class="hljs-built_in">front</span>());<br>        queue.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>        <span class="hljs-built_in">create_matrix</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>        <span class="hljs-built_in">create_sorted_tuple</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>        <span class="hljs-built_in">create_stack</span>(); <br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>        <span class="hljs-built_in">create_queue</span>(); <br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、STL-Set"><a href="#六、STL-Set" class="headerlink" title="六、STL Set"></a>六、STL Set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; s1,s2,cap,cup,diff;<br>    <span class="hljs-type">int</span> n1,n2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n2; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_union</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cup, cup.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">begin</span>(); it!=cup.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_intersection</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cap, cap.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cap.<span class="hljs-built_in">begin</span>(); it!=cap.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_difference</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(diff, diff.<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=diff.<span class="hljs-built_in">begin</span>(); it!=diff.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator a=cup.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator b=cup.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, *it, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),it));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),a), *a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),b), *b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CheatSheet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一上</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数(1)</title>
    <link href="/24Fall/LinearAlgebra-1/"/>
    <url>/24Fall/LinearAlgebra-1/</url>
    
    <content type="html"><![CDATA[<p>大一上学期线性代数(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、基本定义"><a href="#一、基本定义" class="headerlink" title="一、基本定义"></a>一、基本定义</h2><ol><li>映射：详见<a href="https://sqzr2319.github.io/DiscreteMath-1">离散数学(1)</a></li><li>数域：非空且对四则运算封闭，$\mathbb Q\subset \mathbb F\subset \mathbb R$</li></ol><h2 id="二、矩阵与消元"><a href="#二、矩阵与消元" class="headerlink" title="二、矩阵与消元"></a>二、矩阵与消元</h2><ol><li>证明<ol><li>$AB&#x3D;A*B$ 的列 $&#x3D;A$ 的行 $*B&#x3D;\sum A$ 的列 $*B$ 的行</li><li>上&#x2F;下三角矩阵的乘积仍然是上&#x2F;下三角矩阵</li><li>上&#x2F;下三角矩阵的逆仍然是上&#x2F;下三角矩阵</li><li>可逆矩阵存在 $\mathrm{LU}$ 分解 $\Leftrightarrow$ 各阶顺序主子式非零</li><li>$\mathrm{LDU}$ 分解唯一 $\Rightarrow$ 对称矩阵 $S&#x3D;LDL^T\Rightarrow$ 正定矩阵 $S&#x3D;CC^T$</li></ol></li><li>计算<ol><li>线性方程组的唯一解</li><li>矩阵的逆</li><li>$\mathrm{LU&#x2F;LDU&#x2F;PLU&#x2F;LUP&#x2F;Cholesky}$ 分解</li></ol></li><li>分块矩阵<ol><li>乘法条件：$A&#x3D;(A_{ij})_{m\times n},B&#x3D;(B_{jk})_{n\times p},\forall 1\le j\le n, A_{ij}$ 的行指标 $&#x3D;B_{jk}$ 的列指标</li><li>$A&#x3D;\mathrm{diag}\{A_1,\dots ,A_n\}$ 可逆 $\leftrightarrow$ $\forall 1\le i\le n, A_i$  可逆，且 $A^{-1}&#x3D;\mathrm{diag}\{A_1^{-1},\dots ,A_n^{-1}\}$</li><li>上三角分块矩阵可逆 $\leftrightarrow$ 对角线矩阵均可逆，且逆矩阵的对角线为对角线矩阵的逆</li><li>$M&#x3D;\begin{bmatrix} A&amp;B \\ C&amp;D \end{bmatrix}$ 可逆 $\Rightarrow$ $A$ 可逆 $\Leftrightarrow D-CA^{-1}B$ 可逆 $\Leftrightarrow D$ 可逆 $\Leftrightarrow A-BD^{-1}C$ 可逆</li><li>$A\in M_n (\mathbb F)$ 可逆，$u, v\in \mathbb F^n$，则 $A+uv^T$ 可逆 $\leftrightarrow$ $1+v^TA^{-1} u\neq 0$ ，且当 $A+uv^T$ 可逆时，$(A+uv^T)^{-1}&#x3D;A^{-1}-\frac{A^{-1}uv^TA^{-1}}{1+v^TA^{-1}u}$</li><li>$I+uv^T$ 可逆 $\leftrightarrow$ $1+v^Tu\neq 0$，且当 $I+uv^T$ 可逆时，$(1+uv^T)^{-1}&#x3D;I-\frac{uv^T}{1+v^Tu}$</li></ol></li><li>例题<ol><li>$(2023)$ 证明：若 $A\in \mathbb M_n (\mathbb R)$ 正定，则 $\forall x\in \mathbb R^n, 0\le x^T (A+xx^T)^{-1}x\lt 1$</li></ol></li></ol><h2 id="三、线性空间"><a href="#三、线性空间" class="headerlink" title="三、线性空间"></a>三、线性空间</h2><ol><li>线性空间<ol><li>定义：$+$ 封闭&#x2F;零元&#x2F;负元&#x2F;交换&#x2F;结合；$\times$ 封闭&#x2F;结合&#x2F;一元&#x2F;分配</li><li>子空间：$+,\times$ 封闭</li><li>对偶空间：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a></li></ol></li><li>证明<ol><li>矩阵秩的性质<ol><li>$r&#x3D;\begin{bmatrix}A&amp;0\\0&amp;B\end{bmatrix}&#x3D;r (A)+r (B)$</li><li>$r&#x3D;\begin{bmatrix}A&amp;0\\C&amp;B\end{bmatrix}\ge r (A)+r (B)$</li><li>$r (A)+r (B)-n\le r (AB)\le \min\{r (A), r (B)\}$，其中 $A\in M_{m, n}, B\in M_{n, p}$</li><li>$\max\{r (A), r (B)\}\le r (A|B)\le r (A)+r (B)$</li><li>$r (A+B)\le r (A)+r (B)$</li></ol></li><li>矩阵迹的性质<ol><li>$\mathrm{tr} (AB)&#x3D;\mathrm{tr} (BA), \mathrm{tr} (ABC)&#x3D;\mathrm{tr} (BCA)&#x3D;\mathrm{tr} (CAB)$</li><li>$AB-BA\neq I_n$</li><li>$\displaystyle A&#x3D;\begin{bmatrix} a_1&amp;a_2 \\ a_3&amp;a_4 \end{bmatrix}, B&#x3D;\begin{bmatrix} b_1&amp;b_2 \\ b_3&amp;b_4 \end{bmatrix}, \mathrm{tr} (A^TB)&#x3D;\sum_{i&#x3D;1}^4 a_ib_i$</li><li>$\displaystyle \mathrm{tr} (A^TA)&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^na_{ij}^2$</li><li>$\displaystyle x^TAx&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n a_{ij}x_ix_j&#x3D;\mathrm{tr} (Axx^T)$，反对称阵 $x^TAx&#x3D;0$</li></ol></li></ol></li><li>计算<ol><li>极大线性无关组</li><li>$C (A), N (A), C (A^T), N (A^T)$</li><li>线性方程组的所有解</li><li>满秩分解：$Q_1 AQ_2&#x3D;\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}&#x3D;\begin{bmatrix} I_r \\ 0 \end{bmatrix}*\begin{bmatrix} I_r&amp;0 \end{bmatrix}\Rightarrow A&#x3D;Q_1^{-1}\begin{bmatrix} I_r \\ 0 \end{bmatrix}*\begin{bmatrix} I_r&amp;0 \end{bmatrix} Q_2^{-1}$</li></ol></li><li>例题<ol><li>证明：若 $A&#x3D;\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}, B&#x3D;\begin{bmatrix}I&amp;G\\0&amp;0\end{bmatrix}$ 同型且具有相同的四个子空间，则 $F&#x3D;G$</li><li>证明：若 $A, B$ 为同型矩阵，且 $N (A)&#x3D;N (B)$，$\mathrm{rref} (A)&#x3D;\mathrm{rref} (B)$</li><li>证明：对 $n$ 阶方阵 $A$，<ol><li>$A^2&#x3D;A\Leftrightarrow r (A)+r (I_n-A)&#x3D;n$</li><li>$A^2&#x3D;I_n\Leftrightarrow r (I_n+A)+r (I_n-A)&#x3D;n$</li></ol></li><li>证明：对 $\mathbb R^n$ 中线性无关的向量组 $x_0, x_1,\dots ,x_t$，存在满足如下条件的非齐次线性方程组：$x_0, x_1,\dots ,x_t$ 都是该方程组的解且任意解都能被 $x_0, x_1,\dots ,x_t$ 线性表示</li><li>证明：若 $S:\alpha_1,\dots ,\alpha_r$ 线性无关，且可被 $T:\beta_1,\dots ,\beta_t$ 线性表示，可以选择 $T$ 中的 $r$ 个向量换成 $S$，得到的新的向量组与 $T$ 线性等价</li></ol></li></ol><h2 id="四、内积空间"><a href="#四、内积空间" class="headerlink" title="四、内积空间"></a>四、内积空间</h2><ol><li>内积<ol><li>定义：非负性、线性、对称性</li><li>性质：勾股定理、$\mathrm{Cauchy-Schwarz}$ 不等式</li></ol></li><li>证明<ol><li>$N (A)\oplus C (A^T)&#x3D;\mathbb R^n, N (A^T)\oplus C (A)&#x3D;\mathbb R^m$</li><li>$\mathrm{dim} (U+V)+\mathrm{dim} (U\cap V)&#x3D;\mathrm{dim}U+\mathrm{dim}V$</li><li>$A\in M_{n, r}(\mathbb R)$，则 $A^TA$ 可逆 $\Leftrightarrow r (A)&#x3D;r$，即 $N(A^TA)&#x3D;N(A)$</li><li>$P$ 是正交投影矩阵 $\Leftrightarrow P^2&#x3D;P, P^T&#x3D;P\Leftrightarrow P&#x3D;\mathbb P_{C (P)}$</li><li>$A: C (A^T)\to C (A)$ 是双射；$A^T: C (A)\to C (A^T)$ 是双射</li><li>$Q$ 是正交矩阵 $\Leftrightarrow Q^TQ&#x3D;I_n\Leftrightarrow Q^T$ 是正交矩阵，$Q_1, Q_2$ 正交 $\Rightarrow Q_1 Q_2$ 正交</li><li>$Q$ 是正交矩阵 $\Leftrightarrow Qx\cdot Qy&#x3D;x\cdot y\Leftrightarrow |Qx|&#x3D;|x|$（保距、保角度）</li><li>直线投影：$\mathbb P&#x3D;\frac{uu^T}{|u|^2}$，关于法线对称变换：$I-2\mathbb P$，关于直线对称变换：$2\mathbb P-I$</li><li>$QR$ 分解的唯一性 $\Rightarrow A$ 是正交阵且是对角线为正的上三角阵则 $A&#x3D;I_n$</li></ol></li><li>计算<ol><li>$U+V, U\cap V$</li><li>正交投影矩阵</li><li>最小二乘法</li><li>$N (A), C (A^T)$ 分解</li><li>$\mathrm{Gram-Schmidt}$ 正交化</li><li>$QR$ 分解</li></ol></li><li>投影和 $QR$ 的推广<ol><li>投影矩阵：$P^2&#x3D;P$</li><li>$A\in M_{m, n}(\mathbb R), r (M)\lt n\le m$ 的 $QR$ 分解<ol><li>$A&#x3D;BC, B$ 可逆，$C$ 为行简化阶梯矩阵，记 $C&#x3D;\begin{bmatrix} C_1 \\ 0 \end{bmatrix}, C_1$ 对角非负上三角</li><li>对 $B$ 使用 $QR$ 分解，$B&#x3D;QR_B&#x3D;\begin{bmatrix} Q_{1}&amp;Q_{2} \end{bmatrix}*\begin{bmatrix} R_{11}&amp;R_{12} \\ 0&amp;R_{22} \end{bmatrix}, R_{11}, R_{22}$ 上三角</li><li>$A&#x3D;\begin{bmatrix} Q_{1}&amp;Q_{2} \end{bmatrix}\cdot \begin{bmatrix} R_{11}C_1 \\ 0 \end{bmatrix}&#x3D;Q_1\cdot R_{11}C_1$，$Q_1$ 列正交，$R_{11}C_1$ 对角非负上三角</li><li>推广的 $QR$ 分解不唯一</li></ol></li></ol></li><li>例题<ol><li>证明：若 $A, B$ 是正交投影矩阵，则 $A+B$ 是正交投影矩阵 $\Leftrightarrow C (A), C (B)$ 正交</li><li>证明：$n$ 阶方阵 $P$ 是关于 $A$ 的正交投影矩阵 $\Leftrightarrow \forall x\in \mathbb R^n, Px\in C (A), x-Px\in N (A^T)$</li><li>证明：若可逆矩阵 $A$ 对应的线性变换保持向量之间的角度不变，则<ol><li>对 $A$ 进行 $QR$ 分解，则 $R$ 也保持向量之间的角度不变</li><li>$R$ 为对角矩阵</li><li>$R&#x3D;kI_n$，则 $A$ 为正交矩阵的常数倍</li></ol></li><li>证明：反对称矩阵的秩是偶数</li><li>证明：若 $A\in M_n (\mathbb R)$ 可逆且反对称，$b\in \mathbb R^n$，则<ol><li>$r (A+bb^T)&#x3D;n$</li><li>$r \begin{pmatrix} A&amp;b \\ b^T&amp;0 \end{pmatrix}&#x3D;n$</li></ol></li><li>$(2024)$ 证明：若 $\mathbb R^n$ 中的向量 $\alpha_1,\alpha_2,\alpha_3,\alpha_4$ 满足两两之间的标准内积 $a_i^Ta_j&lt;0$，则 $\alpha_1,\alpha_2,\alpha_3,\alpha_4$ 中任意三个向量线性无关</li></ol></li></ol><h2 id="五、行列式"><a href="#五、行列式" class="headerlink" title="五、行列式"></a>五、行列式</h2><ol><li>计算<ol><li>高斯消元</li><li>分块矩阵<ol><li>$\mathrm{det}\begin{pmatrix} A&amp;B \\ C&amp;D \end{pmatrix}&#x3D;\mathrm{det}A*\mathrm{det} (D-CA^{-1}B)$</li><li>$\mathrm{det}\begin{pmatrix} A&amp;B \\ B&amp;A \end{pmatrix}&#x3D;\mathrm{det}(A+B)*\mathrm{det} (A-B)$</li><li>$AB&#x3D;BA\Rightarrow \mathrm{det}\begin{pmatrix} A&amp;B \\ -B&amp;A \end{pmatrix}&#x3D;\mathrm{det}(A^2+B^2)$</li></ol></li><li>$\mathrm{Leibnitz}$ 展开</li><li>$\mathrm{Laplace}$ 展开</li></ol></li><li>应用<ol><li>$\mathrm{Vandemonde}$ 行列式：若 $v_{ij}&#x3D;a_j^{i-1}$，则 $\displaystyle \mathrm{det}V&#x3D;\prod_{1\le i\lt j\le n}(a_i-a_j)$</li><li>$\mathrm{Cauchy}$ 行列式：若 $c_{ij}&#x3D;\frac{1}{x_i+y_j}$，则 $\displaystyle \mathrm{det}C&#x3D;\frac{\prod_{1\le i\lt j\le n}(x_i-x_j)(y_i-y_j)}{\prod_{1\le i, j\lt n}(x_i+y_j)}$</li><li>$\mathrm{Cramer}$ 法则：$\displaystyle x_i&#x3D;\frac{\mathrm{det} (A_1,\dots, A_{i-1}, b, A_{i+1},\dots ,A_n)}{\mathrm{det}A}$</li><li>伴随矩阵：$\displaystyle A^{-1}&#x3D;\frac{A^*}{\mathrm{det}A}, A^*&#x3D;((A_{ij})_{n\times n})^T$</li><li>摄动法<ol><li>$(A^*)^{-1}&#x3D;(A^{-1})^*,(A^T)^*&#x3D;(A^*)^T$</li><li>$A$ 不可逆时，$EA&#x3D;U, U+\epsilon I_n$ 可逆，则 $A_\epsilon&#x3D;E^{-1}(U+\epsilon I_n)&#x3D;A+\epsilon E^{-1}$ 可逆</li></ol></li><li>$\mathrm{det} (I_n+AB)&#x3D;\mathrm{det} (I_m+BA)$</li><li>$\mathrm{Binet-Cauchy}$ 定理：$A&#x3D;(a_{ij})_{m\times n},B&#x3D;(b_{ij})_{n\times m},n\ge m$，则 $\det(AB)&#x3D;\sum A_iB_i$</li></ol></li><li>例题<ol><li>证明：若 $A$ 对角占优且对角线元素为正，则 $\mathrm{det}A\gt 0$</li><li>证明：若 $A$ 不可逆，则其伴随矩阵的秩为 $0$ 或 $1$</li><li>证明：若 $A&#x3D;[t_1,\dots ,t_n]$，则 $|\mathrm{det}T|\le||t_1||\dots ||t_n||$</li><li>证明：若 $A$ 可逆且元素为整数，则 $A^{-1}$ 元素为整数 $\Leftrightarrow |\mathrm{det}A|&#x3D;1$</li><li>利用摄动法证明：<ol><li>给定 $A, B\in M_n (\mathbb R)$，则 $\forall \epsilon_0\gt 0,\exists C, s.t. \forall \epsilon\in (0,\epsilon_0),|\mathrm{det} (A+\epsilon B)-\mathrm{det}A|\le C\epsilon$</li><li>记 $A$ 的伴随矩阵为 $A^*$，则 $\displaystyle \lim_{\epsilon\to 0}||(A_\epsilon)^*-A^*||_2&#x3D;0$</li></ol></li></ol></li></ol><h2 id="六、特征值"><a href="#六、特征值" class="headerlink" title="六、特征值"></a>六、特征值</h2><ol><li>特征值<ol><li>$\displaystyle P_A (\lambda)&#x3D;\sum_{k&#x3D;0}^n (-1)^{n-k}S_{n-k}\lambda^{k}$，其中 $S_k$ 是 $A$ 的全体 $k$ 阶主子式的和</li><li>$\displaystyle S_{k}&#x3D;\sum_{1\le i_1\lt \dots \lt i_k\le n}\lambda_{i_1}\dots \lambda_{i_k}, k&#x3D;1\Rightarrow \sum_{i&#x3D;1}^n\lambda_i&#x3D;\mathrm{tr}A, k&#x3D;n\Rightarrow \prod_{i&#x3D;1}^n\lambda_i&#x3D;\mathrm{det}A$</li><li>圆盘定理：$\displaystyle \exists i,|\lambda-a_{ii}|\le\sum_{j\neq i}|a_{ij}|$（对角占优）</li><li>同时对角化 $\Leftrightarrow$ $AB&#x3D;BA$</li></ol></li><li>实对称矩阵<ol><li>实对称矩阵的特征值为实数，实反对称矩阵的特征值为纯虚数或零</li><li>$\displaystyle \lambda_1&#x3D;\max_{x\neq 0}\frac{x^TAx}{x^Tx},\lambda_i&#x3D;\max_{x\notin span\{q_1,\dots ,q_{i-1}\}}\frac{x^TAx}{x^Tx}&#x3D;\min_{x\notin\{q_{i+1},\dots ,q_n\}}\frac{x^TAx}{x^Tx},\lambda_n&#x3D;\min_{x\neq 0}\frac{x^TAx}{x^Tx}$</li><li>$A$ 正定 $\Leftrightarrow$ $P^TAP$ 正定 $\Leftrightarrow A$ 的特征值为正数 $\Leftrightarrow A&#x3D;C^TC\Leftrightarrow A&#x3D;LDL^T$，$D$ 对角为正 $\Leftrightarrow A$ 的各阶顺序主子式为正 $\Leftrightarrow A$ 的所有各阶主子式为正</li><li>$A$ 半正定 $\Leftrightarrow A$ 的特征值非负 $\Leftrightarrow A&#x3D;C^TC\Leftrightarrow A&#x3D;LDL^T$，$D$ 对角非负 $\Leftrightarrow A$ 的各阶主子式非负（注意：各阶顺序主子式非负 $\neq$ 半正定）</li><li>$A$ 负定 $\Leftrightarrow A$ 的各阶顺序主子式负正相间</li><li>实对称矩阵 $A$ 的合同标准形唯一存在 $\begin{bmatrix} I_P&amp; &amp;  \\  &amp;-I_{r-p}&amp; \\ &amp; &amp;0 \end{bmatrix}$，对应正、负、零特征值</li><li>步骤：对 $A$ 作行变换，再对 $\begin{bmatrix} A \\ I \end{bmatrix}$ 作相同的初等列变换，则 $I$ 转变为 $P$</li></ol></li><li>相似对角化的推广：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a><ol><li>$\mathrm{Schur}$ 分解（上三角化）</li><li>$\mathrm{Hamilton-Cayley}$ 定理</li><li>广义特征空间</li><li>$\mathrm{Jordan}$ 标准形</li></ol></li><li>例题<ol><li>若 $A&#x3D;X\Lambda X^{-1}$，求 $\begin{bmatrix} O&amp;A \\ A&amp;O \end{bmatrix}$ 的相似对角化</li><li>$(2023)$ 已知三阶方阵 $A$ 满足 $A^2-2 A-3 I&#x3D;O$，求 $\mathrm{det} (A+2 I)$ 的所有可能取值</li><li>证明：若 $A\in M_n (\mathbb R)$ 反对称，则 $I-A^2$ 正定</li><li>证明：若复矩阵 $A, B$ 可交换，则 $A, B$ 至少有一个公共的特征向量</li><li>证明：若 $A^2&#x3D;A$，则 $A$ 可对角化</li><li>证明：对 $m$ 阶方阵 $A_1$，$n$ 阶矩阵 $A_2$ 和 $m\times n$ 阶矩阵 $B$，若 $A_1, A_2$ 没有相同的特征值，则关于 $m\times n$ 矩阵 $X$ 的矩阵方程 $A_1 X-XA_2&#x3D;B$ 有唯一解</li><li>证明：若 $AB&#x3D;BA$，且 $A$ 有 $n$ 个不同的特征值，则存在不超过 $n-1$ 次的多项式 $f (x), s.t. B&#x3D;f (A)$</li><li>$(2023)$ 证明：若 $A\in M_n (\mathbb R)$ 对称，则 $A$ 至少有 $k$ 个计重数的特征值 $\Leftrightarrow$ 存在 $k$ 维子空间 $V$ 使得对于任意非零向量 $v\in V, v^TAv\gt 0$</li><li>证明：任意迹为 $0$ 的方阵相似于一个对角元素全为 $0$ 的方阵</li><li>证明：若 $A_1,\dots ,A_m$ 是 $m$ 个两两可交换的实对称阵，则它们可同时正交对角化</li><li>证明：若 $A, B$ 满足以下条件，则存在可逆阵 $T$，$T^TAT, T^TBT$ 为对角阵<ol><li>$A$ 正定，$B$ 实对称</li><li>$A, B$ 半正定</li></ol></li><li>证明：给定 $n$ 阶正定矩阵 $A$，则<ol><li>对任意 $y$，$\mathrm{det}\begin{pmatrix} A&amp;y \\ y^T&amp;0 \end{pmatrix}\le 0$</li><li>$\mathrm{det}A\le a_{nn}\mathrm{det} (A_{n-1})$，其中 $A_{n-1}$ 是 $A$ 的顺序主子阵</li><li>$\mathrm{det} (A)\le a_{11}a_{22}\dots a_{nn}$</li><li>对任意实可逆阵 $T$，$\displaystyle (\mathrm{det}T)^2\le \prod_{i&#x3D;1}^n (t_{1 i}^2+t_{2 i}^2+\dots +t_{ni}^2)$</li></ol></li></ol></li></ol><h2 id="七、奇异值分解"><a href="#七、奇异值分解" class="headerlink" title="七、奇异值分解"></a>七、奇异值分解</h2><ol><li>奇异值分解<ol><li>$A^TA$ 与 $AA^T$ 有相同的特征值</li><li>$A: V_\lambda (A^TA)\to V_\lambda (AA^T)$ 是双射</li><li>$A^T: V_\lambda (AA^T)\to V_\lambda (A^TA)$ 是双射</li><li>$\xi_1,\dots ,\xi_s$ 是 $V_\lambda (A^TA)$ 的标准正交基 $\Rightarrow \frac{A\xi_1}{\sqrt{\lambda}},\dots ,\frac{A\xi_s}{\sqrt{\lambda}}$ 是 $V_\lambda (AA^T)$ 的标准正交基</li><li>$\displaystyle A&#x3D;U\Sigma V^T\Rightarrow A^TA&#x3D;V\Lambda V^T, AA^T&#x3D;U\Lambda U^T, A&#x3D;\sum_{i&#x3D;1}^r\sigma_iu_iv_i^T$</li><li>$(u_1,\dots ,u_r) (v_1,\dots ,v_r),(u_{r+1},\dots ,u_m), (v_{r+1},\dots, v_n)$ 分别是 $C (A), C(A^T), N(A^T), N(A)$ 的标准正交基</li><li>步骤：$A^TA$ 的对角化得出 $V,\Sigma\Rightarrow$ 得出 $(u_1,\dots ,u_r)\Rightarrow$ $N (A^T)$ 的标准正交基</li></ol></li><li>应用<ol><li>极分解：$A&#x3D;U\Sigma V^T&#x3D;UV^T*V\Sigma V^T&#x3D;QS$，$Q$ 为正交阵，$S$ 为半正定矩阵</li><li>伪逆<ol><li>定义：$AA^+A&#x3D;A, A^+AA^+&#x3D;A^+, (AA^+)^T&#x3D;AA^+, (A^+A)^T&#x3D;A^+A$</li><li>性质：唯一性；$A^+&#x3D;A^{-1}$；$(A^+)^T&#x3D;(A^T)^+$</li><li>$A\in M_{m, n}, r (A)&#x3D;n\Rightarrow A^+&#x3D;(A^TA)^{-1}A^T; r (A)&#x3D;m\Rightarrow A^+&#x3D;A^T (AA^T)^{-1}$</li><li>$\mathbb P_{C (A)}&#x3D;AA^+,\mathbb P_{C (A^T)}&#x3D;A^+A$</li><li>$T: C (A^T)\to C (A), T (x)&#x3D;Ax, T^{-1}&#x3D;A^+$</li><li>求解：$A&#x3D;U\Sigma V^T\Rightarrow A^+&#x3D;V\Sigma^+U^T$</li></ol></li></ol></li><li>谱范数<ol><li>定义：$\displaystyle ||A||&#x3D;\sup_{x\in \mathbb R^n}\frac{|Ax|}{|x|}&#x3D;\sigma_1$，其中 $\sigma_1$ 是 $A$ 最大的特征值</li><li>性质：$||A+B||\le ||A||+||B||,||AB||\le ||A||||B||,||kA||&#x3D;|k|||A||,||A||&#x3D;0\Leftrightarrow A&#x3D;0$</li><li>$U, V$ 正交 $\Rightarrow ||UAV^T||&#x3D;||A||$</li><li>$|\lambda|\gt||A||\Rightarrow \lambda I-A$ 可逆 $\Leftrightarrow A$ 的特征值在 $[-||A||,||A||]$ 里</li><li>低秩逼近：$\displaystyle \min_{r (B)&#x3D;k}||A-B||&#x3D;\sigma_{k+1}, B&#x3D;\sum_{i&#x3D;1}^k\sigma_iu_iv_i^T$</li><li>正交逼近：$\displaystyle A&#x3D;U\Sigma V^T\Rightarrow \min_{B正交}||A-B||&#x3D;||A-UV^T||$</li></ol></li><li>$\mathrm{Frobenius}$ 范数<ol><li>定义：$\displaystyle||A||_F&#x3D;\sqrt{\mathrm{tr} (A^TA)}&#x3D;\sqrt{\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^na_{ij}^2}&#x3D;\sqrt{\sum_{i&#x3D;1}^r\sigma_i^2}$</li><li>性质：$||A||_F&#x3D;0\Leftrightarrow A&#x3D;0,||kA||_F&#x3D;|k|||A||_F,||A+B||_F\le ||A||_F+||B||_F$</li><li>$U, V$ 正交 $\Rightarrow ||UAV^T||_F&#x3D;||A||_F$</li><li>$||AB||_F\le ||A||_F||B||,||AB||_F\le ||A||||B||_F$</li><li>低秩逼近：$\displaystyle \min_{r (B)\le k}||A-B||_F^2&#x3D;\sum_{i&#x3D;k+1}^r\sigma_i^2, B&#x3D;\sum_{i&#x3D;1}^k\sigma_iu_iv_i^T$</li><li>$\displaystyle A&#x3D;\sum_{i&#x3D;1}^r\sigma_iu_iv_i^T$，则 $\displaystyle \max_{r (Q)\le k, Q 列正交}\mathrm{tr} (Q^TAA^TQ)&#x3D;\sum_{i&#x3D;1}^k\sigma_i^2, Q&#x3D;[u_1,\dots ,u_k]$</li></ol></li><li>例题<ol><li>若 $A&#x3D;U\Sigma V^T$，求 $\begin{bmatrix} O&amp;A^T \ A&amp;O \end{bmatrix}$ 的相似对角化</li><li>证明：若对称阵 $A\in M_n (\mathbb R)$ 有特征值 $\lambda_1\ge \dots \ge \lambda_n$，对应特征向量 $u_1,\dots ,u_n$，则 $\displaystyle \forall m\lt n,\max_{Q\in M_{m, n}(\mathbb R), Q列正交}\mathrm{tr} (Q^TAQ)&#x3D;\sum_{i&#x3D;1}^m\lambda_i$，且 $Q&#x3D;[u_1,\dots ,u_m]$ 时最大</li></ol></li></ol><h2 id="八、线性变换"><a href="#八、线性变换" class="headerlink" title="八、线性变换"></a>八、线性变换</h2><ol><li>证明<ol><li>同构：线性双射，且 $\mathrm{dim} U&#x3D;\mathrm{dim} V&#x3D;n\Rightarrow U\approx V\approx \mathbb F^n$</li><li>相似：线性变换 $T: V\to V$ 在不同基底下的表示矩阵</li><li>相抵：线性变换 $T: V_1\to V_2$ 在不同基底下的表示矩阵</li><li>合同：二次型 $T: V\times V\to \mathbb R$ 在不同基底下的对称阵表示</li></ol></li><li>计算<ol><li>线性变换的表示矩阵</li><li>线性变换的值域与核</li><li>线性变换的特征值、特征向量</li><li>线性变换的相似对角化：$T\alpha&#x3D;\alpha A, AP&#x3D;P\Lambda$，令 $\eta&#x3D;\alpha P\Rightarrow T\eta&#x3D;\eta\Lambda$</li><li>线性变换的相抵标准形：$T\alpha&#x3D;\beta A,P_2 AP_1&#x3D;\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}$ ，令 $\eta&#x3D;\alpha P_1,\gamma&#x3D;\beta P_2^{-1}, T\eta&#x3D;\gamma\begin{bmatrix} I_r&amp;0 \\ 0&amp;0 \end{bmatrix}$</li><li>过渡矩阵：$\begin{bmatrix} A&amp;B \end{bmatrix}$ 高斯消元得 $\begin{bmatrix} I_r&amp;C \\ 0&amp;0 \end{bmatrix}$，则 $P&#x3D;C$（$A$ 可逆时 $P&#x3D;C&#x3D;A^{-1}B$）</li></ol></li><li>相似对角化的推广：详见<a href="https://sqzr2319.github.io/LinearAlgebra-2">线性代数(2)</a><ol><li>线性变换的 $\mathrm{Jordan}$ 化</li><li>线性变换的 $\mathrm{Hamilton-Cayley}$ 定理</li></ol></li><li>例题<ol><li>证明：设 $V$ 是 $n$ 维线性空间，$f$ 是其上的线性变换，且存在向量 $a\in V, s.t. f^{n-1}(a)\neq 0, f^n (a)&#x3D;0$，则 $V$ 存在一组基，使得 $f$ 在该组基下的矩阵 $J_n&#x3D;\begin{bmatrix} 0&amp;1&amp; &amp;  \\  &amp;\ddots&amp;\ddots&amp; \\  &amp; &amp;0&amp;1\\ &amp; &amp; &amp;0 \end{bmatrix}$</li></ol></li></ol><h2 id="九、空间解析几何"><a href="#九、空间解析几何" class="headerlink" title="九、空间解析几何"></a>九、空间解析几何</h2><ol><li>叉积与混合积：$x\times y&#x3D;\mathrm{det}\begin{pmatrix} e_1&amp;e_2&amp;e_3  \\  x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \end{pmatrix},(x\times y)*z&#x3D;\mathrm{det}\begin{pmatrix} z_1&amp;z_2&amp;z_3  \\  x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \end{pmatrix}$</li><li>直线与平面<ol><li>$x, y, z$ 共面 $\Leftrightarrow \mathrm{det}\begin{pmatrix} x_1&amp;x_2&amp;x_3 \\ y_1&amp;y_2&amp;y_3 \\ z_1&amp;z_2&amp;z_3 \end{pmatrix}&#x3D;0$</li><li>平面的参数方程：$\begin{cases} x&#x3D;x_0+t_1 x_1+t_2 x_2 \\ y&#x3D;y_0+t_1 y_1+t_2 y_2\\ z&#x3D;z_0+t_1 z_1+t_2 z_2 \end{cases}$</li><li>平面的一般方程：$\mathrm{det}\begin{pmatrix} x-x_0&amp;y-y_0&amp;z-z_0 \\ x_1&amp;y_1&amp;z_1 \\ x_2&amp;y_2&amp;z_2 \end{pmatrix}&#x3D;0\Rightarrow Ax+By+Cz+D&#x3D;0$</li><li>平面与平面的位置关系：相交 &#x2F; 平行 &#x2F; 重合</li><li>直线的参数方程：$\begin{cases} x&#x3D;x_0+tX \\ y&#x3D;y_0+tY\\ z&#x3D;z_0+tZ \end{cases}$，消去参数化为标准方程</li><li>直线的标准方程：$\displaystyle \frac{x-x_0}{X}&#x3D;\frac{y-y_0}{Y}&#x3D;\frac{z-z_0}{Z}$，展开化为一般方程</li><li>直线的一般方程：$\begin{cases} A_1 x+B_1 y+C_1 z+D_1&#x3D;0 \\ A_2 x+B_2 y+C_2 z+D_2&#x3D;0 \end{cases}$，取点化为标准方程</li><li>直线与直线的位置关系：异面 &#x2F; 相交 &#x2F; 平行 &#x2F; 重合</li><li>直线与平面的位置关系：$(AX+BY+CZ) t+Ax_0+By_0+Cz_0+D&#x3D;0$ 解的个数</li><li>点到平面的距离：$\displaystyle d&#x3D;\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}$</li><li>点到直线的距离：$\displaystyle d&#x3D;\frac{|AB\times v|}{|v|}$</li><li>异面直线的距离：$\displaystyle d&#x3D;\frac{|(v_1\times v_2)*P_1 P_2|}{|v_1\times v_2|}$</li></ol></li><li>曲面与二次曲面<ol><li>二次型的化简：$A&#x3D;P^TBP$，令 $x&#x3D;Py$，则 $x^TAx&#x3D;y^TBy$</li><li>球面方程：$x^2+y^2+z^2+ax+by+cz+d&#x3D;0$</li><li>柱面方程：$f (x, y)&#x3D;0$ 或 $f (x, z)&#x3D;0$ 或 $f (y, z)&#x3D;0$</li><li>旋转面方程：$f (x,\sqrt{y^2+z^2})&#x3D;0$ 或 $f (y,\sqrt{x^2+z^2})&#x3D;0$ 或 $f (z, \sqrt{x^2+y^2})&#x3D;0$</li><li>空间曲线的方程：两个曲面的交线 $\begin{cases} f(x, y, z)&#x3D;0 \\ g(x, y, z)&#x3D;0 \end{cases}$</li><li>椭球面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}&#x3D;1$</li><li>单叶双曲面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}&#x3D;1$</li><li>双叶双曲面：$\displaystyle \frac{z^2}{c^2}-\frac{x^2}{a^2}-\frac{y^2}{b^2}&#x3D;1$</li><li>锥面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}&#x3D;0$</li><li>椭圆抛物面：$\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}&#x3D;z$</li><li>双曲抛物面：$\displaystyle \frac{x^2}{a^2}-\frac{y^2}{b^2}&#x3D;z$</li></ol></li><li>例题<ol><li>在直角坐标系中，已知平面 $\pi$ 过点 $(1,1,0), (0,0,1), (0,1,1)$，求与平面 $\pi$ 垂直且过点 $(1,1,1)$ 的直线的标准方程</li><li>求 $x_1^2+x_2^2+x_3^2+4 x_1 x_2+4 x_1 x_3-4 x_2 x_3&#x3D;1$ 表示的二次曲面类型</li><li>求过点 $(3,2,1)$ 与直线 $\displaystyle \frac{x}{3}&#x3D;\frac{y}{0}&#x3D;z$ 平行且与平面 $x-y+z+1&#x3D;0$ 垂直的平面方程</li><li>求实二次型 $f (x_1, x_2, x_3)&#x3D;x_1^2+x_2^2-x_3^2-2 x_1 x_3$ 的规范形</li><li>设三元二次型 $f (x_1, x_2, x_3)&#x3D;x_1^2+\frac{1}{2}x_2^2+ax_3^2-x_2 x_3$ 的秩为 $2$<ol><li>求参数 $a$</li><li>求正交阵 $Q$，作正交替换 $X&#x3D;QY$，化二次型 $f (x_1, x_2, x_3)$ 为标准形</li><li>指出 $f (x_1, x_2, x_3)$ 表示何种二次曲面</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学(1)</title>
    <link href="/24Fall/DiscreteMath-1/"/>
    <url>/24Fall/DiscreteMath-1/</url>
    
    <content type="html"><![CDATA[<p>大一上学期离散数学(1)的复习笔记，目前已完结。</p><span id="more"></span><h2 id="一、命题逻辑"><a href="#一、命题逻辑" class="headerlink" title="一、命题逻辑"></a>一、命题逻辑</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><ol><li>命题：真值<strong>非真即假或待定</strong>的<strong>陈述句</strong></li><li>合式公式：<strong>有限次</strong>联结，<strong>不包含空公式</strong></li></ol><h3 id="2-命题形式化"><a href="#2-命题形式化" class="headerlink" title="2. 命题形式化"></a>2. 命题形式化</h3><ol><li>注意<strong>异或</strong>和<strong>充要条件</strong>的判断</li></ol><h3 id="3-波兰表达式"><a href="#3-波兰表达式" class="headerlink" title="3. 波兰表达式"></a>3. 波兰表达式</h3><ol><li>中缀表示的扫描：发现第一个右括号 $\to$  返回最近的左括号 $\to$  向右继续扫描</li><li>中缀式 $\Rightarrow$ 波兰式：根据优先级加括号 $\to$  从内层括号逐步向外层脱开</li><li>波兰式 $\Rightarrow$ 中缀式：压栈</li><li>$\neg A$ 的前缀为 $\neg A$，后缀为 $A\neg$</li></ol><h3 id="4-等值公式"><a href="#4-等值公式" class="headerlink" title="4. 等值公式"></a>4. 等值公式</h3><ol><li>蕴含<strong>没有结合律、交换律</strong></li><li>双蕴含<strong>没有分配律</strong></li><li>前提合取合并：$P\to (Q\to R)&#x3D;(P\wedge Q)\to R$ </li><li>前提析取合并：$(P\to R)\wedge (Q\to R)&#x3D;(P\vee Q)\to R$ </li><li>前提交换：$P\to (Q\to R)&#x3D;Q\to (P\to R)$ </li><li>从 $T$ 行写双蕴含：$P\leftrightarrow Q&#x3D;(P\wedge Q)\vee (\neg P\wedge \neg Q)$ </li><li>从 $F$ 行写双蕴含：$P\leftrightarrow Q&#x3D;(P\vee \neg Q)\wedge (\neg P\vee Q)$ </li><li>归谬论：$(P\to Q)\wedge (P\to \neg Q)&#x3D;\neg P$ </li><li>代入规则：只能对<strong>重言式</strong>中的<strong>原子命题</strong>使用，且必须<strong>全部代换</strong></li><li>置换规则：只需等值</li></ol><h3 id="5-真值表"><a href="#5-真值表" class="headerlink" title="5. 真值表"></a>5. 真值表</h3><ol><li>从 $T$ 行写：一个个情况累加，$1&#x3D;T, 0&#x3D;F$，用极小项构成主析取范式</li><li>从 $F$ 行写：一个个情况排除，$1&#x3D;F, 0&#x3D;T$，用极大项构成主合取范式</li></ol><h3 id="6-真值函项"><a href="#6-真值函项" class="headerlink" title="6. 真值函项"></a>6. 真值函项</h3><ol><li>对 $n$ 个命题变元，每个变元有 $m$ 种取值：可定义 $m^{m^n}$ 个 $n$ 元联结词</li></ol><h3 id="7-完备集"><a href="#7-完备集" class="headerlink" title="7. 完备集"></a>7. 完备集</h3><ol><li>$\{\neg ,\wedge ,\vee\},\{\neg,\wedge \},\{\neg,\vee\},\{\neg,\to\},\{\uparrow\},\{\downarrow\}$</li></ol><h3 id="8-对偶式"><a href="#8-对偶式" class="headerlink" title="8. 对偶式"></a>8. 对偶式</h3><ol><li>$A^*$：将 $A$ 中出现的 $\wedge ,\vee ,T, F$ 分别用 $\vee, \wedge ,F, T$ 代换</li><li>$A^-$：将 $A$ 中的命题变项分别用各自的互补对代换</li><li>$\neg A&#x3D;A^{*-}$</li></ol><h3 id="9-范式"><a href="#9-范式" class="headerlink" title="9. 范式"></a>9. 范式</h3><ol><li>步骤：消去蕴含 $\to$ 将否定内移到命题变项上 $\to$ 利用分配律或<strong>利用真值表</strong><ol><li>$A\wedge (B\vee C)&#x3D;(A\wedge B)\vee (A\wedge C)$ 多用于求析取范式</li><li>$A\vee (B\wedge C)&#x3D;(A\vee B)\wedge (A\vee C)$ 多用于求合取范式</li></ol></li><li>快速填满变项：$\neg P\vee Q&#x3D;m^{0 x}\vee m^{x 1}&#x3D;\bigvee_{0,1,3}$ </li><li>极大项与极小项的关系：$\neg m_2&#x3D;M_5,\neg M_2&#x3D;m_5$ </li><li>否定：$A&#x3D;\bigvee_{0,1,3}\Leftrightarrow \neg A&#x3D;\bigvee_{2,4,5,6,7}, B&#x3D;\bigwedge_{0,1,3}\Leftrightarrow \neg B&#x3D;\bigwedge_{2,4,5,6,7}$ </li><li>主合取范式与主析取范式的转换：$\bigvee_{0,1,3}&#x3D;\neg \neg \bigvee_{0,1,3}&#x3D;\neg \bigwedge_{4,6,7}&#x3D;\bigwedge_{0,1,2,3,5}$ </li><li>永真式的主合取范式、矛盾式的主析取范式为空公式</li></ol><h3 id="10-推理公式"><a href="#10-推理公式" class="headerlink" title="10. 推理公式"></a>10. 推理公式</h3><ol><li>$P\wedge Q\Rightarrow P\Rightarrow P\vee Q$ </li><li>假言推理： $P\wedge (P\to Q)\Rightarrow Q$ </li><li>三段论：$(P\to Q)\wedge (Q\to R)\Rightarrow P\to R$</li></ol><h3 id="11-推理演算"><a href="#11-推理演算" class="headerlink" title="11. 推理演算"></a>11. 推理演算</h3><ol><li>注意附加前提引入</li></ol><h3 id="12-归结推理"><a href="#12-归结推理" class="headerlink" title="12. 归结推理"></a>12. 归结推理</h3><ol><li>证明 $A\Rightarrow B$ 步骤：将 $A,\neg B$ 分别化为合取范式，建立子句集，归结出矛盾</li><li><strong>半完备性</strong>：对真命题能够归结出空子句，对假命题得不到任何结论</li></ol><h3 id="13-公理系统"><a href="#13-公理系统" class="headerlink" title="13. 公理系统"></a>13. 公理系统</h3><ol><li>公理<ol><li>$(P\vee P)\to P$ </li><li>$P\to (P\vee Q)$</li><li>$(P\vee Q)\to (Q\vee P)$ </li><li>$(Q\to R)\to ((P\vee Q)\to (P\vee R))$ </li><li>$\to,\wedge,\leftrightarrow$ 的定义</li><li>代入、置换、分离规则</li><li>演绎定理：若 $A$ 推出 $B$ 过程中不使用代入规则，则 $A\to B$ 成立</li></ol></li><li>定理<ol><li>$(Q\to R)\to ((P\to Q)\to (P\to R))$ </li><li>$P\to P$ </li><li>$\neg P\vee P$ </li><li>$P\vee \neg P$ </li><li>$P\to \neg \neg P$ </li><li>$\neg \neg P\to P$ </li><li>$(P\to Q)\to (\neg Q\to \neg P)$</li></ol></li><li>例题<ol><li>$(P\vee Q)\to (Q\to (P\vee Q))$ </li><li>$(2022) (\neg Q\to P)\to (\neg P\to Q)$</li></ol></li></ol><h3 id="14-性质"><a href="#14-性质" class="headerlink" title="14. 性质"></a>14. 性质</h3><ol><li>满足完备性：是否所有的定理都可由公理系统推导出来</li><li>满足可靠性：非重言式或不成立的公式是否也可推导出来</li><li>满足可判定性：存在一种机械的方法在有穷步内判定任意公式是否为定理</li></ol><h2 id="二、谓词逻辑"><a href="#二、谓词逻辑" class="headerlink" title="二、谓词逻辑"></a>二、谓词逻辑</h2><h3 id="1-基本定义-1"><a href="#1-基本定义-1" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><ol><li>与命题逻辑的关系<ol><li>谓词逻辑 $&#x3D;$ 命题逻辑 $+$ 个体词 $+$ 谓词 $+$ 量词 $+$ 函数</li><li>$P (x), Q (f(x), y)$ 是<strong>命题形式</strong>，<strong>取定谓词、函数，并量化个体词后化为命题</strong></li><li>一个命题是<strong>没有自由变元的谓词常项</strong></li></ol></li><li>合式公式<ol><li>两个合式公式的连接：<strong>无变元 $x$ 在 $A, B$ 中的一个是约束的而在另一个中是自由的</strong></li><li>$A$ 是合式公式，且 $x$ 在 $A$ 中是<strong>自由</strong>变元，则 $(\forall x) A, (\exists x) A$ 是合式公式</li><li>反例：$(\forall x) F (x)\wedge G (x), (\exists x)(\forall x) F (x), (\forall x) P (y)$</li></ol></li></ol><h3 id="2-自然语句的形式化"><a href="#2-自然语句的形式化" class="headerlink" title="2. 自然语句的形式化"></a>2. 自然语句的形式化</h3><ol><li>注意<strong>唯一性</strong>的表示</li></ol><h3 id="3-有限域下公式的表示法"><a href="#3-有限域下公式的表示法" class="headerlink" title="3. 有限域下公式的表示法"></a>3. 有限域下公式的表示法</h3><ol><li>解释：须取定谓词、函数</li><li>有限域下公式的可满足性和普遍有效性依赖且仅依赖于个体域个体的数目</li><li>在 $k$ 个体域上普遍有效 $\Rightarrow$ 在 $k-1$ 个体域上普遍有效</li><li>在 $k$ 个体域上可满足 $\Rightarrow$ 在 $k+1$ 个体域上可满足</li></ol><h3 id="4-等值公式-1"><a href="#4-等值公式-1" class="headerlink" title="4. 等值公式"></a>4. 等值公式</h3><ol><li>由命题逻辑移植来的等值式</li><li>量词的否定</li><li>量词对无关命题变项的分配律（$\to$ 前件不变后件变）</li><li>量词 $\forall$ 对 $\wedge$、量词 $\exists$ 对 $\vee$ 的分配律</li><li>变元易名</li></ol><h3 id="5-范式"><a href="#5-范式" class="headerlink" title="5. 范式"></a>5. 范式</h3><ol><li>前束范式：消去蕴含 $\to$ 否定符内移 $\to$ 量词左移 $\to$ 变元易名</li><li>$\mathrm{Skolem}$ 标准形：$(\exists x)(\forall y)(\exists z) P (x, y, z)&#x3D;P (a, y, f (y))$ </li><li>前束范式与 $\mathrm{Skolem}$ 标准形在<strong>不可满足</strong>的意义下一致</li></ol><h3 id="6-推理公式"><a href="#6-推理公式" class="headerlink" title="6. 推理公式"></a>6. 推理公式</h3><ol><li>$(\forall x) P (x)\vee (\forall x) Q (x)\Rightarrow (\forall x)(P (x)\vee Q (x))$ </li><li>$(\exists x)(P (x)\wedge Q (x))\Rightarrow (\exists x) P (x)\wedge (\exists x) Q (x)$ </li><li>$(\forall x)(P (x)\to Q (x))\Rightarrow (\forall x)P(x)\to (\forall x)Q(x)$ </li><li>$(\forall x)(P (x)\to Q (x))\Rightarrow (\exists x)P(x)\to (\exists x)Q(x)$ </li><li>$(\forall x)(P (x)\leftrightarrow Q (x))\Rightarrow (\forall x) P (x)\leftrightarrow (\forall x) Q (x)$ </li><li>$(\forall x)(P (x)\leftrightarrow Q (x))\Rightarrow (\exists x) P (x)\leftrightarrow (\exists x) Q (x)$ </li><li>$(\forall x)(P (x)\to Q (x))\wedge (\forall x)(Q (x)\to R (x))\Rightarrow (\forall x)(P (x)\to R (x))$ </li><li>$(\forall x)(P (x)\to Q (x))\wedge P (a)\Rightarrow Q (a)$ </li><li>$(\forall x)(\forall y) P (x, y)\Rightarrow (\exists x)(\forall y) P (x, y)\Rightarrow (\forall y)(\exists x) P (x, y)$</li></ol><h3 id="7-推理演算"><a href="#7-推理演算" class="headerlink" title="7. 推理演算"></a>7. 推理演算</h3><ol><li>$UI$：$(\forall x) P (x)\Rightarrow P (y)$，其中 $y$ 不在 $P (x)$ 中约束出现</li><li>$UG$：$P (y)\Rightarrow (\forall x) P (x)$，其中 $x$ 不在 $P (y)$ 中约束出现</li><li>$EI$：$(\exists x) P (x)\Rightarrow P (c)$，其中 $c$ 不在 $P (x)$ 中出现，<strong>且 $P (x)$ 中无自由变元</strong><ol><li>反例：$(\exists x)(x&gt;y)$ 成立，但 $c&gt;y$ 不成立</li></ol></li><li>$EG$：$P (c)\Rightarrow (\exists x) P (x)$，其中 $x$ 不在 $P (c)$ 中出现</li></ol><h3 id="8-归结推理"><a href="#8-归结推理" class="headerlink" title="8. 归结推理"></a>8. 归结推理</h3><ol><li>步骤：将 $A,\neg B$ 分别化为前束范式，再化为 $\mathrm{Skolem}$ 标准形，建立子句集</li><li>归结方法：$P (x)\vee Q (x)$ 与 $\neg P (a)\vee R (y)$ 归结出 $Q (a)\vee R (y)$</li></ol><h3 id="9-一阶逻辑公理系统"><a href="#9-一阶逻辑公理系统" class="headerlink" title="9. 一阶逻辑公理系统"></a>9. 一阶逻辑公理系统</h3><ol><li>由命题逻辑移植来的公理（演绎定理除外）</li><li>$(\forall x) P (x)\to P (y)$ </li><li>$P (y)\to (\exists x) P (x)$ </li><li>约束变元易名规则</li><li>后件概括规则：若 $A\to B (x)$ 且 $x$ 在 $A$ 中不出现，则 $A\to (\forall x) B (x)$ </li><li>前件存在规则：若 $A (x)\to B$ 且 $x$ 在 $B$ 中不出现，则 $(\exists x) A (x)\to B$ </li><li>演绎定理：不使用代入规则、前件存在和后件概括规则</li></ol><h3 id="10-性质"><a href="#10-性质" class="headerlink" title="10. 性质"></a>10. 性质</h3><ol><li>满足完备性</li><li>满足可靠性</li><li><strong>不满足可判定性</strong>，但有子类是可判定的<ol><li>只含有一元谓词变项的公式是可判定的</li><li>个体域有穷时的谓词公式是可判定的</li><li>$\exists,\forall$ 前束范式的母式中无量词和其他自由变项时是可判定的</li></ol></li></ol><h2 id="三、集合"><a href="#三、集合" class="headerlink" title="三、集合"></a>三、集合</h2><h3 id="1-集合的运算"><a href="#1-集合的运算" class="headerlink" title="1. 集合的运算"></a>1. 集合的运算</h3><ol><li>$A\subseteq B\Leftrightarrow P (A)\subseteq P (B)$</li><li>$A&#x3D;B\Leftrightarrow P (A)&#x3D;P (B)$ </li><li>$P (A)\in P (B)\Rightarrow A\in B$ </li><li>$P (A)\cap P (B)&#x3D;P (A\cap B)$ </li><li>$P (A)\cup P (B)\subseteq P (A\cup B)$</li><li>$P (A-B)\subseteq (P (A)-P (B))\cup \{\emptyset\}$ </li><li>传递集合：$(\forall x)(\forall y)((x\in y\wedge y\in A)\to x\in A)$ <ol><li>等价描述 $1$：传递集合元素的元素都是它的元素</li><li>等价描述 $2$：传递集合的元素都是它的子集</li></ol></li><li>$A$ 是传递集合 $\Leftrightarrow$ $A\subseteq P (A)\Leftrightarrow P(A)$ 是传递集合</li><li>$A\subseteq B\Rightarrow \bigcup A\subseteq \bigcup B$ </li><li>$A\subseteq B\Rightarrow \bigcap B\subseteq \bigcap A$，其中 $A, B$ 非空</li><li>$\bigcup (A\cup B)&#x3D;(\bigcup A)\cup (\bigcup B)$ </li><li>$\bigcap (A\cup B)&#x3D;(\bigcap A)\cap (\bigcap B)$，其中 $A, B$ 非空</li><li>$\bigcup (P (A))&#x3D;A$ </li><li>$A$ 是传递集合 $\Rightarrow$ $\bigcup A$ 是传递集合</li><li>$A$ 的元素都是传递集合 $\Rightarrow$ $\bigcup A$ 是传递集合</li><li>非空集合 $A$ 是传递集合 $\Rightarrow$ $\bigcap A$ 是传递集合，且 $\bigcap A&#x3D;\emptyset$</li><li>非空集合 $A$ 的元素都是传递集合 $\Rightarrow$ $\bigcap A$ 是传递集合</li></ol><h3 id="2-集合论公理系统"><a href="#2-集合论公理系统" class="headerlink" title="2. 集合论公理系统"></a>2. 集合论公理系统</h3><ol><li>外延公理</li><li>空集合存在定理</li><li>无序对集合存在定理</li><li>广义并集合存在定理</li><li>子集公理模式</li><li>幂集合公理</li><li>无穷公理</li><li>替换公理模式</li><li>正则公理：任意非空集合 $S$ 存在元素 $x$ 使得 $S$ 和 $x$ 不相交</li><li>选择公理：对任意关系 $R$ 存在函数 $f$ 使得 $f\subseteq R, dom (f)&#x3D;dom (R)$ <ol><li>等价形式：良序定理、$\mathrm{Zorn}$ 引理、基数的三歧性</li></ol></li></ol><h2 id="四、关系"><a href="#四、关系" class="headerlink" title="四、关系"></a>四、关系</h2><h3 id="1-关系的运算"><a href="#1-关系的运算" class="headerlink" title="1. 关系的运算"></a>1. 关系的运算</h3><ol><li>$R_1\circ (R_2\cup R_3)&#x3D;R_1\circ R_2 \cup R_1\circ R_3$ </li><li>$R_1\circ (R_2\cap R_3)\subseteq R_1\circ R_2\cap R_1\circ R_3$ </li><li>$(R_1\cup R_2)\circ R_3&#x3D;R_1\circ R_3\cup R_2\circ R_3$ </li><li>$(R_1\cap R_2)\circ R_3\subseteq R_1\circ R_3\cap R_2\circ R_3$ </li><li>$R[A\cup B]&#x3D;R[A]\cup R[B]$ </li><li>$R[\bigcup A]&#x3D;\bigcup\{R[B]|B\in A\}$ </li><li>$R[A\cap B]\subseteq R[A]\cap R[B]$ </li><li>$R[\bigcap A]\subseteq \bigcap\{R[B]|B\in A\}$，其中 $A$ 非空</li><li>$R[A]-R[B]\subseteq R[A-B]$ </li><li>$R\uparrow(A\cup B)&#x3D;R\uparrow A\cup R\uparrow B$ </li><li>$R\uparrow (A\cap B)&#x3D;R\uparrow A\cap R\uparrow B$</li></ol><h3 id="2-关系的性质"><a href="#2-关系的性质" class="headerlink" title="2. 关系的性质"></a>2. 关系的性质</h3><ol><li>自反：$I_A\subseteq R, r (R)&#x3D;R\cup I_A$  </li><li>反自反：$R\cap I_A&#x3D;\emptyset$ </li><li>对称：$R&#x3D;R^{-1}, s (R)&#x3D;R\cup R^{-1}$ </li><li>反对称：$R\cap R^{-1}\subseteq I_A$ </li><li>传递：$R\circ R\subseteq R, t (R)$ 使用 $\mathrm{Warshall}$ 算法 </li><li>$R_1,R_2$ 自反 $\Rightarrow R^{-1}, R_1\cap R_2, R_1\cup R_2, R_1\circ R_2$ 自反</li><li>$R_1, R_2$ 反自反&#x2F;对称 $\Rightarrow R^{-1}, R_1\cap R_2, R_1\cup R_2, R_1-R_2$ 反自反&#x2F;对称</li><li>$R_1, R_2$ 反对称 $\Rightarrow R^{-1}, R_1\cap R_2, R_1-R_2$ 反对称</li><li>$R_1, R_2$ 传递 $\Rightarrow R^{-1}, R_1\cap R_2$ 传递</li><li>$R_1\subseteq R_2\Rightarrow r&#x2F;s&#x2F;t (R_1)\subseteq r&#x2F;s&#x2F;t (R_2)$ </li><li>$r&#x2F;s (R_1)\cup r&#x2F;s (R_2)&#x3D;r&#x2F;s (R_1\cup R_2)$ </li><li>$t (R_1)\cup t (R_2)\subseteq t (R_1\cup R_2)$ </li><li>$R$ 自反 $\Rightarrow s&#x2F;t (R)$ 自反</li><li>$R$ 对称 $\Rightarrow r&#x2F;t (R)$ 对称</li><li>$R$ 传递 $\Rightarrow r (R)$ 传递</li><li>$rs (R)&#x3D;sr (R)$ </li><li>$rt (R)&#x3D;tr (R)$ </li><li>$st (R)\subseteq ts (R)$ </li><li>$(2022) R$ 的等价闭包：$tsr (R), trs (R), rts (R)$</li></ol><h3 id="3-特殊关系"><a href="#3-特殊关系" class="headerlink" title="3. 特殊关系"></a>3. 特殊关系</h3><ol><li>等价关系：自反、对称、传递</li><li>相容关系：自反、对称</li><li>偏序关系：自反、反对称、传递</li><li>拟序关系：反自反、反对称、传递</li><li>全序关系：两两都可比的偏序关系</li><li>良序关系：任意非空子集都有最小元的偏序关系</li><li>偏序关系八大元与链<ol><li>最大&#x2F;小元、上&#x2F;下确界不一定存在，若存在必唯一</li><li>非空有限集合中极大&#x2F;小元一定存在，但不一定唯一</li><li>最大&#x2F;小元为极大&#x2F;小元、上&#x2F;下界、上&#x2F;下确界</li><li>属于子集的上&#x2F;下界为子集的最大&#x2F;小元</li><li>最长链的长度为 $n\Rightarrow$ 至少存在 $n$ 个不相交的反链</li></ol></li><li>良序集一定是全序集</li><li>有限全序集一定是良序集</li><li>良序定理：任意集合都可以良序化</li></ol><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><h3 id="1-函数的性质"><a href="#1-函数的性质" class="headerlink" title="1. 函数的性质"></a>1. 函数的性质</h3><ol><li>$f, g$ 是满射&#x2F;单射&#x2F;双射 $\Rightarrow f\circ g$ 是满射&#x2F;单射&#x2F;双射</li><li>$f\circ g$ 是满射 $\Rightarrow f$ 是满射</li><li>$f\circ g$ 是单射 $\Rightarrow g$ 是单射</li><li>$f\circ g$ 是双射 $\Rightarrow f$ 是满射，$g$ 是单射</li><li>左逆：$g\circ f&#x3D;I_A$；右逆：$f\circ g&#x3D;I_A$ </li><li>$f$ 存在左逆&#x2F;右逆 $\Leftrightarrow$ $f$ 是单射&#x2F;满射</li><li>$f$ 存在左逆、右逆且两者相等 $\Leftrightarrow f$ 是双射</li><li>存在单射：$m\le n$；满射：$m\ge n\gt 0\vee m&#x3D;n&#x3D;0$；双射：$m&#x3D;n$ </li><li>函数与函数相容：$x\in A\cap C\Rightarrow f (x)&#x3D;g (x)$ </li><li>函数与等价关系相容：$\langle x, y\rangle\in R\Rightarrow \langle f (x), f (y)\rangle \in R$ </li><li>$f, g$ 相容 $\Leftrightarrow$ $f\cup g$ 是函数 $\Leftrightarrow f\uparrow (A\cap C)&#x3D;g\uparrow (A\cap C)$ </li><li>函数集合 $C$ 相容 $\Rightarrow F&#x3D;\bigcup C$ 是函数，$dom (F)&#x3D;\bigcup \{dom (f)|f\in C\}$ </li><li>$R$ 与 $f$ 相容 $\Rightarrow$ $\exists ! F: A&#x2F;R\to A&#x2F;R, F ([x]_R)&#x3D;[f (x)]_R$</li></ol><h3 id="2-开集与闭集"><a href="#2-开集与闭集" class="headerlink" title="2. 开集与闭集"></a>2. 开集与闭集</h3><ol><li>闭集：导集是原集合的子集</li><li>任意集合的导集是闭集</li><li>任意个闭集的交集是闭集，有限个闭集的并集是闭集</li><li>开集：原集合是内点集合的子集</li><li>任意个开集的并集是开集，有限个开集的交集是开集</li><li>若 $A$ 是开集&#x2F;闭集，则 $\mathbb R-A$ 是闭集&#x2F;开集</li></ol><h3 id="3-实数"><a href="#3-实数" class="headerlink" title="3. 实数"></a>3. 实数</h3><ol><li>$\mathbb N\to \mathbb Z\to \mathbb Q_1\to \mathbb Q\to \mathbb B\to \mathbb R$ </li><li>$1_\mathbb N&#x3D;\{\emptyset\}, -1_\mathbb Z&#x3D;\langle 0,1\rangle,-1_\mathbb Q&#x3D;\{\frac{1}{-1},\frac{-1}{1},\frac{2}{-2},\frac{-2}{2},\dots\},-1_\mathbb R&#x3D;\{-1,-1+\frac{1}{n},\dots\}$ </li><li>$\mathbb N\approx \mathbb Z, \mathbb R\approx \mathbb R^+, \mathbb N\times \mathbb N\approx \mathbb N, \mathbb N\approx \mathbb Q, (0,1)\approx \mathbb R,[0,1]\approx (0,1),\neg \mathbb N\approx \mathbb R$</li><li>$P (A)\approx A_2,\neg A\approx P (A)$ </li><li>$(2022) \mathbb R\approx \mathbb R\times \mathbb N$</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>大一上</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第二讲 数学软件与线性代数</title>
    <link href="/43Class/43Class-2/"/>
    <url>/43Class/43Class-2/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第二讲，介绍了 Mathematica 和 MATLAB 的基本用法，主要包括线性方程组的求解、线性空间与内积空间的相关理论、行列式、特征值与奇异值分解等内容。</p><span id="more"></span><blockquote><p>计算的目的不在于数字本身，而在于洞察其背后的意义。 -Richard Hamming</p></blockquote><p>笃实 43 班的同学们大家好，这里是学委小组的第二期推送。本期我们将结合 Mathematica、MATLAB，帮助大家从头开始复习一遍线性代数。</p><p>考虑到不同老师的教学顺序不同，我们将采用我们自己认为最合理的顺序进行复习。如果屏幕前你的老师是从行列式讲起的，我们希望这篇推送能帮你重新建立起对线性代数的整体理解。</p><h2 id="前言：Mathematica-与-MATLAB-简介"><a href="#前言：Mathematica-与-MATLAB-简介" class="headerlink" title="前言：Mathematica 与 MATLAB 简介"></a>前言：Mathematica 与 MATLAB 简介</h2><p>Mathematica 是由 Wolfram 开发的一款科学计算软件，内置了大量函数可以直接调用，能够大大简化解决数学问题时的计算过程。此外，Wolfram 还提供了一个线上计算平台：<a href="https://www.wolframalpha.com/%E3%80%82">https://www.wolframalpha.com/。</a></p><p>MATLAB 则更加强大，在深度学习、计算机视觉、图像识别等领域都有广泛的应用。但考虑到篇幅所限以及解释型语言较难入门，本文只介绍 MATLAB 的基本矩阵运算指令。</p><p>Mathematica 和 MATLAB 的下载与安装详见信息服务中心 its.tsinghua.edu.cn，篇幅有限，此处不再赘述。</p><p><img src="/img/43Class-2/1.jpg"></p><p>上图是 Mathematica 的启动界面，点按新文档按钮进入如下图所示的编辑界面：</p><p><img src="/img/43Class-2/2.jpg"></p><p>在空白页面中输入指令完毕后点按红色的计算按钮运行指令。</p><p><img src="/img/43Class-2/3.jpg"></p><p>上图是 MATLAB 的操作界面，在命令行窗口中输入指令后按回车键执行指令。</p><h2 id="一、逆矩阵：求解线性方程组唯一解"><a href="#一、逆矩阵：求解线性方程组唯一解" class="headerlink" title="一、逆矩阵：求解线性方程组唯一解"></a>一、逆矩阵：求解线性方程组唯一解</h2><p>线性代数的建立源于对线性方程组的求解。对于有唯一解的线性方程组，我们可以通过对系数矩阵求逆来求出方程的唯一解。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算逆矩阵 *)<br>Inverse[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算逆矩阵</span><br>inv([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>如何保存求逆时高斯消元的具体过程呢？为此我们推出了 LU 分解，又因为 LU 分解不唯一以及 LU 分解与逆矩阵的存在性不等价，我们分别推出了 LDU 分解和 PLU 分解。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 LU/PLU 分解 *)<br>LUDecomposition[&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>&#125;&#125;]<br>(* 输出的第一个元素为一个 <span class="hljs-number">3</span>*<span class="hljs-number">3</span> 矩阵，其中包含对角线的上三角为 U 矩阵，不含对角线的下三角加上 I 为 L 矩阵；输出的第二个 <span class="hljs-number">3</span>*<span class="hljs-number">1</span> 的元素代表 P 矩阵 *)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 LU/LUP 分解</span><br>[L,U,P]=lu([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>])<br></code></pre></td></tr></table></figure><p>而对于有无数解的线性方程组，我们需要线性空间相关理论求出线性方程组的全体解；对于无解的线性方程组，我们可以通过最小二乘法求出最接近解的伪解，而这需要内积空间的相关理论。接下来，我们将按照线性空间→内积空间的顺序依次解决这两个问题。</p><h2 id="二、线性空间：求解线性方程组全体解"><a href="#二、线性空间：求解线性方程组全体解" class="headerlink" title="二、线性空间：求解线性方程组全体解"></a>二、线性空间：求解线性方程组全体解</h2><p>通过 10 条性质，我们定义了抽象线性空间，又通过极大线性无关组、张成、基、维数研究了线性空间的基本性质。接着我们从线性空间回到矩阵，将向量组的秩推广到了矩阵的秩，并定义了矩阵的四个子空间。最后我们推出了线性代数基本定理 1。</p><p>线性代数基本定理 1：对于一个 $m\times n$ 矩阵，</p><ol><li>行空间与列空间的维数相等，等于矩阵的秩。</li><li>行空间与零空间都是 $\mathbb R^n$ 的子空间，且维数之和等于矩阵的行数。</li><li>列空间与左零空间都是 $\mathbb R^m$ 的子空间，且维数之和等于矩阵的行数。</li><li>借助线性空间理论，我们得出了线性方程组全体解的求解方法：全体解&#x3D;特解+零空间。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算线性方程组全体解 *)<br>(* 第一步：计算特解 *)<br>LinearSolve[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;]<br>(* 第二步：计算零空间 *)<br>NullSpace[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算线性方程组全体解</span><br><span class="hljs-comment">% 第一步：计算特解</span><br>x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]\[<span class="hljs-number">2</span>;<span class="hljs-number">5</span>;<span class="hljs-number">8</span>]<br><span class="hljs-comment">% 第二步：计算零空间</span><br>null([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><h2 id="三、内积空间：求解无解线性方程组的伪解"><a href="#三、内积空间：求解无解线性方程组的伪解" class="headerlink" title="三、内积空间：求解无解线性方程组的伪解"></a>三、内积空间：求解无解线性方程组的伪解</h2><p>我们首先定义了线性空间上的内积，推出了勾股定理、Cauchy-Schwarz 不等式，并通过内积定义了正交。接着我们借助正交理论研究矩阵的四个子空间，推出了线性代数基本定理 2。</p><p>线性代数基本定理 2：对于一个 $m\times n$ 矩阵 $A$，</p><ol><li>$A$ 的零空间与行空间互为 $\mathbb R^n$ 上的正交补。</li><li>$A$ 的左零空间与列空间互为 $\mathbb R^m$ 上的正交补。</li><li>$A$ 的行空间到列空间上存在双射 $T_1(x)&#x3D;Ax$。</li><li>$A$ 的列空间到行空间上存在双射 $T_2(x)&#x3D;A^Tx$。</li></ol><p>借助内积空间理论，我们研究了向量到矩阵列空间的投影。对于列向量线性无关的矩阵 $A$，我们推出了投影矩阵 $\mathbb P_{C(A)}&#x3D;A(A^TA)^{-1}A^T$，并推出了最小二乘法。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算最小二乘法 *)<br>LeastSquares[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">8</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算最小二乘法</span><br>A=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>b=[<span class="hljs-number">7</span>;<span class="hljs-number">7</span>;<span class="hljs-number">8</span>]<br>x=inv(A^&#123;\prime&#125;*A)*A^&#123;\prime&#125;*b<br></code></pre></td></tr></table></figure><p>但我们发现投影矩阵的求解过程计算量过大，于是我们借助 Gram-Schmidt 正交化得到了正交矩阵，对于正交矩阵 $Q$，投影矩阵 $\mathbb P_{C(Q)}&#x3D;QQ^T$，大大简化了计算。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 QR 分解 *)<br>&#123;q,r&#125;=QRDecomposition[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 QR 分解</span><br>[Q,R]=qr([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>而对于列向量线性相关的矩阵 $A$，$A^TA$ 不可逆，求解投影矩阵需要先求出伪逆，而伪逆需要奇异值分解相关理论，接下来我们将通过行列式→特征值→奇异值分解的顺序解决这个问题。</p><h2 id="四、行列式，特征值与奇异值：求解伪逆"><a href="#四、行列式，特征值与奇异值：求解伪逆" class="headerlink" title="四、行列式，特征值与奇异值：求解伪逆"></a>四、行列式，特征值与奇异值：求解伪逆</h2><p>行列式的讲解方法一直存在很大争议。我们认为，通过行列式的线性性质推出 Leibnitz 展开，再推出 Laplace 展开是比较合理的顺序。借助行列式，我们推出了矩阵可逆的充要条件是矩阵的行列式不为零。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算矩阵行列式 *)<br>Det[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算矩阵行列式</span><br>det([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br><span class="hljs-comment">% 行列式为 0 时由于浮点数误差往往输出并不为 0</span><br></code></pre></td></tr></table></figure><p>借助行列式理论，我们得到了特征值与特征向量的求解方法：求解方程 $det(\lambda I_n-A)&#x3D;0$，再求解 $N(\lambda I_n-A)$。若特征向量足够张成整个 $\mathbb R^n$，则矩阵可以相似对角化。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算矩阵特征值与特征向量 *)<br>Eigensystem[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br>(* 输出的第一个元素为特征值集合，第二个元素为特征值分别对应的特征向量 *)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算矩阵特征值与特征向量</span><br>[V,D]=eig([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br><span class="hljs-comment">% V 为特征向量矩阵，D 为特征值矩阵</span><br></code></pre></td></tr></table></figure><p>但并非所有矩阵都能够相似对角化，但我们发现所有方阵都与上三角矩阵相似，于是我们推出了 Schur 分解以及 Jordan 分解。这部分内容会在下学期的高等线性代数选讲课程中详细介绍，不在本学期考察范围内，有大致了解即可。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算 Schur 分解和 Jordan 分解 *)<br>&#123;q,t&#125;=SchurDecomposition[&#123;&#123;<span class="hljs-number">2.7</span>,<span class="hljs-number">4.8</span>,<span class="hljs-number">8.1</span>&#125;,&#123;<span class="hljs-number">-0.6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>&#125;&#125;]<br>&#123;v,<span class="hljs-built_in">j</span>&#125;=JordanDecomposition[&#123;&#123;<span class="hljs-number">27</span>,<span class="hljs-number">48</span>,<span class="hljs-number">81</span>&#125;,&#123;<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算 Schur 分解和 Jordan 分解</span><br>[Q,T]=schur([<span class="hljs-number">2.7</span>,<span class="hljs-number">4.8</span>,<span class="hljs-number">8.1</span>;<span class="hljs-number">-0.6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0.1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.3</span>])<br>[V,J]=jordan([<span class="hljs-number">27</span>,<span class="hljs-number">48</span>,<span class="hljs-number">81</span>;<span class="hljs-number">-6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])<br><span class="hljs-comment">% jordan 函数需要 Symbolic Math Toolbox 库</span><br></code></pre></td></tr></table></figure><p>然而有一类矩阵一定能够相似对角化：实对称矩阵，且其特征向量之间还满足正交性，于是我们研究了实对称矩阵以及其特殊分支正定矩阵的正交相似对角化。</p><p>至此，我们终于得到了足够的理论依据，得以推出奇异值分解理论。奇异值分解的求解方法是：先求解 $A^TA$ 的特征值与特征向量，得出右奇异向量以及奇异值，再借助右奇异向量和 $N(A^T)$ 解出左奇异向量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算奇异值分解 *)<br>&#123;u,s,v&#125;=SingularValueDecomposition[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算奇异值分解</span><br>[U,S,V]=svd([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>借助奇异值分解，我们推出了伪逆的求解方法：设 $A$ 的奇异值分解为 $A&#x3D;U\Sigma V^T$，则 $A$ 的伪逆 $A^+&#x3D;V\Sigma^+ U^T$，其中 $\Sigma^+$ 为 $\Sigma$ 取转置后再取对角元素的倒数。借助伪逆，我们得以求解列向量线性相关矩阵的投影矩阵：$\mathbb P_{C(A)}&#x3D;AA^+$。此外，可以证明，对于前文线性代数基本定理2中的双射 $T_1(x)$ 和 $T_2(x)$，其逆映射分别为 $T_1^{-1}(x)&#x3D;A^+x,T_2^{-1}(x)&#x3D;A^{T^+}x$。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB">(* Mathematica 计算伪逆 *)<br>PseudoInverse[&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MATLAB"><span class="hljs-comment">% MATLAB 计算伪逆</span><br>pinv([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><p>至此，我们已经完全解决了线性方程组 $Ax&#x3D;b$ 的求解或伪解问题。那如果将向量 $x$ 和 $b$ 也分别替换为矩阵 $X$ 和 $B$，我们又该如何求矩阵方程 $AX&#x3D;B$ 的解或伪解呢？</p><p>显然当 $A$ 固定时伪解可以逐列求得，即 $X&#x3D;A^+B$ ，因此更值得讨论的是当 $A$ 变化时如何寻找一个最佳的 $A$ 使得伪解 $X$ 的误差最小。用矩阵论的语言来说，就是当 $rank(A)&#x3D;k$ 固定时，寻找一个最佳矩阵 $A_k$ 使得 $B-\mathbb P_{C(A_k)}B$ 的 Frobenius 范数最小，而这就是主成分分析问题。</p><p>实际上若 $A_k$ 满足条件，则所有列空间与 $A_k$ 的列空间相同的矩阵都满足条件：与其说我们求解的是一个最佳矩阵，不如说我们求解的是一个最佳子空间。因此我们不妨取一个列向量为该子空间标准正交基的矩阵 $Q_k$，借助奇异值分解理论，可以证明：若 $B$ 有奇异值分解 $\displaystyle B&#x3D;U\Sigma V^T&#x3D;\sum^r_{i&#x3D;1}\sigma_i u_i v_i^T$，则当 $Q_k&#x3D;[u_1,u_2,\dots ,u_k]$ 时，有 $\displaystyle||B-\mathbb P_{C(Q_k)}B||_{F_{min}}&#x3D;\sum^r_{i&#x3D;k+1}\sigma_i^2$。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>篇幅所限，课程中涉及的大量推论、应用和证明技巧以及和微积分的联系在本文中都没有覆盖到，还请大家认真复习。最后，下面两个表格分别是特殊矩阵的特征根与特征向量和矩阵可逆与奇异的等价条件。希望能帮助大家串联起整个线性代数体系。</p><p><img src="/img/43Class-2/4.jpg"></p><p><img src="/img/43Class-2/5.jpg"></p><p>这期的内容到这里就结束了，感谢大家读到这里。这里推荐一本书《Introduction to Linear Algebra》-Gilbert Strang，事实上本文的复习顺序就是受到了这本书的启发，且上面的两个表格也正来自这本书。</p><p>原定本期更新的 Markdown 和 LaTeX 环境的配置过程和入门语法将顺延到寒假期间更新，在这里先预祝各位同学期末考试顺利。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肆叁小灶第一讲 Standard Template Library (STL)</title>
    <link href="/43Class/43Class-1/"/>
    <url>/43Class/43Class-1/</url>
    
    <content type="html"><![CDATA[<p>肆叁小灶第一讲，介绍了 STL 库的基本用法，主要包括 deque 和 set 的使用方法以及一些常用的 STL 函数。</p><span id="more"></span><p>笃实43班的同学们大家好，这里是学委小组的第一期推送。</p><p>经过半学期的沉淀<del>（摸鱼）</del>，在小组内部以及和吴导商量过后，我们已经有了接下来工作计划的雏形：由褚一枫同学来负责制作介绍编程相关知识的推送，而邓写意同学负责编程月赛等活动的组织工作。</p><p>考虑到篇幅所限，每期介绍的内容不会很多、很深，会以一些课上不讲的小技巧以及一些实用软件的简略介绍为主，更多细节最终还是要靠大家自己去探索。</p><p>本学期内我们预计将发布四期：</p><ol><li>STL</li><li>Markdown 与 LaTeX</li><li>常用数学软件</li><li>常用编程 AI</li></ol><p>废话不多说，让我们直接进入正题。</p><h2 id="一、What-is-STL"><a href="#一、What-is-STL" class="headerlink" title="一、What is STL ?"></a>一、What is STL ?</h2><p>如果直接去百度上搜索，大概率会得到如下结果：</p><blockquote><p>STL 是 C++ 标准模板库（Standard Template Library）的缩写，是 C++ 标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个包罗数据结构与算法的软件框架。</p></blockquote><p>问题来了，数据结构又是什么？</p><p>简而言之，数据结构就是数据存储在计算机里的样子。比如一维数组就是一个最简单的数据结构，数据在内存里连续排列，可以按照顺序逐个访问。</p><p>更“高级”一点的数据结构还包括二维数组（矩阵）、链表、栈、队列、树、图等等，其中二维数组和链表我们已经在程设课上接触过了，而栈和队列分别是深度优先搜索（DFS）和广度优先搜索（BFS）的底层架构，再过两周程设课就会讲到，至于树和图，则是离散数学和数据结构这两门课的常客。</p><p>就像我们只需要引入标准输入输出库 stdio.h 就可以直接实现输入和输出而无需进行命令行操作一样，我们只需要引入 STL 库和 std 命名空间，就可以通过一些简单的函数直接实现这些数据结构。</p><p>而不同于标准输入输出库，STL 库是很多个库的合称，如 vector、stack、algorithm 等，考虑到篇幅所限，我们今天主要介绍两个模板：双端队列 deque 和集合 set。</p><h2 id="二、What-is-Deque"><a href="#二、What-is-Deque" class="headerlink" title="二、What is Deque ?"></a>二、What is Deque ?</h2><p>还记得前面说到的栈和队列吗？我们先简要介绍一下这两个数据结构。</p><p>栈的特点是“先进后出”，简而言之，可以把它理解成往一个桶里一边塞衣服一边把衣服取出来，显然只能取出叠在最上面的衣服，而塞的越早的衣服就叠在越下面，也就要越晚才能再次被取出来。</p><p>举一个简单的例子，按顺序进行以下操作：</p><p>1 入栈，2 入栈，3 入栈，3 出栈，2 出栈，4 入栈，4 出栈，1 出栈，5 入栈，5 出栈。</p><p>这样我们就成功的把 [1,2,3,4,5] 通过一个栈转化成了 [3,2,4,1,5]。</p><p>下面这张图可以辅助大家理解：</p><p><img src="/img/43Class-1/1.jpg"></p><p>而队列则和栈恰好相反，特点是“先进先出”，可以理解为在食堂排队，先入队的自然能先领到午饭。</p><p>同样举一个简单的例子：</p><p>1 入队，2 入队，3 入队，1 出队，4 入队，2 出队，3 出队，5 入队，4 出队，5 出队。</p><p>可能你会发现，这样一通操作下来不还是 [1,2,3,4,5] 吗？没错，因为这并不是队列的正确用途。等大家学到广度优先搜索就会明白队列的作用了。</p><p>同样给一张图辅助大家理解：</p><p><img src="/img/43Class-1/2.jpg"></p><p>所以讲了那么久的栈和队列，Deque呢？</p><p>我知道你很急，但你先别急。</p><p>Deque 的全称是 Double Queue（双端队列），简而言之，它既可以从前面插入可以从后面插入，既可以从前面取出也可以从后面取出。</p><p>可见，数组、栈和队列都可以视作 Deque 的一个“特殊情况”：数组只从后面插入而不取出，栈从后插入、从后取出，队列从后插入、从前取出。那么二维数组呢？也很简单，只需要让一个 Deque 的每个元素又都各是一个 Deque 即可。而且 Deque 模板无需提前给定大小，也就是自动实现了动态数组的功能。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tuple_cmp</span><span class="hljs-params">(tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a,tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)==<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(a)&gt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(a)&gt;<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(b);<br>&#125;<span class="hljs-comment">//基于tuple的二元组降序排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_matrix</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;deque&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>            temp.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        matrix.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<span class="hljs-comment">//输入：先创建临时一维deque存储一行，再把一整行导入二维deque</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,matrix[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<span class="hljs-comment">//输出：deque允许通过下标访问</span><br>&#125;<span class="hljs-comment">//基于deque的动态二元数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_sorted_tuple</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; sorted_tuple;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);<br>        tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; temp=<span class="hljs-built_in">make_tuple</span>(x,y);<br>        sorted_tuple.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<span class="hljs-comment">//输入：先创建临时tuple存储二元组，再将整个tuple导入deque</span><br>    <span class="hljs-built_in">stable_sort</span>(sorted_tuple.<span class="hljs-built_in">begin</span>(),sorted_tuple.<span class="hljs-built_in">end</span>(),tuple_cmp);<span class="hljs-comment">//对tuple组成的deque进行降序排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(sorted_tuple[i]),<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(sorted_tuple[i]));<br>    &#125;<span class="hljs-comment">//输出：tuple不允许用下标[0][1]访问，只能用get函数</span><br>&#125;<span class="hljs-comment">//基于deque&amp;tuple&amp;sort的降序二元组数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_stack</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; stack;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        stack.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<span class="hljs-comment">//入栈</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack.<span class="hljs-built_in">back</span>());<br>        stack.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<span class="hljs-comment">//出栈</span><br>&#125;<span class="hljs-comment">//基于deque的栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_queue</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        queue.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<span class="hljs-comment">//入队</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,queue.<span class="hljs-built_in">front</span>());<br>        queue.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<span class="hljs-comment">//出队</span><br>&#125;<span class="hljs-comment">//基于deque的队列</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br>    <span class="hljs-keyword">switch</span>(op)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>          <span class="hljs-built_in">create_matrix</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>          <span class="hljs-built_in">create_sorted_tuple</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>          <span class="hljs-built_in">create_stack</span>();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>          <span class="hljs-built_in">create_queue</span>();<br>          <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，case 1&amp;3&amp;4 已经包括了如何创建一个 Deque、如何从前后插入和取出元素，接下来我们解释一下 case 2 中用到的多元组 tuple 和 sort 函数。</p><p>简而言之，tuple 是几个子元素组成的有序对，可以看成结构体的平替。case 2 的代码中已经包括了如何创建一个 tuple 元素、如何取出一个 tuple 中特定位置的子元素。</p><p>sort 函数位于 algorithm 库中，时间复杂度（可以简单理解为算法的效率）为 O(nlgn)，远远优秀于程设课讲的 O(n²) 的冒泡排序。其默认参数为对单元素（即非 tuple、pair、struct）组成的一维数组进行升序排列，因此上面 case 2 在对 tuple 进行降序排列时，需要自己写一个比较函数。此外，case 2 中使用了 stable_sort，其与 sort 的区别在于 stable_sort 会保持排序前后两个相同元素的相对位置，而 sort 不一定。</p><p>再补充一点，实际上 deque 库中同样有在任意位置插入或删除的函数 d.insert(n,x) 和 d.erase(n)，但由于底层架构的原因这两个操作的复杂度都是 O(n) 而非 O(1)，无法平替链表。如需使用 STL 实现链表可以引入 list 库，这里由于篇幅所限就不展开了。<del>留给读者作为课后习题</del></p><h2 id="三、What-is-Set"><a href="#三、What-is-Set" class="headerlink" title="三、What is Set ?"></a>三、What is Set ?</h2><p>高中数学告诉我们，集合具有互异性，而 STL 中的 set 也是如此，可以将输入的数据自动去重。不同的是，它还能实现自动排序。如向一个 set 中输入 [1,5,3,5,7,4]，输出的结果会是 [1,3,4,5,7]。值得一提的是，set 的插入操作时间复杂度为 O(lgn)，也就是说它可以做到以 sort 函数的效率持续维护一个升序数组。</p><p>此外，STL 也提供了 multiset（升序，不去重）、unordered_set（无序，去重）、unordered_multiset（无序，不去重）等功能，可以按需使用。</p><p>以下是参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; s1,s2,cap,cup,diff;<br>    <span class="hljs-type">int</span> n1,n2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n1; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<span class="hljs-comment">//输入s1</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1：set不允许通过下标访问，只能通过迭代器访问</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n2; i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(x);<br>    &#125;<span class="hljs-comment">//输入s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it!=s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_union</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cup, cup.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1∪s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">begin</span>(); it!=cup.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1∪s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_intersection</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(cap, cap.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1∩s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cap.<span class="hljs-built_in">begin</span>(); it!=cap.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1∩s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">set_difference</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(diff, diff.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//计算s1-s2</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=diff.<span class="hljs-built_in">begin</span>(); it!=diff.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>    &#125;<span class="hljs-comment">//输出s1-s2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it=cup.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中的第一个3</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator a=cup.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中第一个≥3的数</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator b=cup.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//寻找并集中第一个＞3的数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, *it, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),it));<span class="hljs-comment">//输出第一个3的“下标”</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),a), *a);<span class="hljs-comment">//输出第一个≥3的数的“下标”</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-built_in">distance</span>(cup.<span class="hljs-built_in">begin</span>(),b), *b);<span class="hljs-comment">//输出第一个&gt;3的数的“下标”</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中已经包含了如何创建一个 set、如何向 set 中插入元素，接下来我们解释一下代码中用到的迭代器 iterator 和几个 algorithm 库函数。</p><p>强调一点：set 与 deque 不同，不能直接通过下标访问，只能通过地址访问。而 iterator 可以简单理解为 STL 容器专用指针，注意这里不能直接用指针的原因是通过 STL 容器存储的元素在内存中的位置不一定是连续的，用指针的 ++ 操作很可能访问到内存中错误的位置，而使用 iterator 就可以避免这个问题。</p><p>此外，代码中用到了七个 algorithm 库函数，我们分别做一下简要介绍：</p><ol><li>set_union：求两个有序列表的并集</li><li>set_intersection：求两个有序列表的交集</li><li>set_difference：求两个有序列表的差集</li><li>s.find(x)：返回列表中x元素第一次出现的地址</li><li>s.lowerbound(x)：返回有序列表中第一个≥x的元素的地址</li><li>s.upperbound(x)：返回有序列表中第一个&gt;x的元素的地址</li><li>distance：求两个迭代器之间的距离</li></ol><p>上面的代码稍作修改就可以无痛速通这道程设 OJ 作业：</p><p><img src="/img/43Class-1/3.jpg"></p><p>当然，这道题的输入数据已经是升序排列的了，也就不需要再使用 set 容器，直接使用普通数组或前面介绍的 deque 容器配合上述 algorithm 库函数即可。实际上 algorithm 库中还有很多有奇效的函数，如 next_permutation 等等，由于篇幅所限就不展开了。<del>同样留作课后习题</del></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>考虑到初学 C 语言的同学了解底层架构的必要性，STL 库在 OJ 作业和期末考试中是禁用的，切勿模板一时爽期末火葬场（据学长所说数据结构课也是禁用 STL 的）。然而在大作业中 STL 库可以随意使用，能够大幅提升代码构建效率和运行效率。此外，对于想参加算法竞赛的同学，个人建议在熟练使用的同时也去了解一下 STL 库函数的底层实现，可以大大加深对数据结构与算法优化的理解。</p><p>这期的内容到这里就结束了，感谢大家读到这里。下期我们将为大家简要介绍 Markdown 和 LaTeX 环境的配置过程和入门语法，这些内容对正在修读离散数学（1）的同学可能并不陌生，希望能够帮到未选课的同学。</p>]]></content>
    
    
    <categories>
      
      <category>推送</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>肆叁小灶</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
